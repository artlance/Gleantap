/* library */

/* mask */
"use strict"; !function (t) { "function" == typeof define && define.amd ? define(["jquery"], t) : "object" == typeof exports ? module.exports = t(require("jquery")) : t(jQuery || Zepto) }(function (t) { var a = function (a, e, n) { a = t(a); var r, s = this, o = a.val(); e = "function" == typeof e ? e(a.val(), void 0, a, n) : e; var i = { invalid: [], getCaret: function () { try { var t, e = 0, n = a.get(0), r = document.selection, s = n.selectionStart; return r && -1 === navigator.appVersion.indexOf("MSIE 10") ? (t = r.createRange(), t.moveStart("character", a.is("input") ? -a.val().length : -a.text().length), e = t.text.length) : (s || "0" === s) && (e = s), e } catch (o) { } }, setCaret: function (t) { try { if (a.is(":focus")) { var e, n = a.get(0); e = n.createTextRange(), e.collapse(!0), e.moveEnd("character", t), e.moveStart("character", t), e.select() } } catch (r) { } }, events: function () { a.on("input.mask keyup.mask", i.behaviour).on("paste.mask drop.mask", function () { setTimeout(function () { a.keydown().keyup() }, 100) }).on("change.mask", function () { a.data("changed", !0) }).on("blur.mask", function () { o === a.val() || a.data("changed") || a.triggerHandler("change"), a.data("changed", !1) }).on("blur.mask", function () { o = a.val() }).on("focus.mask", function (a) { n.selectOnFocus === !0 && t(a.target).select() }).on("focusout.mask", function () { n.clearIfNotMatch && !r.test(i.val()) && i.val("") }) }, getRegexMask: function () { for (var t, a, n, r, o, i, c = [], l = 0; l < e.length; l++)t = s.translation[e.charAt(l)], t ? (a = t.pattern.toString().replace(/.{1}$|^.{1}/g, ""), n = t.optional, r = t.recursive, r ? (c.push(e.charAt(l)), o = { digit: e.charAt(l), pattern: a }) : c.push(n || r ? a + "?" : a)) : c.push(e.charAt(l).replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")); return i = c.join(""), o && (i = i.replace(new RegExp("(" + o.digit + "(.*" + o.digit + ")?)"), "($1)?").replace(new RegExp(o.digit, "g"), o.pattern)), new RegExp(i) }, destroyEvents: function () { a.off(["input", "keydown", "keyup", "paste", "drop", "blur", "focusout", ""].join(".mask ")) }, val: function (t) { var e, n = a.is("input"), r = n ? "val" : "text"; return arguments.length > 0 ? (a[r]() !== t && a[r](t), e = a) : e = a[r](), e }, getMCharsBeforeCount: function (t, a) { for (var n = 0, r = 0, o = e.length; o > r && t > r; r++)s.translation[e.charAt(r)] || (t = a ? t + 1 : t, n++); return n }, caretPos: function (t, a, n, r) { var o = s.translation[e.charAt(Math.min(t - 1, e.length - 1))]; return o ? Math.min(t + n - a - r, n) : i.caretPos(t + 1, a, n, r) }, behaviour: function (a) { a = a || window.event, i.invalid = []; var e = a.keyCode || a.which; if (-1 === t.inArray(e, s.byPassKeys)) { var n = i.getCaret(), r = i.val(), o = r.length, c = o > n, l = i.getMasked(), u = l.length, h = i.getMCharsBeforeCount(u - 1) - i.getMCharsBeforeCount(o - 1); return i.val(l), !c || 65 === e && a.ctrlKey || (8 !== e && 46 !== e && (n = i.caretPos(n, o, u, h)), i.setCaret(n)), i.callbacks(a) } }, getMasked: function (t) { var a, r, o = [], c = i.val(), l = 0, u = e.length, h = 0, f = c.length, v = 1, p = "push", d = -1; for (n.reverse ? (p = "unshift", v = -1, a = 0, l = u - 1, h = f - 1, r = function () { return l > -1 && h > -1 }) : (a = u - 1, r = function () { return u > l && f > h }); r();) { var k = e.charAt(l), g = c.charAt(h), m = s.translation[k]; m ? (g.match(m.pattern) ? (o[p](g), m.recursive && (-1 === d ? d = l : l === a && (l = d - v), a === d && (l -= v)), l += v) : m.optional ? (l += v, h -= v) : m.fallback ? (o[p](m.fallback), l += v, h -= v) : i.invalid.push({ p: h, v: g, e: m.pattern }), h += v) : (t || o[p](k), g === k && (h += v), l += v) } var y = e.charAt(a); return u !== f + 1 || s.translation[y] || o.push(y), o.join("") }, callbacks: function (t) { var r = i.val(), s = r !== o, c = [r, t, a, n], l = function (t, a, e) { "function" == typeof n[t] && a && n[t].apply(this, e) }; l("onChange", s === !0, c), l("onKeyPress", s === !0, c), l("onComplete", r.length === e.length, c), l("onInvalid", i.invalid.length > 0, [r, t, a, i.invalid, n]) } }; s.mask = e, s.options = n, s.remove = function () { var t = i.getCaret(); return i.destroyEvents(), i.val(s.getCleanVal()), i.setCaret(t - i.getMCharsBeforeCount(t)), a }, s.getCleanVal = function () { return i.getMasked(!0) }, s.init = function (e) { if (e = e || !1, n = n || {}, s.byPassKeys = t.jMaskGlobals.byPassKeys, s.translation = t.jMaskGlobals.translation, s.translation = t.extend({}, s.translation, n.translation), s = t.extend(!0, {}, s, n), r = i.getRegexMask(), e === !1) { n.placeholder && a.attr("placeholder", n.placeholder), t("input").length && "oninput" in t("input")[0] == !1 && "on" === a.attr("autocomplete") && a.attr("autocomplete", "off"), i.destroyEvents(), i.events(); var o = i.getCaret(); i.val(i.getMasked()), i.setCaret(o + i.getMCharsBeforeCount(o, !0)) } else i.events(), i.val(i.getMasked()) }, s.init(!a.is("input")) }; t.maskWatchers = {}; var e = function () { var e = t(this), r = {}, s = "data-mask-", o = e.attr("data-mask"); return e.attr(s + "reverse") && (r.reverse = !0), e.attr(s + "clearifnotmatch") && (r.clearIfNotMatch = !0), "true" === e.attr(s + "selectonfocus") && (r.selectOnFocus = !0), n(e, o, r) ? e.data("mask", new a(this, o, r)) : void 0 }, n = function (a, e, n) { n = n || {}; var r = t(a).data("mask"), s = JSON.stringify, o = t(a).val() || t(a).text(); try { return "function" == typeof e && (e = e(o)), "object" != typeof r || s(r.options) !== s(n) || r.mask !== e } catch (i) { } }; t.fn.mask = function (e, r) { r = r || {}; var s = this.selector, o = t.jMaskGlobals, i = t.jMaskGlobals.watchInterval, c = function () { return n(this, e, r) ? t(this).data("mask", new a(this, e, r)) : void 0 }; return t(this).each(c), s && "" !== s && o.watchInputs && (clearInterval(t.maskWatchers[s]), t.maskWatchers[s] = setInterval(function () { t(document).find(s).each(c) }, i)), this }, t.fn.unmask = function () { return clearInterval(t.maskWatchers[this.selector]), delete t.maskWatchers[this.selector], this.each(function () { var a = t(this).data("mask"); a && a.remove().removeData("mask") }) }, t.fn.cleanVal = function () { return this.data("mask").getCleanVal() }, t.applyDataMask = function (a) { a = a || t.jMaskGlobals.maskElements; var n = a instanceof t ? a : t(a); n.filter(t.jMaskGlobals.dataMaskAttr).each(e) }; var r = { maskElements: "input,td,span,div", dataMaskAttr: "*[data-mask]", dataMask: !0, watchInterval: 300, watchInputs: !0, watchDataMask: !1, byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91], translation: { 0: { pattern: /\d/ }, 9: { pattern: /\d/, optional: !0 }, "#": { pattern: /\d/, recursive: !0 }, A: { pattern: /[a-zA-Z0-9]/ }, S: { pattern: /[a-zA-Z]/ } } }; t.jMaskGlobals = t.jMaskGlobals || {}, r = t.jMaskGlobals = t.extend(!0, {}, r, t.jMaskGlobals), r.dataMask && t.applyDataMask(), setInterval(function () { t.jMaskGlobals.watchDataMask && t.applyDataMask() }, r.watchInterval) });

/*!
 * Chart.js v3.3.2
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Chart = e() }(this, (function () {
    "use strict"; const t = "undefined" == typeof window ? function (t) { return t() } : window.requestAnimationFrame; function e(e, i, n) { const o = n || (t => Array.prototype.slice.call(t)); let s = !1, a = []; return function (...n) { a = o(n), s || (s = !0, t.call(window, (() => { s = !1, e.apply(i, a) }))) } } function i(t, e) { let i; return function () { return e ? (clearTimeout(i), i = setTimeout(t, e)) : t(), e } } const n = t => "start" === t ? "left" : "end" === t ? "right" : "center", o = (t, e, i) => "start" === t ? e : "end" === t ? i : (e + i) / 2, s = (t, e, i) => "right" === t ? i : "center" === t ? (e + i) / 2 : e; var a = new class { constructor() { this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0 } _notify(t, e, i, n) { const o = e.listeners[n], s = e.duration; o.forEach((n => n({ chart: t, initial: e.initial, numSteps: s, currentStep: Math.min(i - e.start, s) }))) } _refresh() { const e = this; e._request || (e._running = !0, e._request = t.call(window, (() => { e._update(), e._request = null, e._running && e._refresh() }))) } _update(t = Date.now()) { const e = this; let i = 0; e._charts.forEach(((n, o) => { if (!n.running || !n.items.length) return; const s = n.items; let a, r = s.length - 1, l = !1; for (; r >= 0; --r)a = s[r], a._active ? (a._total > n.duration && (n.duration = a._total), a.tick(t), l = !0) : (s[r] = s[s.length - 1], s.pop()); l && (o.draw(), e._notify(o, n, t, "progress")), s.length || (n.running = !1, e._notify(o, n, t, "complete"), n.initial = !1), i += s.length })), e._lastDate = t, 0 === i && (e._running = !1) } _getAnims(t) { const e = this._charts; let i = e.get(t); return i || (i = { running: !1, initial: !0, items: [], listeners: { complete: [], progress: [] } }, e.set(t, i)), i } listen(t, e, i) { this._getAnims(t).listeners[e].push(i) } add(t, e) { e && e.length && this._getAnims(t).items.push(...e) } has(t) { return this._getAnims(t).items.length > 0 } start(t) { const e = this._charts.get(t); e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce(((t, e) => Math.max(t, e._duration)), 0), this._refresh()) } running(t) { if (!this._running) return !1; const e = this._charts.get(t); return !!(e && e.running && e.items.length) } stop(t) { const e = this._charts.get(t); if (!e || !e.items.length) return; const i = e.items; let n = i.length - 1; for (; n >= 0; --n)i[n].cancel(); e.items = [], this._notify(t, e, Date.now(), "complete") } remove(t) { return this._charts.delete(t) } };
/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */const r = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, l = "0123456789ABCDEF", c = t => l[15 & t], h = t => l[(240 & t) >> 4] + l[15 & t], d = t => (240 & t) >> 4 == (15 & t); function u(t) { var e = function (t) { return d(t.r) && d(t.g) && d(t.b) && d(t.a) }(t) ? c : h; return t ? "#" + e(t.r) + e(t.g) + e(t.b) + (t.a < 255 ? e(t.a) : "") : t } function f(t) { return t + .5 | 0 } const g = (t, e, i) => Math.max(Math.min(t, i), e); function p(t) { return g(f(2.55 * t), 0, 255) } function m(t) { return g(f(255 * t), 0, 255) } function x(t) { return g(f(t / 2.55) / 100, 0, 1) } function b(t) { return g(f(100 * t), 0, 100) } const _ = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/; const y = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/; function v(t, e, i) { const n = e * Math.min(i, 1 - i), o = (e, o = (e + t / 30) % 12) => i - n * Math.max(Math.min(o - 3, 9 - o, 1), -1); return [o(0), o(8), o(4)] } function w(t, e, i) { const n = (n, o = (n + t / 60) % 6) => i - i * e * Math.max(Math.min(o, 4 - o, 1), 0); return [n(5), n(3), n(1)] } function M(t, e, i) { const n = v(t, 1, .5); let o; for (e + i > 1 && (o = 1 / (e + i), e *= o, i *= o), o = 0; o < 3; o++)n[o] *= 1 - e - i, n[o] += e; return n } function k(t) { const e = t.r / 255, i = t.g / 255, n = t.b / 255, o = Math.max(e, i, n), s = Math.min(e, i, n), a = (o + s) / 2; let r, l, c; return o !== s && (c = o - s, l = a > .5 ? c / (2 - o - s) : c / (o + s), r = o === e ? (i - n) / c + (i < n ? 6 : 0) : o === i ? (n - e) / c + 2 : (e - i) / c + 4, r = 60 * r + .5), [0 | r, l || 0, a] } function S(t, e, i, n) { return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, n)).map(m) } function P(t, e, i) { return S(v, t, e, i) } function D(t) { return (t % 360 + 360) % 360 } function C(t) { const e = y.exec(t); let i, n = 255; if (!e) return; e[5] !== i && (n = e[6] ? p(+e[5]) : m(+e[5])); const o = D(+e[2]), s = +e[3] / 100, a = +e[4] / 100; return i = "hwb" === e[1] ? function (t, e, i) { return S(M, t, e, i) }(o, s, a) : "hsv" === e[1] ? function (t, e, i) { return S(w, t, e, i) }(o, s, a) : P(o, s, a), { r: i[0], g: i[1], b: i[2], a: n } } const O = { x: "dark", Z: "light", Y: "re", X: "blu", W: "gr", V: "medium", U: "slate", A: "ee", T: "ol", S: "or", B: "ra", C: "lateg", D: "ights", R: "in", Q: "turquois", E: "hi", P: "ro", O: "al", N: "le", M: "de", L: "yello", F: "en", K: "ch", G: "arks", H: "ea", I: "ightg", J: "wh" }, T = { OiceXe: "f0f8ff", antiquewEte: "faebd7", aqua: "ffff", aquamarRe: "7fffd4", azuY: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "0", blanKedOmond: "ffebcd", Xe: "ff", XeviTet: "8a2be2", bPwn: "a52a2a", burlywood: "deb887", caMtXe: "5f9ea0", KartYuse: "7fff00", KocTate: "d2691e", cSO: "ff7f50", cSnflowerXe: "6495ed", cSnsilk: "fff8dc", crimson: "dc143c", cyan: "ffff", xXe: "8b", xcyan: "8b8b", xgTMnPd: "b8860b", xWay: "a9a9a9", xgYF: "6400", xgYy: "a9a9a9", xkhaki: "bdb76b", xmagFta: "8b008b", xTivegYF: "556b2f", xSange: "ff8c00", xScEd: "9932cc", xYd: "8b0000", xsOmon: "e9967a", xsHgYF: "8fbc8f", xUXe: "483d8b", xUWay: "2f4f4f", xUgYy: "2f4f4f", xQe: "ced1", xviTet: "9400d3", dAppRk: "ff1493", dApskyXe: "bfff", dimWay: "696969", dimgYy: "696969", dodgerXe: "1e90ff", fiYbrick: "b22222", flSOwEte: "fffaf0", foYstWAn: "228b22", fuKsia: "ff00ff", gaRsbSo: "dcdcdc", ghostwEte: "f8f8ff", gTd: "ffd700", gTMnPd: "daa520", Way: "808080", gYF: "8000", gYFLw: "adff2f", gYy: "808080", honeyMw: "f0fff0", hotpRk: "ff69b4", RdianYd: "cd5c5c", Rdigo: "4b0082", ivSy: "fffff0", khaki: "f0e68c", lavFMr: "e6e6fa", lavFMrXsh: "fff0f5", lawngYF: "7cfc00", NmoncEffon: "fffacd", ZXe: "add8e6", ZcSO: "f08080", Zcyan: "e0ffff", ZgTMnPdLw: "fafad2", ZWay: "d3d3d3", ZgYF: "90ee90", ZgYy: "d3d3d3", ZpRk: "ffb6c1", ZsOmon: "ffa07a", ZsHgYF: "20b2aa", ZskyXe: "87cefa", ZUWay: "778899", ZUgYy: "778899", ZstAlXe: "b0c4de", ZLw: "ffffe0", lime: "ff00", limegYF: "32cd32", lRF: "faf0e6", magFta: "ff00ff", maPon: "800000", VaquamarRe: "66cdaa", VXe: "cd", VScEd: "ba55d3", VpurpN: "9370db", VsHgYF: "3cb371", VUXe: "7b68ee", VsprRggYF: "fa9a", VQe: "48d1cc", VviTetYd: "c71585", midnightXe: "191970", mRtcYam: "f5fffa", mistyPse: "ffe4e1", moccasR: "ffe4b5", navajowEte: "ffdead", navy: "80", Tdlace: "fdf5e6", Tive: "808000", TivedBb: "6b8e23", Sange: "ffa500", SangeYd: "ff4500", ScEd: "da70d6", pOegTMnPd: "eee8aa", pOegYF: "98fb98", pOeQe: "afeeee", pOeviTetYd: "db7093", papayawEp: "ffefd5", pHKpuff: "ffdab9", peru: "cd853f", pRk: "ffc0cb", plum: "dda0dd", powMrXe: "b0e0e6", purpN: "800080", YbeccapurpN: "663399", Yd: "ff0000", Psybrown: "bc8f8f", PyOXe: "4169e1", saddNbPwn: "8b4513", sOmon: "fa8072", sandybPwn: "f4a460", sHgYF: "2e8b57", sHshell: "fff5ee", siFna: "a0522d", silver: "c0c0c0", skyXe: "87ceeb", UXe: "6a5acd", UWay: "708090", UgYy: "708090", snow: "fffafa", sprRggYF: "ff7f", stAlXe: "4682b4", tan: "d2b48c", teO: "8080", tEstN: "d8bfd8", tomato: "ff6347", Qe: "40e0d0", viTet: "ee82ee", JHt: "f5deb3", wEte: "ffffff", wEtesmoke: "f5f5f5", Lw: "ffff00", LwgYF: "9acd32" }; let A; function L(t) { A || (A = function () { const t = {}, e = Object.keys(T), i = Object.keys(O); let n, o, s, a, r; for (n = 0; n < e.length; n++) { for (a = r = e[n], o = 0; o < i.length; o++)s = i[o], r = r.replace(s, O[s]); s = parseInt(T[a], 16), t[r] = [s >> 16 & 255, s >> 8 & 255, 255 & s] } return t }(), A.transparent = [0, 0, 0, 0]); const e = A[t.toLowerCase()]; return e && { r: e[0], g: e[1], b: e[2], a: 4 === e.length ? e[3] : 255 } } function R(t, e, i) { if (t) { let n = k(t); n[e] = Math.max(0, Math.min(n[e] + n[e] * i, 0 === e ? 360 : 1)), n = P(n), t.r = n[0], t.g = n[1], t.b = n[2] } } function E(t, e) { return t ? Object.assign(e || {}, t) : t } function I(t) { var e = { r: 0, g: 0, b: 0, a: 255 }; return Array.isArray(t) ? t.length >= 3 && (e = { r: t[0], g: t[1], b: t[2], a: 255 }, t.length > 3 && (e.a = m(t[3]))) : (e = E(t, { r: 0, g: 0, b: 0, a: 1 })).a = m(e.a), e } function z(t) { return "r" === t.charAt(0) ? function (t) { const e = _.exec(t); let i, n, o, s = 255; if (e) { if (e[7] !== i) { const t = +e[7]; s = 255 & (e[8] ? p(t) : 255 * t) } return i = +e[1], n = +e[3], o = +e[5], i = 255 & (e[2] ? p(i) : i), n = 255 & (e[4] ? p(n) : n), o = 255 & (e[6] ? p(o) : o), { r: i, g: n, b: o, a: s } } }(t) : C(t) } class F { constructor(t) { if (t instanceof F) return t; const e = typeof t; let i; var n, o, s; "object" === e ? i = I(t) : "string" === e && (s = (n = t).length, "#" === n[0] && (4 === s || 5 === s ? o = { r: 255 & 17 * r[n[1]], g: 255 & 17 * r[n[2]], b: 255 & 17 * r[n[3]], a: 5 === s ? 17 * r[n[4]] : 255 } : 7 !== s && 9 !== s || (o = { r: r[n[1]] << 4 | r[n[2]], g: r[n[3]] << 4 | r[n[4]], b: r[n[5]] << 4 | r[n[6]], a: 9 === s ? r[n[7]] << 4 | r[n[8]] : 255 })), i = o || L(t) || z(t)), this._rgb = i, this._valid = !!i } get valid() { return this._valid } get rgb() { var t = E(this._rgb); return t && (t.a = x(t.a)), t } set rgb(t) { this._rgb = I(t) } rgbString() { return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${x(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : this._rgb; var t } hexString() { return this._valid ? u(this._rgb) : this._rgb } hslString() { return this._valid ? function (t) { if (!t) return; const e = k(t), i = e[0], n = b(e[1]), o = b(e[2]); return t.a < 255 ? `hsla(${i}, ${n}%, ${o}%, ${x(t.a)})` : `hsl(${i}, ${n}%, ${o}%)` }(this._rgb) : this._rgb } mix(t, e) { const i = this; if (t) { const n = i.rgb, o = t.rgb; let s; const a = e === s ? .5 : e, r = 2 * a - 1, l = n.a - o.a, c = ((r * l == -1 ? r : (r + l) / (1 + r * l)) + 1) / 2; s = 1 - c, n.r = 255 & c * n.r + s * o.r + .5, n.g = 255 & c * n.g + s * o.g + .5, n.b = 255 & c * n.b + s * o.b + .5, n.a = a * n.a + (1 - a) * o.a, i.rgb = n } return i } clone() { return new F(this.rgb) } alpha(t) { return this._rgb.a = m(t), this } clearer(t) { return this._rgb.a *= 1 - t, this } greyscale() { const t = this._rgb, e = f(.3 * t.r + .59 * t.g + .11 * t.b); return t.r = t.g = t.b = e, this } opaquer(t) { return this._rgb.a *= 1 + t, this } negate() { const t = this._rgb; return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this } lighten(t) { return R(this._rgb, 2, t), this } darken(t) { return R(this._rgb, 2, -t), this } saturate(t) { return R(this._rgb, 1, t), this } desaturate(t) { return R(this._rgb, 1, -t), this } rotate(t) { return function (t, e) { var i = k(t); i[0] = D(i[0] + e), i = P(i), t.r = i[0], t.g = i[1], t.b = i[2] }(this._rgb, t), this } } function V(t) { return new F(t) } const B = t => t instanceof CanvasGradient || t instanceof CanvasPattern; function W(t) { return B(t) ? t : V(t) } function H(t) { return B(t) ? t : V(t).saturate(.5).darken(.1).hexString() } function N() { } const j = function () { let t = 0; return function () { return t++ } }(); function $(t) { return null == t } function Y(t) { if (Array.isArray && Array.isArray(t)) return !0; const e = Object.prototype.toString.call(t); return "[object" === e.substr(0, 7) && "Array]" === e.substr(-6) } function U(t) { return null !== t && "[object Object]" === Object.prototype.toString.call(t) } const X = t => ("number" == typeof t || t instanceof Number) && isFinite(+t); function q(t, e) { return X(t) ? t : e } function K(t, e) { return void 0 === t ? e : t } const G = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 : t / e, Z = (t, e) => "string" == typeof t && t.endsWith("%") ? parseFloat(t) / 100 * e : +t; function Q(t, e, i) { if (t && "function" == typeof t.call) return t.apply(i, e) } function J(t, e, i, n) { let o, s, a; if (Y(t)) if (s = t.length, n) for (o = s - 1; o >= 0; o--)e.call(i, t[o], o); else for (o = 0; o < s; o++)e.call(i, t[o], o); else if (U(t)) for (a = Object.keys(t), s = a.length, o = 0; o < s; o++)e.call(i, t[a[o]], a[o]) } function tt(t, e) { let i, n, o, s; if (!t || !e || t.length !== e.length) return !1; for (i = 0, n = t.length; i < n; ++i)if (o = t[i], s = e[i], o.datasetIndex !== s.datasetIndex || o.index !== s.index) return !1; return !0 } function et(t) { if (Y(t)) return t.map(et); if (U(t)) { const e = Object.create(null), i = Object.keys(t), n = i.length; let o = 0; for (; o < n; ++o)e[i[o]] = et(t[i[o]]); return e } return t } function it(t) { return -1 === ["__proto__", "prototype", "constructor"].indexOf(t) } function nt(t, e, i, n) { if (!it(t)) return; const o = e[t], s = i[t]; U(o) && U(s) ? ot(o, s, n) : e[t] = et(s) } function ot(t, e, i) { const n = Y(e) ? e : [e], o = n.length; if (!U(t)) return t; const s = (i = i || {}).merger || nt; for (let a = 0; a < o; ++a) { if (!U(e = n[a])) continue; const o = Object.keys(e); for (let n = 0, a = o.length; n < a; ++n)s(o[n], t, e, i) } return t } function st(t, e) { return ot(t, e, { merger: at }) } function at(t, e, i) { if (!it(t)) return; const n = e[t], o = i[t]; U(n) && U(o) ? st(n, o) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = et(o)) } function rt(t, e) { const i = t.indexOf(".", e); return -1 === i ? t.length : i } function lt(t, e) { if ("" === e) return t; let i = 0, n = rt(e, i); for (; t && n > i;)t = t[e.substr(i, n - i)], i = n + 1, n = rt(e, i); return t } function ct(t) { return t.charAt(0).toUpperCase() + t.slice(1) } const ht = t => void 0 !== t, dt = t => "function" == typeof t, ut = (t, e) => { if (t.size !== e.size) return !1; for (const i of t) if (!e.has(i)) return !1; return !0 }, ft = Object.create(null), gt = Object.create(null); function pt(t, e) { if (!e) return t; const i = e.split("."); for (let e = 0, n = i.length; e < n; ++e) { const n = i[e]; t = t[n] || (t[n] = Object.create(null)) } return t } function mt(t, e, i) { return "string" == typeof e ? ot(pt(t, e), i) : ot(pt(t, ""), e) } var xt = new class { constructor(t) { this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = t => t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = ["mousemove", "mouseout", "click", "touchstart", "touchmove"], this.font = { family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif", size: 12, style: "normal", lineHeight: 1.2, weight: null }, this.hover = {}, this.hoverBackgroundColor = (t, e) => H(e.backgroundColor), this.hoverBorderColor = (t, e) => H(e.borderColor), this.hoverColor = (t, e) => H(e.color), this.indexAxis = "x", this.interaction = { mode: "nearest", intersect: !0 }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.describe(t) } set(t, e) { return mt(this, t, e) } get(t) { return pt(this, t) } describe(t, e) { return mt(gt, t, e) } override(t, e) { return mt(ft, t, e) } route(t, e, i, n) { const o = pt(this, t), s = pt(this, i), a = "_" + e; Object.defineProperties(o, { [a]: { value: o[e], writable: !0 }, [e]: { enumerable: !0, get() { const t = this[a], e = s[n]; return U(t) ? Object.assign({}, e, t) : K(t, e) }, set(t) { this[a] = t } } }) } }({ _scriptable: t => !t.startsWith("on"), _indexable: t => "events" !== t, hover: { _fallback: "interaction" }, interaction: { _scriptable: !1, _indexable: !1 } }); const bt = Math.PI, _t = 2 * bt, yt = _t + bt, vt = Number.POSITIVE_INFINITY, wt = bt / 180, Mt = bt / 2, kt = bt / 4, St = 2 * bt / 3, Pt = Math.log10, Dt = Math.sign; function Ct(t) { const e = Math.pow(10, Math.floor(Pt(t))), i = t / e; return (i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * e } function Ot(t) { const e = [], i = Math.sqrt(t); let n; for (n = 1; n < i; n++)t % n == 0 && (e.push(n), e.push(t / n)); return i === (0 | i) && e.push(i), e.sort(((t, e) => t - e)).pop(), e } function Tt(t) { return !isNaN(parseFloat(t)) && isFinite(t) } function At(t, e, i) { return Math.abs(t - e) < i } function Lt(t, e) { const i = Math.round(t); return i - e <= t && i + e >= t } function Rt(t, e, i) { let n, o, s; for (n = 0, o = t.length; n < o; n++)s = t[n][i], isNaN(s) || (e.min = Math.min(e.min, s), e.max = Math.max(e.max, s)) } function Et(t) { return t * (bt / 180) } function It(t) { return t * (180 / bt) } function zt(t) { if (!X(t)) return; let e = 1, i = 0; for (; Math.round(t * e) / e !== t;)e *= 10, i++; return i } function Ft(t, e) { const i = e.x - t.x, n = e.y - t.y, o = Math.sqrt(i * i + n * n); let s = Math.atan2(n, i); return s < -.5 * bt && (s += _t), { angle: s, distance: o } } function Vt(t, e) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) } function Bt(t, e) { return (t - e + yt) % _t - bt } function Wt(t) { return (t % _t + _t) % _t } function Ht(t, e, i, n) { const o = Wt(t), s = Wt(e), a = Wt(i), r = Wt(s - o), l = Wt(a - o), c = Wt(o - s), h = Wt(o - a); return o === s || o === a || n && s === a || r > l && c < h } function Nt(t, e, i) { return Math.max(e, Math.min(i, t)) } function jt(t) { return Nt(t, -32768, 32767) } function $t(t) { return !t || $(t.size) || $(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family } function Yt(t, e, i, n, o) { let s = e[o]; return s || (s = e[o] = t.measureText(o).width, i.push(o)), s > n && (n = s), n } function Ut(t, e, i, n) { let o = (n = n || {}).data = n.data || {}, s = n.garbageCollect = n.garbageCollect || []; n.font !== e && (o = n.data = {}, s = n.garbageCollect = [], n.font = e), t.save(), t.font = e; let a = 0; const r = i.length; let l, c, h, d, u; for (l = 0; l < r; l++)if (d = i[l], null != d && !0 !== Y(d)) a = Yt(t, o, s, a, d); else if (Y(d)) for (c = 0, h = d.length; c < h; c++)u = d[c], null == u || Y(u) || (a = Yt(t, o, s, a, u)); t.restore(); const f = s.length / 2; if (f > i.length) { for (l = 0; l < f; l++)delete o[s[l]]; s.splice(0, f) } return a } function Xt(t, e, i) { const n = t.currentDevicePixelRatio, o = 0 !== i ? Math.max(i / 2, .5) : 0; return Math.round((e - o) * n) / n + o } function qt(t, e) { (e = e || t.getContext("2d")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore() } function Kt(t, e, i, n) { let o, s, a, r, l; const c = e.pointStyle, h = e.rotation, d = e.radius; let u = (h || 0) * wt; if (c && "object" == typeof c && (o = c.toString(), "[object HTMLImageElement]" === o || "[object HTMLCanvasElement]" === o)) return t.save(), t.translate(i, n), t.rotate(u), t.drawImage(c, -c.width / 2, -c.height / 2, c.width, c.height), void t.restore(); if (!(isNaN(d) || d <= 0)) { switch (t.beginPath(), c) { default: t.arc(i, n, d, 0, _t), t.closePath(); break; case "triangle": t.moveTo(i + Math.sin(u) * d, n - Math.cos(u) * d), u += St, t.lineTo(i + Math.sin(u) * d, n - Math.cos(u) * d), u += St, t.lineTo(i + Math.sin(u) * d, n - Math.cos(u) * d), t.closePath(); break; case "rectRounded": l = .516 * d, r = d - l, s = Math.cos(u + kt) * r, a = Math.sin(u + kt) * r, t.arc(i - s, n - a, l, u - bt, u - Mt), t.arc(i + a, n - s, l, u - Mt, u), t.arc(i + s, n + a, l, u, u + Mt), t.arc(i - a, n + s, l, u + Mt, u + bt), t.closePath(); break; case "rect": if (!h) { r = Math.SQRT1_2 * d, t.rect(i - r, n - r, 2 * r, 2 * r); break } u += kt; case "rectRot": s = Math.cos(u) * d, a = Math.sin(u) * d, t.moveTo(i - s, n - a), t.lineTo(i + a, n - s), t.lineTo(i + s, n + a), t.lineTo(i - a, n + s), t.closePath(); break; case "crossRot": u += kt; case "cross": s = Math.cos(u) * d, a = Math.sin(u) * d, t.moveTo(i - s, n - a), t.lineTo(i + s, n + a), t.moveTo(i + a, n - s), t.lineTo(i - a, n + s); break; case "star": s = Math.cos(u) * d, a = Math.sin(u) * d, t.moveTo(i - s, n - a), t.lineTo(i + s, n + a), t.moveTo(i + a, n - s), t.lineTo(i - a, n + s), u += kt, s = Math.cos(u) * d, a = Math.sin(u) * d, t.moveTo(i - s, n - a), t.lineTo(i + s, n + a), t.moveTo(i + a, n - s), t.lineTo(i - a, n + s); break; case "line": s = Math.cos(u) * d, a = Math.sin(u) * d, t.moveTo(i - s, n - a), t.lineTo(i + s, n + a); break; case "dash": t.moveTo(i, n), t.lineTo(i + Math.cos(u) * d, n + Math.sin(u) * d) }t.fill(), e.borderWidth > 0 && t.stroke() } } function Gt(t, e, i) { return i = i || .5, t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i } function Zt(t, e) { t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip() } function Qt(t) { t.restore() } function Jt(t, e, i, n, o) { if (!e) return t.lineTo(i.x, i.y); if ("middle" === o) { const n = (e.x + i.x) / 2; t.lineTo(n, e.y), t.lineTo(n, i.y) } else "after" === o != !!n ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y); t.lineTo(i.x, i.y) } function te(t, e, i, n) { if (!e) return t.lineTo(i.x, i.y); t.bezierCurveTo(n ? e.cp1x : e.cp2x, n ? e.cp1y : e.cp2y, n ? i.cp2x : i.cp1x, n ? i.cp2y : i.cp1y, i.x, i.y) } function ee(t, e, i, n, o, s = {}) { const a = Y(e) ? e : [e], r = s.strokeWidth > 0 && "" !== s.strokeColor; let l, c; for (t.save(), s.translation && t.translate(s.translation[0], s.translation[1]), $(s.rotation) || t.rotate(s.rotation), t.font = o.string, s.color && (t.fillStyle = s.color), s.textAlign && (t.textAlign = s.textAlign), s.textBaseline && (t.textBaseline = s.textBaseline), l = 0; l < a.length; ++l) { if (c = a[l], r && (s.strokeColor && (t.strokeStyle = s.strokeColor), $(s.strokeWidth) || (t.lineWidth = s.strokeWidth), t.strokeText(c, i, n, s.maxWidth)), t.fillText(c, i, n, s.maxWidth), s.strikethrough || s.underline) { const e = t.measureText(c), o = i - e.actualBoundingBoxLeft, a = i + e.actualBoundingBoxRight, r = n - e.actualBoundingBoxAscent, l = n + e.actualBoundingBoxDescent, h = s.strikethrough ? (r + l) / 2 : l; t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = s.decorationWidth || 2, t.moveTo(o, h), t.lineTo(a, h), t.stroke() } n += o.lineHeight } t.restore() } function ie(t, e) { const { x: i, y: n, w: o, h: s, radius: a } = e; t.arc(i + a.topLeft, n + a.topLeft, a.topLeft, -Mt, bt, !0), t.lineTo(i, n + s - a.bottomLeft), t.arc(i + a.bottomLeft, n + s - a.bottomLeft, a.bottomLeft, bt, Mt, !0), t.lineTo(i + o - a.bottomRight, n + s), t.arc(i + o - a.bottomRight, n + s - a.bottomRight, a.bottomRight, Mt, 0, !0), t.lineTo(i + o, n + a.topRight), t.arc(i + o - a.topRight, n + a.topRight, a.topRight, 0, -Mt, !0), t.lineTo(i + a.topLeft, n) } function ne(t, e, i) { i = i || (i => t[i] < e); let n, o = t.length - 1, s = 0; for (; o - s > 1;)n = s + o >> 1, i(n) ? s = n : o = n; return { lo: s, hi: o } } const oe = (t, e, i) => ne(t, i, (n => t[n][e] < i)), se = (t, e, i) => ne(t, i, (n => t[n][e] >= i)); function ae(t, e, i) { let n = 0, o = t.length; for (; n < o && t[n] < e;)n++; for (; o > n && t[o - 1] > i;)o--; return n > 0 || o < t.length ? t.slice(n, o) : t } const re = ["push", "pop", "shift", "splice", "unshift"]; function le(t, e) { t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, "_chartjs", { configurable: !0, enumerable: !1, value: { listeners: [e] } }), re.forEach((e => { const i = "_onData" + ct(e), n = t[e]; Object.defineProperty(t, e, { configurable: !0, enumerable: !1, value(...e) { const o = n.apply(this, e); return t._chartjs.listeners.forEach((t => { "function" == typeof t[i] && t[i](...e) })), o } }) }))) } function ce(t, e) { const i = t._chartjs; if (!i) return; const n = i.listeners, o = n.indexOf(e); -1 !== o && n.splice(o, 1), n.length > 0 || (re.forEach((e => { delete t[e] })), delete t._chartjs) } function he(t) { const e = new Set; let i, n; for (i = 0, n = t.length; i < n; ++i)e.add(t[i]); if (e.size === n) return t; const o = []; return e.forEach((t => { o.push(t) })), o } function de(t) { let e = t.parentNode; return e && "[object ShadowRoot]" === e.toString() && (e = e.host), e } function ue(t, e, i) { let n; return "string" == typeof t ? (n = parseInt(t, 10), -1 !== t.indexOf("%") && (n = n / 100 * e.parentNode[i])) : n = t, n } const fe = t => window.getComputedStyle(t, null); function ge(t, e) { return fe(t).getPropertyValue(e) } const pe = ["top", "right", "bottom", "left"]; function me(t, e, i) { const n = {}; i = i ? "-" + i : ""; for (let o = 0; o < 4; o++) { const s = pe[o]; n[s] = parseFloat(t[e + "-" + s + i]) || 0 } return n.width = n.left + n.right, n.height = n.top + n.bottom, n } function xe(t, e) { const { canvas: i, currentDevicePixelRatio: n } = e, o = fe(i), s = "border-box" === o.boxSizing, a = me(o, "padding"), r = me(o, "border", "width"), { x: l, y: c, box: h } = function (t, e) { const i = t.native || t, n = i.touches, o = n && n.length ? n[0] : i, { offsetX: s, offsetY: a } = o; let r, l, c = !1; if (((t, e, i) => (t > 0 || e > 0) && (!i || !i.shadowRoot))(s, a, i.target)) r = s, l = a; else { const t = e.getBoundingClientRect(); r = o.clientX - t.left, l = o.clientY - t.top, c = !0 } return { x: r, y: l, box: c } }(t, i), d = a.left + (h && r.left), u = a.top + (h && r.top); let { width: f, height: g } = e; return s && (f -= a.width + r.width, g -= a.height + r.height), { x: Math.round((l - d) / f * i.width / n), y: Math.round((c - u) / g * i.height / n) } } const be = t => Math.round(10 * t) / 10; function _e(t, e, i, n) { const o = fe(t), s = me(o, "margin"), a = ue(o.maxWidth, t, "clientWidth") || vt, r = ue(o.maxHeight, t, "clientHeight") || vt, l = function (t, e, i) { let n, o; if (void 0 === e || void 0 === i) { const s = de(t); if (s) { const t = s.getBoundingClientRect(), a = fe(s), r = me(a, "border", "width"), l = me(a, "padding"); e = t.width - l.width - r.width, i = t.height - l.height - r.height, n = ue(a.maxWidth, s, "clientWidth"), o = ue(a.maxHeight, s, "clientHeight") } else e = t.clientWidth, i = t.clientHeight } return { width: e, height: i, maxWidth: n || vt, maxHeight: o || vt } }(t, e, i); let { width: c, height: h } = l; if ("content-box" === o.boxSizing) { const t = me(o, "border", "width"), e = me(o, "padding"); c -= e.width + t.width, h -= e.height + t.height } return c = Math.max(0, c - s.width), h = Math.max(0, n ? Math.floor(c / n) : h - s.height), c = be(Math.min(c, a, l.maxWidth)), h = be(Math.min(h, r, l.maxHeight)), c && !h && (h = be(c / 2)), { width: c, height: h } } function ye(t, e, i) { const n = e || 1, o = Math.floor(t.height * n), s = Math.floor(t.width * n); t.height = o / n, t.width = s / n; const a = t.canvas; return a.style && (i || !a.style.height && !a.style.width) && (a.style.height = `${t.height}px`, a.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== n || a.height !== o || a.width !== s) && (t.currentDevicePixelRatio = n, a.height = o, a.width = s, t.ctx.setTransform(n, 0, 0, n, 0, 0), !0) } const ve = function () { let t = !1; try { const e = { get passive() { return t = !0, !1 } }; window.addEventListener("test", null, e), window.removeEventListener("test", null, e) } catch (t) { } return t }(); function we(t, e) { const i = ge(t, e), n = i && i.match(/^(\d+)(\.\d+)?px$/); return n ? +n[1] : void 0 } function Me(t, e) { return "native" in t ? { x: t.x, y: t.y } : xe(t, e) } function ke(t, e, i, n) { const { controller: o, data: s, _sorted: a } = t, r = o._cachedMeta.iScale; if (r && e === r.axis && a && s.length) { const t = r._reversePixels ? se : oe; if (!n) return t(s, e, i); if (o._sharedOptions) { const n = s[0], o = "function" == typeof n.getRange && n.getRange(e); if (o) { const n = t(s, e, i - o), a = t(s, e, i + o); return { lo: n.lo, hi: a.hi } } } } return { lo: 0, hi: s.length - 1 } } function Se(t, e, i, n, o) { const s = t.getSortedVisibleDatasetMetas(), a = i[e]; for (let t = 0, i = s.length; t < i; ++t) { const { index: i, data: r } = s[t], { lo: l, hi: c } = ke(s[t], e, a, o); for (let t = l; t <= c; ++t) { const e = r[t]; e.skip || n(e, i, t) } } } function Pe(t, e, i, n) { const o = []; if (!Gt(e, t.chartArea, t._minPadding)) return o; return Se(t, i, e, (function (t, i, s) { t.inRange(e.x, e.y, n) && o.push({ element: t, datasetIndex: i, index: s }) }), !0), o } function De(t, e, i, n, o) { const s = function (t) { const e = -1 !== t.indexOf("x"), i = -1 !== t.indexOf("y"); return function (t, n) { const o = e ? Math.abs(t.x - n.x) : 0, s = i ? Math.abs(t.y - n.y) : 0; return Math.sqrt(Math.pow(o, 2) + Math.pow(s, 2)) } }(i); let a = Number.POSITIVE_INFINITY, r = []; if (!Gt(e, t.chartArea, t._minPadding)) return r; return Se(t, i, e, (function (i, l, c) { if (n && !i.inRange(e.x, e.y, o)) return; const h = i.getCenterPoint(o); if (!Gt(h, t.chartArea, t._minPadding)) return; const d = s(e, h); d < a ? (r = [{ element: i, datasetIndex: l, index: c }], a = d) : d === a && r.push({ element: i, datasetIndex: l, index: c }) })), r } function Ce(t, e, i, n) { const o = Me(e, t), s = [], a = i.axis, r = "x" === a ? "inXRange" : "inYRange"; let l = !1; return function (t, e) { const i = t.getSortedVisibleDatasetMetas(); let n, o, s; for (let t = 0, a = i.length; t < a; ++t) { ({ index: n, data: o } = i[t]); for (let t = 0, i = o.length; t < i; ++t)s = o[t], s.skip || e(s, n, t) } }(t, ((t, e, i) => { t[r](o[a], n) && s.push({ element: t, datasetIndex: e, index: i }), t.inRange(o.x, o.y, n) && (l = !0) })), i.intersect && !l ? [] : s } var Oe = { modes: { index(t, e, i, n) { const o = Me(e, t), s = i.axis || "x", a = i.intersect ? Pe(t, o, s, n) : De(t, o, s, !1, n), r = []; return a.length ? (t.getSortedVisibleDatasetMetas().forEach((t => { const e = a[0].index, i = t.data[e]; i && !i.skip && r.push({ element: i, datasetIndex: t.index, index: e }) })), r) : [] }, dataset(t, e, i, n) { const o = Me(e, t), s = i.axis || "xy"; let a = i.intersect ? Pe(t, o, s, n) : De(t, o, s, !1, n); if (a.length > 0) { const e = a[0].datasetIndex, i = t.getDatasetMeta(e).data; a = []; for (let t = 0; t < i.length; ++t)a.push({ element: i[t], datasetIndex: e, index: t }) } return a }, point: (t, e, i, n) => Pe(t, Me(e, t), i.axis || "xy", n), nearest: (t, e, i, n) => De(t, Me(e, t), i.axis || "xy", i.intersect, n), x: (t, e, i, n) => (i.axis = "x", Ce(t, e, i, n)), y: (t, e, i, n) => (i.axis = "y", Ce(t, e, i, n)) } }; const Te = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/), Ae = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/); function Le(t, e) { const i = ("" + t).match(Te); if (!i || "normal" === i[1]) return 1.2 * e; switch (t = +i[2], i[3]) { case "px": return t; case "%": t /= 100 }return e * t } function Re(t, e) { const i = {}, n = U(e), o = n ? Object.keys(e) : e, s = U(t) ? n ? i => K(t[i], t[e[i]]) : e => t[e] : () => t; for (const t of o) i[t] = +s(t) || 0; return i } function Ee(t) { return Re(t, { top: "y", right: "x", bottom: "y", left: "x" }) } function Ie(t) { return Re(t, ["topLeft", "topRight", "bottomLeft", "bottomRight"]) } function ze(t) { const e = Ee(t); return e.width = e.left + e.right, e.height = e.top + e.bottom, e } function Fe(t, e) { t = t || {}, e = e || xt.font; let i = K(t.size, e.size); "string" == typeof i && (i = parseInt(i, 10)); let n = K(t.style, e.style); n && !("" + n).match(Ae) && (console.warn('Invalid font style specified: "' + n + '"'), n = ""); const o = { family: K(t.family, e.family), lineHeight: Le(K(t.lineHeight, e.lineHeight), i), size: i, style: n, weight: K(t.weight, e.weight), string: "" }; return o.string = $t(o), o } function Ve(t, e, i, n) { let o, s, a, r = !0; for (o = 0, s = t.length; o < s; ++o)if (a = t[o], void 0 !== a && (void 0 !== e && "function" == typeof a && (a = a(e), r = !1), void 0 !== i && Y(a) && (a = a[i % a.length], r = !1), void 0 !== a)) return n && !r && (n.cacheable = !1), a } function Be(t, e) { const { min: i, max: n } = t; return { min: i - Math.abs(Z(e, i)), max: n + Z(e, n) } } const We = ["left", "top", "right", "bottom"]; function He(t, e) { return t.filter((t => t.pos === e)) } function Ne(t, e) { return t.filter((t => -1 === We.indexOf(t.pos) && t.box.axis === e)) } function je(t, e) { return t.sort(((t, i) => { const n = e ? i : t, o = e ? t : i; return n.weight === o.weight ? n.index - o.index : n.weight - o.weight })) } function $e(t, e, i, n) { return Math.max(t[i], e[i]) + Math.max(t[n], e[n]) } function Ye(t, e) { t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right) } function Ue(t, e, i) { const n = i.box, o = t.maxPadding; U(i.pos) || (i.size && (t[i.pos] -= i.size), i.size = i.horizontal ? n.height : n.width, t[i.pos] += i.size), n.getPadding && Ye(o, n.getPadding()); const s = Math.max(0, e.outerWidth - $e(o, t, "left", "right")), a = Math.max(0, e.outerHeight - $e(o, t, "top", "bottom")), r = s !== t.w, l = a !== t.h; return t.w = s, t.h = a, i.horizontal ? { same: r, other: l } : { same: l, other: r } } function Xe(t, e) { const i = e.maxPadding; function n(t) { const n = { left: 0, top: 0, right: 0, bottom: 0 }; return t.forEach((t => { n[t] = Math.max(e[t], i[t]) })), n } return n(t ? ["left", "right"] : ["top", "bottom"]) } function qe(t, e, i) { const n = []; let o, s, a, r, l, c; for (o = 0, s = t.length, l = 0; o < s; ++o) { a = t[o], r = a.box, r.update(a.width || e.w, a.height || e.h, Xe(a.horizontal, e)); const { same: s, other: h } = Ue(e, i, a); l |= s && n.length, c = c || h, r.fullSize || n.push(a) } return l && qe(n, e, i) || c } function Ke(t, e, i) { const n = i.padding; let o, s, a, r, l = e.x, c = e.y; for (o = 0, s = t.length; o < s; ++o)a = t[o], r = a.box, a.horizontal ? (r.left = r.fullSize ? n.left : e.left, r.right = r.fullSize ? i.outerWidth - n.right : e.left + e.w, r.top = c, r.bottom = c + r.height, r.width = r.right - r.left, c = r.bottom) : (r.left = l, r.right = l + r.width, r.top = r.fullSize ? n.top : e.top, r.bottom = r.fullSize ? i.outerHeight - n.right : e.top + e.h, r.height = r.bottom - r.top, l = r.right); e.x = l, e.y = c } xt.set("layout", { padding: { top: 0, right: 0, bottom: 0, left: 0 } }); var Ge = { addBox(t, e) { t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () { return [{ z: 0, draw(t) { e.draw(t) } }] }, t.boxes.push(e) }, removeBox(t, e) { const i = t.boxes ? t.boxes.indexOf(e) : -1; -1 !== i && t.boxes.splice(i, 1) }, configure(t, e, i) { e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight }, update(t, e, i, n) { if (!t) return; const o = ze(t.options.layout.padding), s = Math.max(e - o.width, 0), a = Math.max(i - o.height, 0), r = function (t) { const e = function (t) { const e = []; let i, n, o; for (i = 0, n = (t || []).length; i < n; ++i)o = t[i], e.push({ index: i, box: o, pos: o.position, horizontal: o.isHorizontal(), weight: o.weight }); return e }(t), i = je(e.filter((t => t.box.fullSize)), !0), n = je(He(e, "left"), !0), o = je(He(e, "right")), s = je(He(e, "top"), !0), a = je(He(e, "bottom")), r = Ne(e, "x"), l = Ne(e, "y"); return { fullSize: i, leftAndTop: n.concat(s), rightAndBottom: o.concat(l).concat(a).concat(r), chartArea: He(e, "chartArea"), vertical: n.concat(o).concat(l), horizontal: s.concat(a).concat(r) } }(t.boxes), l = r.vertical, c = r.horizontal; J(t.boxes, (t => { "function" == typeof t.beforeLayout && t.beforeLayout() })); const h = l.reduce(((t, e) => e.box.options && !1 === e.box.options.display ? t : t + 1), 0) || 1, d = Object.freeze({ outerWidth: e, outerHeight: i, padding: o, availableWidth: s, availableHeight: a, vBoxMaxWidth: s / 2 / h, hBoxMaxHeight: a / 2 }), u = Object.assign({}, o); Ye(u, ze(n)); const f = Object.assign({ maxPadding: u, w: s, h: a, x: o.left, y: o.top }, o); !function (t, e) { let i, n, o; for (i = 0, n = t.length; i < n; ++i)o = t[i], o.horizontal ? (o.width = o.box.fullSize && e.availableWidth, o.height = e.hBoxMaxHeight) : (o.width = e.vBoxMaxWidth, o.height = o.box.fullSize && e.availableHeight) }(l.concat(c), d), qe(r.fullSize, f, d), qe(l, f, d), qe(c, f, d) && qe(l, f, d), function (t) { const e = t.maxPadding; function i(i) { const n = Math.max(e[i] - t[i], 0); return t[i] += n, n } t.y += i("top"), t.x += i("left"), i("right"), i("bottom") }(f), Ke(r.leftAndTop, f, d), f.x += f.w, f.y += f.h, Ke(r.rightAndBottom, f, d), t.chartArea = { left: f.left, top: f.top, right: f.left + f.w, bottom: f.top + f.h, height: f.h, width: f.w }, J(r.chartArea, (e => { const i = e.box; Object.assign(i, t.chartArea), i.update(f.w, f.h) })) } }; class Ze { acquireContext(t, e) { } releaseContext(t) { return !1 } addEventListener(t, e, i) { } removeEventListener(t, e, i) { } getDevicePixelRatio() { return 1 } getMaximumSize(t, e, i, n) { return e = Math.max(0, e || t.width), i = i || t.height, { width: e, height: Math.max(0, n ? Math.floor(e / n) : i) } } isAttached(t) { return !0 } } class Qe extends Ze { acquireContext(t) { return t && t.getContext && t.getContext("2d") || null } } const Je = { touchstart: "mousedown", touchmove: "mousemove", touchend: "mouseup", pointerenter: "mouseenter", pointerdown: "mousedown", pointermove: "mousemove", pointerup: "mouseup", pointerleave: "mouseout", pointerout: "mouseout" }, ti = t => null === t || "" === t; const ei = !!ve && { passive: !0 }; function ii(t, e, i) { t.canvas.removeEventListener(e, i, ei) } function ni(t, e, i) { const n = t.canvas, o = n && de(n) || n, s = new MutationObserver((t => { const e = de(o); t.forEach((t => { for (let n = 0; n < t.addedNodes.length; n++) { const s = t.addedNodes[n]; s !== o && s !== e || i(t.target) } })) })); return s.observe(document, { childList: !0, subtree: !0 }), s } function oi(t, e, i) { const n = t.canvas, o = n && de(n); if (!o) return; const s = new MutationObserver((t => { t.forEach((t => { for (let e = 0; e < t.removedNodes.length; e++)if (t.removedNodes[e] === n) { i(); break } })) })); return s.observe(o, { childList: !0 }), s } const si = new Map; let ai = 0; function ri() { const t = window.devicePixelRatio; t !== ai && (ai = t, si.forEach(((e, i) => { i.currentDevicePixelRatio !== t && e() }))) } function li(t, i, n) { const o = t.canvas, s = o && de(o); if (!s) return; const a = e(((t, e) => { const i = s.clientWidth; n(t, e), i < s.clientWidth && n() }), window), r = new ResizeObserver((t => { const e = t[0], i = e.contentRect.width, n = e.contentRect.height; 0 === i && 0 === n || a(i, n) })); return r.observe(s), function (t, e) { si.size || window.addEventListener("resize", ri), si.set(t, e) }(t, a), r } function ci(t, e, i) { i && i.disconnect(), "resize" === e && function (t) { si.delete(t), si.size || window.removeEventListener("resize", ri) }(t) } function hi(t, i, n) { const o = t.canvas, s = e((e => { null !== t.ctx && n(function (t, e) { const i = Je[t.type] || t.type, { x: n, y: o } = xe(t, e); return { type: i, chart: e, native: t, x: void 0 !== n ? n : null, y: void 0 !== o ? o : null } }(e, t)) }), t, (t => { const e = t[0]; return [e, e.offsetX, e.offsetY] })); return function (t, e, i) { t.addEventListener(e, i, ei) }(o, i, s), s } class di extends Ze { acquireContext(t, e) { const i = t && t.getContext && t.getContext("2d"); return i && i.canvas === t ? (function (t, e) { const i = t.style, n = t.getAttribute("height"), o = t.getAttribute("width"); if (t.$chartjs = { initial: { height: n, width: o, style: { display: i.display, height: i.height, width: i.width } } }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", ti(o)) { const e = we(t, "width"); void 0 !== e && (t.width = e) } if (ti(n)) if ("" === t.style.height) t.height = t.width / (e || 2); else { const e = we(t, "height"); void 0 !== e && (t.height = e) } }(t, e), i) : null } releaseContext(t) { const e = t.canvas; if (!e.$chartjs) return !1; const i = e.$chartjs.initial;["height", "width"].forEach((t => { const n = i[t]; $(n) ? e.removeAttribute(t) : e.setAttribute(t, n) })); const n = i.style || {}; return Object.keys(n).forEach((t => { e.style[t] = n[t] })), e.width = e.width, delete e.$chartjs, !0 } addEventListener(t, e, i) { this.removeEventListener(t, e); const n = t.$proxies || (t.$proxies = {}), o = { attach: ni, detach: oi, resize: li }[e] || hi; n[e] = o(t, e, i) } removeEventListener(t, e) { const i = t.$proxies || (t.$proxies = {}), n = i[e]; if (!n) return; ({ attach: ci, detach: ci, resize: ci }[e] || ii)(t, e, n), i[e] = void 0 } getDevicePixelRatio() { return window.devicePixelRatio } getMaximumSize(t, e, i, n) { return _e(t, e, i, n) } isAttached(t) { const e = de(t); return !(!e || !de(e)) } } var ui = Object.freeze({ __proto__: null, BasePlatform: Ze, BasicPlatform: Qe, DomPlatform: di }); const fi = t => 0 === t || 1 === t, gi = (t, e, i) => -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * _t / i), pi = (t, e, i) => Math.pow(2, -10 * t) * Math.sin((t - e) * _t / i) + 1, mi = { linear: t => t, easeInQuad: t => t * t, easeOutQuad: t => -t * (t - 2), easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1), easeInCubic: t => t * t * t, easeOutCubic: t => (t -= 1) * t * t + 1, easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2), easeInQuart: t => t * t * t * t, easeOutQuart: t => -((t -= 1) * t * t * t - 1), easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2), easeInQuint: t => t * t * t * t * t, easeOutQuint: t => (t -= 1) * t * t * t * t + 1, easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2), easeInSine: t => 1 - Math.cos(t * Mt), easeOutSine: t => Math.sin(t * Mt), easeInOutSine: t => -.5 * (Math.cos(bt * t) - 1), easeInExpo: t => 0 === t ? 0 : Math.pow(2, 10 * (t - 1)), easeOutExpo: t => 1 === t ? 1 : 1 - Math.pow(2, -10 * t), easeInOutExpo: t => fi(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))), easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1), easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t), easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1), easeInElastic: t => fi(t) ? t : gi(t, .075, .3), easeOutElastic: t => fi(t) ? t : pi(t, .075, .3), easeInOutElastic(t) { const e = .1125; return fi(t) ? t : t < .5 ? .5 * gi(2 * t, e, .45) : .5 + .5 * pi(2 * t - 1, e, .45) }, easeInBack(t) { const e = 1.70158; return t * t * ((e + 1) * t - e) }, easeOutBack(t) { const e = 1.70158; return (t -= 1) * t * ((e + 1) * t + e) + 1 }, easeInOutBack(t) { let e = 1.70158; return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2) }, easeInBounce: t => 1 - mi.easeOutBounce(1 - t), easeOutBounce(t) { const e = 7.5625, i = 2.75; return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375 }, easeInOutBounce: t => t < .5 ? .5 * mi.easeInBounce(2 * t) : .5 * mi.easeOutBounce(2 * t - 1) + .5 }, xi = "transparent", bi = { boolean: (t, e, i) => i > .5 ? e : t, color(t, e, i) { const n = W(t || xi), o = n.valid && W(e || xi); return o && o.valid ? o.mix(n, i).hexString() : e }, number: (t, e, i) => t + (e - t) * i }; class _i { constructor(t, e, i, n) { const o = e[i]; n = Ve([t.to, n, o, t.from]); const s = Ve([t.from, o, n]); this._active = !0, this._fn = t.fn || bi[t.type || typeof s], this._easing = mi[t.easing] || mi.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = s, this._to = n, this._promises = void 0 } active() { return this._active } update(t, e, i) { const n = this; if (n._active) { n._notify(!1); const o = n._target[n._prop], s = i - n._start, a = n._duration - s; n._start = i, n._duration = Math.floor(Math.max(a, t.duration)), n._total += s, n._loop = !!t.loop, n._to = Ve([t.to, e, o, t.from]), n._from = Ve([t.from, o, e]) } } cancel() { const t = this; t._active && (t.tick(Date.now()), t._active = !1, t._notify(!1)) } tick(t) { const e = this, i = t - e._start, n = e._duration, o = e._prop, s = e._from, a = e._loop, r = e._to; let l; if (e._active = s !== r && (a || i < n), !e._active) return e._target[o] = r, void e._notify(!0); i < 0 ? e._target[o] = s : (l = i / n % 2, l = a && l > 1 ? 2 - l : l, l = e._easing(Math.min(1, Math.max(0, l))), e._target[o] = e._fn(s, r, l)) } wait() { const t = this._promises || (this._promises = []); return new Promise(((e, i) => { t.push({ res: e, rej: i }) })) } _notify(t) { const e = t ? "res" : "rej", i = this._promises || []; for (let t = 0; t < i.length; t++)i[t][e]() } } xt.set("animation", { delay: void 0, duration: 1e3, easing: "easeOutQuart", fn: void 0, from: void 0, loop: void 0, to: void 0, type: void 0 }); const yi = Object.keys(xt.animation); xt.describe("animation", { _fallback: !1, _indexable: !1, _scriptable: t => "onProgress" !== t && "onComplete" !== t && "fn" !== t }), xt.set("animations", { colors: { type: "color", properties: ["color", "borderColor", "backgroundColor"] }, numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius", "tension"] } }), xt.describe("animations", { _fallback: "animation" }), xt.set("transitions", { active: { animation: { duration: 400 } }, resize: { animation: { duration: 0 } }, show: { animations: { colors: { from: "transparent" }, visible: { type: "boolean", duration: 0 } } }, hide: { animations: { colors: { to: "transparent" }, visible: { type: "boolean", easing: "linear", fn: t => 0 | t } } } }); class vi { constructor(t, e) { this._chart = t, this._properties = new Map, this.configure(e) } configure(t) { if (!U(t)) return; const e = this._properties; Object.getOwnPropertyNames(t).forEach((i => { const n = t[i]; if (!U(n)) return; const o = {}; for (const t of yi) o[t] = n[t]; (Y(n.properties) && n.properties || [i]).forEach((t => { t !== i && e.has(t) || e.set(t, o) })) })) } _animateOptions(t, e) { const i = e.options, n = function (t, e) { if (!e) return; let i = t.options; if (!i) return void (t.options = e); i.$shared && (t.options = i = Object.assign({}, i, { $shared: !1, $animations: {} })); return i }(t, i); if (!n) return []; const o = this._createAnimations(n, i); return i.$shared && function (t, e) { const i = [], n = Object.keys(e); for (let e = 0; e < n.length; e++) { const o = t[n[e]]; o && o.active() && i.push(o.wait()) } return Promise.all(i) }(t.options.$animations, i).then((() => { t.options = i }), (() => { })), o } _createAnimations(t, e) { const i = this._properties, n = [], o = t.$animations || (t.$animations = {}), s = Object.keys(e), a = Date.now(); let r; for (r = s.length - 1; r >= 0; --r) { const l = s[r]; if ("$" === l.charAt(0)) continue; if ("options" === l) { n.push(...this._animateOptions(t, e)); continue } const c = e[l]; let h = o[l]; const d = i.get(l); if (h) { if (d && h.active()) { h.update(d, c, a); continue } h.cancel() } d && d.duration ? (o[l] = h = new _i(d, t, l, c), n.push(h)) : t[l] = c } return n } update(t, e) { if (0 === this._properties.size) return void Object.assign(t, e); const i = this._createAnimations(t, e); return i.length ? (a.add(this._chart, i), !0) : void 0 } } function wi(t, e) { const i = t && t.options || {}, n = i.reverse, o = void 0 === i.min ? e : 0, s = void 0 === i.max ? e : 0; return { start: n ? s : o, end: n ? o : s } } function Mi(t, e) { const i = [], n = t._getSortedDatasetMetas(e); let o, s; for (o = 0, s = n.length; o < s; ++o)i.push(n[o].index); return i } function ki(t, e, i, n) { const o = t.keys, s = "single" === n.mode; let a, r, l, c; if (null !== e) { for (a = 0, r = o.length; a < r; ++a) { if (l = +o[a], l === i) { if (n.all) continue; break } c = t.values[l], X(c) && (s || 0 === e || Dt(e) === Dt(c)) && (e += c) } return e } } function Si(t, e) { const i = t && t.options.stacked; return i || void 0 === i && void 0 !== e.stack } function Pi(t, e, i) { const n = t[e] || (t[e] = {}); return n[i] || (n[i] = {}) } function Di(t, e, i) { for (const n of e.getMatchingVisibleMetas("bar").reverse()) { const e = t[n.index]; if (i && e > 0 || !i && e < 0) return n.index } return null } function Ci(t, e) { const { chart: i, _cachedMeta: n } = t, o = i._stacks || (i._stacks = {}), { iScale: s, vScale: a, index: r } = n, l = s.axis, c = a.axis, h = function (t, e, i) { return `${t.id}.${e.id}.${i.stack || i.type}` }(s, a, n), d = e.length; let u; for (let t = 0; t < d; ++t) { const i = e[t], { [l]: n, [c]: s } = i; u = (i._stacks || (i._stacks = {}))[c] = Pi(o, h, n), u[r] = s, u._top = Di(u, a, !0), u._bottom = Di(u, a, !1) } } function Oi(t, e) { const i = t.scales; return Object.keys(i).filter((t => i[t].axis === e)).shift() } function Ti(t, e) { const i = t.vScale && t.vScale.axis; if (i) { e = e || t._parsed; for (const n of e) { const e = n._stacks; if (!e || void 0 === e[i] || void 0 === e[i][t.index]) return; delete e[i][t.index] } } } const Ai = t => "reset" === t || "none" === t, Li = (t, e) => e ? t : Object.assign({}, t); class Ri { constructor(t, e) { this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.$context = void 0, this._syncList = [], this.initialize() } initialize() { const t = this, e = t._cachedMeta; t.configure(), t.linkScales(), e._stacked = Si(e.vScale, e), t.addElements() } updateIndex(t) { this.index !== t && Ti(this._cachedMeta), this.index = t } linkScales() { const t = this, e = t.chart, i = t._cachedMeta, n = t.getDataset(), o = (t, e, i, n) => "x" === t ? e : "r" === t ? n : i, s = i.xAxisID = K(n.xAxisID, Oi(e, "x")), a = i.yAxisID = K(n.yAxisID, Oi(e, "y")), r = i.rAxisID = K(n.rAxisID, Oi(e, "r")), l = i.indexAxis, c = i.iAxisID = o(l, s, a, r), h = i.vAxisID = o(l, a, s, r); i.xScale = t.getScaleForId(s), i.yScale = t.getScaleForId(a), i.rScale = t.getScaleForId(r), i.iScale = t.getScaleForId(c), i.vScale = t.getScaleForId(h) } getDataset() { return this.chart.data.datasets[this.index] } getMeta() { return this.chart.getDatasetMeta(this.index) } getScaleForId(t) { return this.chart.scales[t] } _getOtherScale(t) { const e = this._cachedMeta; return t === e.iScale ? e.vScale : e.iScale } reset() { this._update("reset") } _destroy() { const t = this._cachedMeta; this._data && ce(this._data, this), t._stacked && Ti(t) } _dataCheck() { const t = this, e = t.getDataset(), i = e.data || (e.data = []), n = t._data; if (U(i)) t._data = function (t) { const e = Object.keys(t), i = new Array(e.length); let n, o, s; for (n = 0, o = e.length; n < o; ++n)s = e[n], i[n] = { x: s, y: t[s] }; return i }(i); else if (n !== i) { if (n) { ce(n, t); const e = t._cachedMeta; Ti(e), e._parsed = [] } i && Object.isExtensible(i) && le(i, t), t._syncList = [], t._data = i } } addElements() { const t = this, e = t._cachedMeta; t._dataCheck(), t.datasetElementType && (e.dataset = new t.datasetElementType) } buildOrUpdateElements(t) { const e = this, i = e._cachedMeta, n = e.getDataset(); let o = !1; e._dataCheck(); const s = i._stacked; i._stacked = Si(i.vScale, i), i.stack !== n.stack && (o = !0, Ti(i), i.stack = n.stack), e._resyncElements(t), (o || s !== i._stacked) && Ci(e, i._parsed) } configure() { const t = this, e = t.chart.config, i = e.datasetScopeKeys(t._type), n = e.getOptionScopes(t.getDataset(), i, !0); t.options = e.createResolver(n, t.getContext()), t._parsing = t.options.parsing } parse(t, e) { const i = this, { _cachedMeta: n, _data: o } = i, { iScale: s, _stacked: a } = n, r = s.axis; let l, c, h, d = 0 === t && e === o.length || n._sorted, u = t > 0 && n._parsed[t - 1]; if (!1 === i._parsing) n._parsed = o, n._sorted = !0, h = o; else { h = Y(o[t]) ? i.parseArrayData(n, o, t, e) : U(o[t]) ? i.parseObjectData(n, o, t, e) : i.parsePrimitiveData(n, o, t, e); const s = () => null === c[r] || u && c[r] < u[r]; for (l = 0; l < e; ++l)n._parsed[l + t] = c = h[l], d && (s() && (d = !1), u = c); n._sorted = d } a && Ci(i, h) } parsePrimitiveData(t, e, i, n) { const { iScale: o, vScale: s } = t, a = o.axis, r = s.axis, l = o.getLabels(), c = o === s, h = new Array(n); let d, u, f; for (d = 0, u = n; d < u; ++d)f = d + i, h[d] = { [a]: c || o.parse(l[f], f), [r]: s.parse(e[f], f) }; return h } parseArrayData(t, e, i, n) { const { xScale: o, yScale: s } = t, a = new Array(n); let r, l, c, h; for (r = 0, l = n; r < l; ++r)c = r + i, h = e[c], a[r] = { x: o.parse(h[0], c), y: s.parse(h[1], c) }; return a } parseObjectData(t, e, i, n) { const { xScale: o, yScale: s } = t, { xAxisKey: a = "x", yAxisKey: r = "y" } = this._parsing, l = new Array(n); let c, h, d, u; for (c = 0, h = n; c < h; ++c)d = c + i, u = e[d], l[c] = { x: o.parse(lt(u, a), d), y: s.parse(lt(u, r), d) }; return l } getParsed(t) { return this._cachedMeta._parsed[t] } getDataElement(t) { return this._cachedMeta.data[t] } applyStack(t, e, i) { const n = this.chart, o = this._cachedMeta, s = e[t.axis]; return ki({ keys: Mi(n, !0), values: e._stacks[t.axis] }, s, o.index, { mode: i }) } updateRangeFromParsed(t, e, i, n) { const o = i[e.axis]; let s = null === o ? NaN : o; const a = n && i._stacks[e.axis]; n && a && (n.values = a, t.min = Math.min(t.min, s), t.max = Math.max(t.max, s), s = ki(n, o, this._cachedMeta.index, { all: !0 })), t.min = Math.min(t.min, s), t.max = Math.max(t.max, s) } getMinMax(t, e) { const i = this, n = i._cachedMeta, o = n._parsed, s = n._sorted && t === n.iScale, a = o.length, r = i._getOtherScale(t), l = e && n._stacked && { keys: Mi(i.chart, !0), values: null }, c = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY }, { min: h, max: d } = function (t) { const { min: e, max: i, minDefined: n, maxDefined: o } = t.getUserBounds(); return { min: n ? e : Number.NEGATIVE_INFINITY, max: o ? i : Number.POSITIVE_INFINITY } }(r); let u, f, g, p; function m() { return g = o[u], f = g[t.axis], p = g[r.axis], !X(f) || h > p || d < p } for (u = 0; u < a && (m() || (i.updateRangeFromParsed(c, t, g, l), !s)); ++u); if (s) for (u = a - 1; u >= 0; --u)if (!m()) { i.updateRangeFromParsed(c, t, g, l); break } return c } getAllParsedValues(t) { const e = this._cachedMeta._parsed, i = []; let n, o, s; for (n = 0, o = e.length; n < o; ++n)s = e[n][t.axis], X(s) && i.push(s); return i } getMaxOverflow() { return !1 } getLabelAndValue(t) { const e = this._cachedMeta, i = e.iScale, n = e.vScale, o = this.getParsed(t); return { label: i ? "" + i.getLabelForValue(o[i.axis]) : "", value: n ? "" + n.getLabelForValue(o[n.axis]) : "" } } _update(t) { const e = this, i = e._cachedMeta; e.configure(), e._cachedDataOpts = {}, e.update(t || "default"), i._clip = function (t) { let e, i, n, o; return U(t) ? (e = t.top, i = t.right, n = t.bottom, o = t.left) : e = i = n = o = t, { top: e, right: i, bottom: n, left: o } }(K(e.options.clip, function (t, e, i) { if (!1 === i) return !1; const n = wi(t, i), o = wi(e, i); return { top: o.end, right: n.end, bottom: o.start, left: n.start } }(i.xScale, i.yScale, e.getMaxOverflow()))) } update(t) { } draw() { const t = this, e = t._ctx, i = t.chart, n = t._cachedMeta, o = n.data || [], s = i.chartArea, a = [], r = t._drawStart || 0, l = t._drawCount || o.length - r; let c; for (n.dataset && n.dataset.draw(e, s, r, l), c = r; c < r + l; ++c) { const t = o[c]; t.active ? a.push(t) : t.draw(e, s) } for (c = 0; c < a.length; ++c)a[c].draw(e, s) } getStyle(t, e) { const i = e ? "active" : "default"; return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i) } getContext(t, e, i) { const n = this, o = n.getDataset(); let s; if (t >= 0 && t < n._cachedMeta.data.length) { const e = n._cachedMeta.data[t]; s = e.$context || (e.$context = function (t, e, i) { return Object.assign(Object.create(t), { active: !1, dataIndex: e, parsed: void 0, raw: void 0, element: i, index: e, mode: "default", type: "data" }) }(n.getContext(), t, e)), s.parsed = n.getParsed(t), s.raw = o.data[t], s.index = s.dataIndex = t } else s = n.$context || (n.$context = function (t, e) { return Object.assign(Object.create(t), { active: !1, dataset: void 0, datasetIndex: e, index: e, mode: "default", type: "dataset" }) }(n.chart.getContext(), n.index)), s.dataset = o, s.index = s.datasetIndex = n.index; return s.active = !!e, s.mode = i, s } resolveDatasetElementOptions(t) { return this._resolveElementOptions(this.datasetElementType.id, t) } resolveDataElementOptions(t, e) { return this._resolveElementOptions(this.dataElementType.id, e, t) } _resolveElementOptions(t, e = "default", i) { const n = this, o = "active" === e, s = n._cachedDataOpts, a = t + "-" + e, r = s[a], l = n.enableOptionSharing && ht(i); if (r) return Li(r, l); const c = n.chart.config, h = c.datasetElementScopeKeys(n._type, t), d = o ? [`${t}Hover`, "hover", t, ""] : [t, ""], u = c.getOptionScopes(n.getDataset(), h), f = Object.keys(xt.elements[t]), g = c.resolveNamedOptions(u, f, (() => n.getContext(i, o)), d); return g.$shared && (g.$shared = l, s[a] = Object.freeze(Li(g, l))), g } _resolveAnimations(t, e, i) { const n = this, o = n.chart, s = n._cachedDataOpts, a = `animation-${e}`, r = s[a]; if (r) return r; let l; if (!1 !== o.options.animation) { const o = n.chart.config, s = o.datasetAnimationScopeKeys(n._type, e), a = o.getOptionScopes(n.getDataset(), s); l = o.createResolver(a, n.getContext(t, i, e)) } const c = new vi(o, l && l.animations); return l && l._cacheable && (s[a] = Object.freeze(c)), c } getSharedOptions(t) { if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t)) } includeOptions(t, e) { return !e || Ai(t) || this.chart._animationsDisabled } updateElement(t, e, i, n) { Ai(n) ? Object.assign(t, i) : this._resolveAnimations(e, n).update(t, i) } updateSharedOptions(t, e, i) { t && !Ai(e) && this._resolveAnimations(void 0, e).update(t, i) } _setStyle(t, e, i, n) { t.active = n; const o = this.getStyle(e, n); this._resolveAnimations(e, i, n).update(t, { options: !n && this.getSharedOptions(o) || o }) } removeHoverStyle(t, e, i) { this._setStyle(t, i, "active", !1) } setHoverStyle(t, e, i) { this._setStyle(t, i, "active", !0) } _removeDatasetHoverStyle() { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, "active", !1) } _setDatasetHoverStyle() { const t = this._cachedMeta.dataset; t && this._setStyle(t, void 0, "active", !0) } _resyncElements(t) { const e = this, i = e._data, n = e._cachedMeta.data; for (const [t, i, n] of e._syncList) e[t](i, n); e._syncList = []; const o = n.length, s = i.length, a = Math.min(s, o); a && e.parse(0, a), s > o ? e._insertElements(o, s - o, t) : s < o && e._removeElements(s, o - s) } _insertElements(t, e, i = !0) { const n = this, o = n._cachedMeta, s = o.data, a = t + e; let r; const l = t => { for (t.length += e, r = t.length - 1; r >= a; r--)t[r] = t[r - e] }; for (l(s), r = t; r < a; ++r)s[r] = new n.dataElementType; n._parsing && l(o._parsed), n.parse(t, e), i && n.updateElements(s, t, e, "reset") } updateElements(t, e, i, n) { } _removeElements(t, e) { const i = this._cachedMeta; if (this._parsing) { const n = i._parsed.splice(t, e); i._stacked && Ti(i, n) } i.data.splice(t, e) } _onDataPush() { const t = arguments.length; this._syncList.push(["_insertElements", this.getDataset().data.length - t, t]) } _onDataPop() { this._syncList.push(["_removeElements", this._cachedMeta.data.length - 1, 1]) } _onDataShift() { this._syncList.push(["_removeElements", 0, 1]) } _onDataSplice(t, e) { this._syncList.push(["_removeElements", t, e]), this._syncList.push(["_insertElements", t, arguments.length - 2]) } _onDataUnshift() { this._syncList.push(["_insertElements", 0, arguments.length]) } } Ri.defaults = {}, Ri.prototype.datasetElementType = null, Ri.prototype.dataElementType = null; class Ei { constructor() { this.x = void 0, this.y = void 0, this.active = !1, this.options = void 0, this.$animations = void 0 } tooltipPosition(t) { const { x: e, y: i } = this.getProps(["x", "y"], t); return { x: e, y: i } } hasValue() { return Tt(this.x) && Tt(this.y) } getProps(t, e) { const i = this, n = this.$animations; if (!e || !n) return i; const o = {}; return t.forEach((t => { o[t] = n[t] && n[t].active() ? n[t]._to : i[t] })), o } } Ei.defaults = {}, Ei.defaultRoutes = void 0; const Ii = new Map; function zi(t, e, i) { return function (t, e) { e = e || {}; const i = t + JSON.stringify(e); let n = Ii.get(i); return n || (n = new Intl.NumberFormat(t, e), Ii.set(i, n)), n }(e, i).format(t) } const Fi = { values: t => Y(t) ? t : "" + t, numeric(t, e, i) { if (0 === t) return "0"; const n = this.chart.options.locale; let o, s = t; if (i.length > 1) { const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value)); (e < 1e-4 || e > 1e15) && (o = "scientific"), s = function (t, e) { let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value; Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t)); return i }(t, i) } const a = Pt(Math.abs(s)), r = Math.max(Math.min(-1 * Math.floor(a), 20), 0), l = { notation: o, minimumFractionDigits: r, maximumFractionDigits: r }; return Object.assign(l, this.options.ticks.format), zi(t, n, l) }, logarithmic(t, e, i) { if (0 === t) return "0"; const n = t / Math.pow(10, Math.floor(Pt(t))); return 1 === n || 2 === n || 5 === n ? Fi.numeric.call(this, t, e, i) : "" } }; var Vi = { formatters: Fi }; function Bi(t, e) { const i = t.options.ticks, n = i.maxTicksLimit || function (t) { const e = t.options.offset, i = t._tickSize(), n = t._length / i + (e ? 0 : 1), o = t._maxLength / i; return Math.floor(Math.min(n, o)) }(t), o = i.major.enabled ? function (t) { const e = []; let i, n; for (i = 0, n = t.length; i < n; i++)t[i].major && e.push(i); return e }(e) : [], s = o.length, a = o[0], r = o[s - 1], l = []; if (s > n) return function (t, e, i, n) { let o, s = 0, a = i[0]; for (n = Math.ceil(n), o = 0; o < t.length; o++)o === a && (e.push(t[o]), s++, a = i[s * n]) }(e, l, o, s / n), l; const c = function (t, e, i) { const n = function (t) { const e = t.length; let i, n; if (e < 2) return !1; for (n = t[0], i = 1; i < e; ++i)if (t[i] - t[i - 1] !== n) return !1; return n }(t), o = e.length / i; if (!n) return Math.max(o, 1); const s = Ot(n); for (let t = 0, e = s.length - 1; t < e; t++) { const e = s[t]; if (e > o) return e } return Math.max(o, 1) }(o, e, n); if (s > 0) { let t, i; const n = s > 1 ? Math.round((r - a) / (s - 1)) : null; for (Wi(e, l, c, $(n) ? 0 : a - n, a), t = 0, i = s - 1; t < i; t++)Wi(e, l, c, o[t], o[t + 1]); return Wi(e, l, c, r, $(n) ? e.length : r + n), l } return Wi(e, l, c), l } function Wi(t, e, i, n, o) { const s = K(n, 0), a = Math.min(K(o, t.length), t.length); let r, l, c, h = 0; for (i = Math.ceil(i), o && (r = o - n, i = r / Math.floor(r / i)), c = s; c < 0;)h++, c = Math.round(s + h * i); for (l = Math.max(s, 0); l < a; l++)l === c && (e.push(t[l]), h++, c = Math.round(s + h * i)) } xt.set("scale", { display: !0, offset: !1, reverse: !1, beginAtZero: !1, bounds: "ticks", grace: 0, grid: { display: !0, lineWidth: 1, drawBorder: !0, drawOnChartArea: !0, drawTicks: !0, tickLength: 8, tickWidth: (t, e) => e.lineWidth, tickColor: (t, e) => e.color, offset: !1, borderDash: [], borderDashOffset: 0, borderWidth: 1 }, title: { display: !1, text: "", padding: { top: 4, bottom: 4 } }, ticks: { minRotation: 0, maxRotation: 50, mirror: !1, textStrokeWidth: 0, textStrokeColor: "", padding: 3, display: !0, autoSkip: !0, autoSkipPadding: 3, labelOffset: 0, callback: Vi.formatters.values, minor: {}, major: {}, align: "center", crossAlign: "near", showLabelBackdrop: !1, backdropColor: "rgba(255, 255, 255, 0.75)", backdropPadding: 2 } }), xt.route("scale.ticks", "color", "", "color"), xt.route("scale.grid", "color", "", "borderColor"), xt.route("scale.grid", "borderColor", "", "borderColor"), xt.route("scale.title", "color", "", "color"), xt.describe("scale", { _fallback: !1, _scriptable: t => !t.startsWith("before") && !t.startsWith("after") && "callback" !== t && "parser" !== t, _indexable: t => "borderDash" !== t && "tickBorderDash" !== t }), xt.describe("scales", { _fallback: "scale" }); const Hi = (t, e, i) => "top" === e || "left" === e ? t[e] + i : t[e] - i; function Ni(t, e) { const i = [], n = t.length / e, o = t.length; let s = 0; for (; s < o; s += n)i.push(t[Math.floor(s)]); return i } function ji(t, e, i) { const n = t.ticks.length, o = Math.min(e, n - 1), s = t._startPixel, a = t._endPixel, r = 1e-6; let l, c = t.getPixelForTick(o); if (!(i && (l = 1 === n ? Math.max(c - s, a - c) : 0 === e ? (t.getPixelForTick(1) - c) / 2 : (c - t.getPixelForTick(o - 1)) / 2, c += o < e ? l : -l, c < s - r || c > a + r))) return c } function $i(t) { return t.drawTicks ? t.tickLength : 0 } function Yi(t, e) { if (!t.display) return 0; const i = Fe(t.font, e), n = ze(t.padding); return (Y(t.text) ? t.text.length : 1) * i.lineHeight + n.height } function Ui(t, e, i) { let o = n(t); return (i && "right" !== e || !i && "right" === e) && (o = (t => "left" === t ? "right" : "right" === t ? "left" : t)(o)), o } class Xi extends Ei { constructor(t) { super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = { left: 0, right: 0, top: 0, bottom: 0 }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0 } init(t) { const e = this; e.options = t.setContext(e.getContext()), e.axis = t.axis, e._userMin = e.parse(t.min), e._userMax = e.parse(t.max), e._suggestedMin = e.parse(t.suggestedMin), e._suggestedMax = e.parse(t.suggestedMax) } parse(t, e) { return t } getUserBounds() { let { _userMin: t, _userMax: e, _suggestedMin: i, _suggestedMax: n } = this; return t = q(t, Number.POSITIVE_INFINITY), e = q(e, Number.NEGATIVE_INFINITY), i = q(i, Number.POSITIVE_INFINITY), n = q(n, Number.NEGATIVE_INFINITY), { min: q(t, i), max: q(e, n), minDefined: X(t), maxDefined: X(e) } } getMinMax(t) { const e = this; let i, { min: n, max: o, minDefined: s, maxDefined: a } = e.getUserBounds(); if (s && a) return { min: n, max: o }; const r = e.getMatchingVisibleMetas(); for (let l = 0, c = r.length; l < c; ++l)i = r[l].controller.getMinMax(e, t), s || (n = Math.min(n, i.min)), a || (o = Math.max(o, i.max)); return { min: q(n, q(o, n)), max: q(o, q(n, o)) } } getPadding() { const t = this; return { left: t.paddingLeft || 0, top: t.paddingTop || 0, right: t.paddingRight || 0, bottom: t.paddingBottom || 0 } } getTicks() { return this.ticks } getLabels() { const t = this.chart.data; return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [] } beforeLayout() { this._cache = {}, this._dataLimitsCached = !1 } beforeUpdate() { Q(this.options.beforeUpdate, [this]) } update(t, e, i) { const n = this, o = n.options.ticks, s = o.sampleSize; n.beforeUpdate(), n.maxWidth = t, n.maxHeight = e, n._margins = i = Object.assign({ left: 0, right: 0, top: 0, bottom: 0 }, i), n.ticks = null, n._labelSizes = null, n._gridLineItems = null, n._labelItems = null, n.beforeSetDimensions(), n.setDimensions(), n.afterSetDimensions(), n._maxLength = n.isHorizontal() ? n.width + i.left + i.right : n.height + i.top + i.bottom, n._dataLimitsCached || (n.beforeDataLimits(), n.determineDataLimits(), n.afterDataLimits(), n._range = Be(n, n.options.grace), n._dataLimitsCached = !0), n.beforeBuildTicks(), n.ticks = n.buildTicks() || [], n.afterBuildTicks(); const a = s < n.ticks.length; n._convertTicksToLabels(a ? Ni(n.ticks, s) : n.ticks), n.configure(), n.beforeCalculateLabelRotation(), n.calculateLabelRotation(), n.afterCalculateLabelRotation(), o.display && (o.autoSkip || "auto" === o.source) && (n.ticks = Bi(n, n.ticks), n._labelSizes = null), a && n._convertTicksToLabels(n.ticks), n.beforeFit(), n.fit(), n.afterFit(), n.afterUpdate() } configure() { const t = this; let e, i, n = t.options.reverse; t.isHorizontal() ? (e = t.left, i = t.right) : (e = t.top, i = t.bottom, n = !n), t._startPixel = e, t._endPixel = i, t._reversePixels = n, t._length = i - e, t._alignToPixels = t.options.alignToPixels } afterUpdate() { Q(this.options.afterUpdate, [this]) } beforeSetDimensions() { Q(this.options.beforeSetDimensions, [this]) } setDimensions() { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0 } afterSetDimensions() { Q(this.options.afterSetDimensions, [this]) } _callHooks(t) { const e = this; e.chart.notifyPlugins(t, e.getContext()), Q(e.options[t], [e]) } beforeDataLimits() { this._callHooks("beforeDataLimits") } determineDataLimits() { } afterDataLimits() { this._callHooks("afterDataLimits") } beforeBuildTicks() { this._callHooks("beforeBuildTicks") } buildTicks() { return [] } afterBuildTicks() { this._callHooks("afterBuildTicks") } beforeTickToLabelConversion() { Q(this.options.beforeTickToLabelConversion, [this]) } generateTickLabels(t) { const e = this, i = e.options.ticks; let n, o, s; for (n = 0, o = t.length; n < o; n++)s = t[n], s.label = Q(i.callback, [s.value, n, t], e); for (n = 0; n < o; n++)$(t[n].label) && (t.splice(n, 1), o--, n--) } afterTickToLabelConversion() { Q(this.options.afterTickToLabelConversion, [this]) } beforeCalculateLabelRotation() { Q(this.options.beforeCalculateLabelRotation, [this]) } calculateLabelRotation() { const t = this, e = t.options, i = e.ticks, n = t.ticks.length, o = i.minRotation || 0, s = i.maxRotation; let a, r, l, c = o; if (!t._isVisible() || !i.display || o >= s || n <= 1 || !t.isHorizontal()) return void (t.labelRotation = o); const h = t._getLabelSizes(), d = h.widest.width, u = h.highest.height, f = Nt(t.chart.width - d, 0, t.maxWidth); a = e.offset ? t.maxWidth / n : f / (n - 1), d + 6 > a && (a = f / (n - (e.offset ? .5 : 1)), r = t.maxHeight - $i(e.grid) - i.padding - Yi(e.title, t.chart.options.font), l = Math.sqrt(d * d + u * u), c = It(Math.min(Math.asin(Math.min((h.highest.height + 6) / a, 1)), Math.asin(Math.min(r / l, 1)) - Math.asin(u / l))), c = Math.max(o, Math.min(s, c))), t.labelRotation = c } afterCalculateLabelRotation() { Q(this.options.afterCalculateLabelRotation, [this]) } beforeFit() { Q(this.options.beforeFit, [this]) } fit() { const t = this, e = { width: 0, height: 0 }, { chart: i, options: { ticks: n, title: o, grid: s } } = t, a = t._isVisible(), r = t.isHorizontal(); if (a) { const a = Yi(o, i.options.font); if (r ? (e.width = t.maxWidth, e.height = $i(s) + a) : (e.height = t.maxHeight, e.width = $i(s) + a), n.display && t.ticks.length) { const { first: i, last: o, widest: s, highest: a } = t._getLabelSizes(), l = 2 * n.padding, c = Et(t.labelRotation), h = Math.cos(c), d = Math.sin(c); if (r) { const i = n.mirror ? 0 : d * s.width + h * a.height; e.height = Math.min(t.maxHeight, e.height + i + l) } else { const i = n.mirror ? 0 : h * s.width + d * a.height; e.width = Math.min(t.maxWidth, e.width + i + l) } t._calculatePadding(i, o, d, h) } } t._handleMargins(), r ? (t.width = t._length = i.width - t._margins.left - t._margins.right, t.height = e.height) : (t.width = e.width, t.height = t._length = i.height - t._margins.top - t._margins.bottom) } _calculatePadding(t, e, i, n) { const o = this, { ticks: { align: s, padding: a }, position: r } = o.options, l = 0 !== o.labelRotation, c = "top" !== r && "x" === o.axis; if (o.isHorizontal()) { const r = o.getPixelForTick(0) - o.left, h = o.right - o.getPixelForTick(o.ticks.length - 1); let d = 0, u = 0; l ? c ? (d = n * t.width, u = i * e.height) : (d = i * t.height, u = n * e.width) : "start" === s ? u = e.width : "end" === s ? d = t.width : (d = t.width / 2, u = e.width / 2), o.paddingLeft = Math.max((d - r + a) * o.width / (o.width - r), 0), o.paddingRight = Math.max((u - h + a) * o.width / (o.width - h), 0) } else { let i = e.height / 2, n = t.height / 2; "start" === s ? (i = 0, n = t.height) : "end" === s && (i = e.height, n = 0), o.paddingTop = i + a, o.paddingBottom = n + a } } _handleMargins() { const t = this; t._margins && (t._margins.left = Math.max(t.paddingLeft, t._margins.left), t._margins.top = Math.max(t.paddingTop, t._margins.top), t._margins.right = Math.max(t.paddingRight, t._margins.right), t._margins.bottom = Math.max(t.paddingBottom, t._margins.bottom)) } afterFit() { Q(this.options.afterFit, [this]) } isHorizontal() { const { axis: t, position: e } = this.options; return "top" === e || "bottom" === e || "x" === t } isFullSize() { return this.options.fullSize } _convertTicksToLabels(t) { const e = this; e.beforeTickToLabelConversion(), e.generateTickLabels(t), e.afterTickToLabelConversion() } _getLabelSizes() { const t = this; let e = t._labelSizes; if (!e) { const i = t.options.ticks.sampleSize; let n = t.ticks; i < n.length && (n = Ni(n, i)), t._labelSizes = e = t._computeLabelSizes(n, n.length) } return e } _computeLabelSizes(t, e) { const { ctx: i, _longestTextCache: n } = this, o = [], s = []; let a, r, l, c, h, d, u, f, g, p, m, x = 0, b = 0; for (a = 0; a < e; ++a) { if (c = t[a].label, h = this._resolveTickFontOptions(a), i.font = d = h.string, u = n[d] = n[d] || { data: {}, gc: [] }, f = h.lineHeight, g = p = 0, $(c) || Y(c)) { if (Y(c)) for (r = 0, l = c.length; r < l; ++r)m = c[r], $(m) || Y(m) || (g = Yt(i, u.data, u.gc, g, m), p += f) } else g = Yt(i, u.data, u.gc, g, c), p = f; o.push(g), s.push(p), x = Math.max(g, x), b = Math.max(p, b) } !function (t, e) { J(t, (t => { const i = t.gc, n = i.length / 2; let o; if (n > e) { for (o = 0; o < n; ++o)delete t.data[i[o]]; i.splice(0, n) } })) }(n, e); const _ = o.indexOf(x), y = s.indexOf(b), v = t => ({ width: o[t] || 0, height: s[t] || 0 }); return { first: v(0), last: v(e - 1), widest: v(_), highest: v(y), widths: o, heights: s } } getLabelForValue(t) { return t } getPixelForValue(t, e) { return NaN } getValueForPixel(t) { } getPixelForTick(t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } getPixelForDecimal(t) { const e = this; e._reversePixels && (t = 1 - t); const i = e._startPixel + t * e._length; return jt(e._alignToPixels ? Xt(e.chart, i, 0) : i) } getDecimalForPixel(t) { const e = (t - this._startPixel) / this._length; return this._reversePixels ? 1 - e : e } getBasePixel() { return this.getPixelForValue(this.getBaseValue()) } getBaseValue() { const { min: t, max: e } = this; return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0 } getContext(t) { const e = this, i = e.ticks || []; if (t >= 0 && t < i.length) { const n = i[t]; return n.$context || (n.$context = function (t, e, i) { return Object.assign(Object.create(t), { tick: i, index: e, type: "tick" }) }(e.getContext(), t, n)) } return e.$context || (e.$context = (n = e.chart.getContext(), o = e, Object.assign(Object.create(n), { scale: o, type: "scale" }))); var n, o } _tickSize() { const t = this, e = t.options.ticks, i = Et(t.labelRotation), n = Math.abs(Math.cos(i)), o = Math.abs(Math.sin(i)), s = t._getLabelSizes(), a = e.autoSkipPadding || 0, r = s ? s.widest.width + a : 0, l = s ? s.highest.height + a : 0; return t.isHorizontal() ? l * n > r * o ? r / n : l / o : l * o < r * n ? l / n : r / o } _isVisible() { const t = this.options.display; return "auto" !== t ? !!t : this.getMatchingVisibleMetas().length > 0 } _computeGridLineItems(t) { const e = this, i = e.axis, n = e.chart, o = e.options, { grid: s, position: a } = o, r = s.offset, l = e.isHorizontal(), c = e.ticks.length + (r ? 1 : 0), h = $i(s), d = [], u = s.setContext(e.getContext()), f = u.drawBorder ? u.borderWidth : 0, g = f / 2, p = function (t) { return Xt(n, t, f) }; let m, x, b, _, y, v, w, M, k, S, P, D; if ("top" === a) m = p(e.bottom), v = e.bottom - h, M = m - g, S = p(t.top) + g, D = t.bottom; else if ("bottom" === a) m = p(e.top), S = t.top, D = p(t.bottom) - g, v = m + g, M = e.top + h; else if ("left" === a) m = p(e.right), y = e.right - h, w = m - g, k = p(t.left) + g, P = t.right; else if ("right" === a) m = p(e.left), k = t.left, P = p(t.right) - g, y = m + g, w = e.left + h; else if ("x" === i) { if ("center" === a) m = p((t.top + t.bottom) / 2 + .5); else if (U(a)) { const t = Object.keys(a)[0], i = a[t]; m = p(e.chart.scales[t].getPixelForValue(i)) } S = t.top, D = t.bottom, v = m + g, M = v + h } else if ("y" === i) { if ("center" === a) m = p((t.left + t.right) / 2); else if (U(a)) { const t = Object.keys(a)[0], i = a[t]; m = p(e.chart.scales[t].getPixelForValue(i)) } y = m - g, w = y - h, k = t.left, P = t.right } for (x = 0; x < c; ++x) { const t = s.setContext(e.getContext(x)), i = t.lineWidth, o = t.color, a = s.borderDash || [], c = t.borderDashOffset, h = t.tickWidth, u = t.tickColor, f = t.tickBorderDash || [], g = t.tickBorderDashOffset; b = ji(e, x, r), void 0 !== b && (_ = Xt(n, b, i), l ? y = w = k = P = _ : v = M = S = D = _, d.push({ tx1: y, ty1: v, tx2: w, ty2: M, x1: k, y1: S, x2: P, y2: D, width: i, color: o, borderDash: a, borderDashOffset: c, tickWidth: h, tickColor: u, tickBorderDash: f, tickBorderDashOffset: g })) } return e._ticksLength = c, e._borderValue = m, d } _computeLabelItems(t) { const e = this, i = e.axis, n = e.options, { position: o, ticks: s } = n, a = e.isHorizontal(), r = e.ticks, { align: l, crossAlign: c, padding: h, mirror: d } = s, u = $i(n.grid), f = u + h, g = d ? -h : f, p = -Et(e.labelRotation), m = []; let x, b, _, y, v, w, M, k, S, P, D, C, O = "middle"; if ("top" === o) w = e.bottom - g, M = e._getXAxisLabelAlignment(); else if ("bottom" === o) w = e.top + g, M = e._getXAxisLabelAlignment(); else if ("left" === o) { const t = e._getYAxisLabelAlignment(u); M = t.textAlign, v = t.x } else if ("right" === o) { const t = e._getYAxisLabelAlignment(u); M = t.textAlign, v = t.x } else if ("x" === i) { if ("center" === o) w = (t.top + t.bottom) / 2 + f; else if (U(o)) { const t = Object.keys(o)[0], i = o[t]; w = e.chart.scales[t].getPixelForValue(i) + f } M = e._getXAxisLabelAlignment() } else if ("y" === i) { if ("center" === o) v = (t.left + t.right) / 2 - f; else if (U(o)) { const t = Object.keys(o)[0], i = o[t]; v = e.chart.scales[t].getPixelForValue(i) } M = e._getYAxisLabelAlignment(u).textAlign } "y" === i && ("start" === l ? O = "top" : "end" === l && (O = "bottom")); const T = e._getLabelSizes(); for (x = 0, b = r.length; x < b; ++x) { _ = r[x], y = _.label; const t = s.setContext(e.getContext(x)); k = e.getPixelForTick(x) + s.labelOffset, S = e._resolveTickFontOptions(x), P = S.lineHeight, D = Y(y) ? y.length : 1; const i = D / 2, n = t.color, l = t.textStrokeColor, h = t.textStrokeWidth; let u; if (a ? (v = k, C = "top" === o ? "near" === c || 0 !== p ? -D * P + P / 2 : "center" === c ? -T.highest.height / 2 - i * P + P : -T.highest.height + P / 2 : "near" === c || 0 !== p ? P / 2 : "center" === c ? T.highest.height / 2 - i * P : T.highest.height - D * P, d && (C *= -1)) : (w = k, C = (1 - D) * P / 2), t.showLabelBackdrop) { const e = ze(t.backdropPadding), i = T.heights[x], n = T.widths[x]; let o = w + C - e.top, s = v - e.left; switch (O) { case "middle": o -= i / 2; break; case "bottom": o -= i }switch (M) { case "center": s -= n / 2; break; case "right": s -= n }u = { left: s, top: o, width: n + e.width, height: i + e.height, color: t.backdropColor } } m.push({ rotation: p, label: y, font: S, color: n, strokeColor: l, strokeWidth: h, textOffset: C, textAlign: M, textBaseline: O, translation: [v, w], backdrop: u }) } return m } _getXAxisLabelAlignment() { const { position: t, ticks: e } = this.options; if (-Et(this.labelRotation)) return "top" === t ? "left" : "right"; let i = "center"; return "start" === e.align ? i = "left" : "end" === e.align && (i = "right"), i } _getYAxisLabelAlignment(t) { const e = this, { position: i, ticks: { crossAlign: n, mirror: o, padding: s } } = e.options, a = t + s, r = e._getLabelSizes().widest.width; let l, c; return "left" === i ? o ? (l = "left", c = e.right + s) : (c = e.right - a, "near" === n ? l = "right" : "center" === n ? (l = "center", c -= r / 2) : (l = "left", c = e.left)) : "right" === i ? o ? (l = "right", c = e.left + s) : (c = e.left + a, "near" === n ? l = "left" : "center" === n ? (l = "center", c += r / 2) : (l = "right", c = e.right)) : l = "right", { textAlign: l, x: c } } _computeLabelArea() { const t = this; if (t.options.ticks.mirror) return; const e = t.chart, i = t.options.position; return "left" === i || "right" === i ? { top: 0, left: t.left, bottom: e.height, right: t.right } : "top" === i || "bottom" === i ? { top: t.top, left: 0, bottom: t.bottom, right: e.width } : void 0 } drawBackground() { const { ctx: t, options: { backgroundColor: e }, left: i, top: n, width: o, height: s } = this; e && (t.save(), t.fillStyle = e, t.fillRect(i, n, o, s), t.restore()) } getLineWidthForValue(t) { const e = this, i = e.options.grid; if (!e._isVisible() || !i.display) return 0; const n = e.ticks.findIndex((e => e.value === t)); if (n >= 0) { return i.setContext(e.getContext(n)).lineWidth } return 0 } drawGrid(t) { const e = this, i = e.options.grid, n = e.ctx, o = e._gridLineItems || (e._gridLineItems = e._computeGridLineItems(t)); let s, a; const r = (t, e, i) => { i.width && i.color && (n.save(), n.lineWidth = i.width, n.strokeStyle = i.color, n.setLineDash(i.borderDash || []), n.lineDashOffset = i.borderDashOffset, n.beginPath(), n.moveTo(t.x, t.y), n.lineTo(e.x, e.y), n.stroke(), n.restore()) }; if (i.display) for (s = 0, a = o.length; s < a; ++s) { const t = o[s]; i.drawOnChartArea && r({ x: t.x1, y: t.y1 }, { x: t.x2, y: t.y2 }, t), i.drawTicks && r({ x: t.tx1, y: t.ty1 }, { x: t.tx2, y: t.ty2 }, { color: t.tickColor, width: t.tickWidth, borderDash: t.tickBorderDash, borderDashOffset: t.tickBorderDashOffset }) } } drawBorder() { const t = this, { chart: e, ctx: i, options: { grid: n } } = t, o = n.setContext(t.getContext()), s = n.drawBorder ? o.borderWidth : 0; if (!s) return; const a = n.setContext(t.getContext(0)).lineWidth, r = t._borderValue; let l, c, h, d; t.isHorizontal() ? (l = Xt(e, t.left, s) - s / 2, c = Xt(e, t.right, a) + a / 2, h = d = r) : (h = Xt(e, t.top, s) - s / 2, d = Xt(e, t.bottom, a) + a / 2, l = c = r), i.save(), i.lineWidth = o.borderWidth, i.strokeStyle = o.borderColor, i.beginPath(), i.moveTo(l, h), i.lineTo(c, d), i.stroke(), i.restore() } drawLabels(t) { const e = this; if (!e.options.ticks.display) return; const i = e.ctx, n = e._computeLabelArea(); n && Zt(i, n); const o = e._labelItems || (e._labelItems = e._computeLabelItems(t)); let s, a; for (s = 0, a = o.length; s < a; ++s) { const t = o[s], e = t.font, n = t.label; t.backdrop && (i.fillStyle = t.backdrop.color, i.fillRect(t.backdrop.left, t.backdrop.top, t.backdrop.width, t.backdrop.height)), ee(i, n, 0, t.textOffset, e, t) } n && Qt(i) } drawTitle() { const { ctx: t, options: { position: e, title: i, reverse: n } } = this; if (!i.display) return; const s = Fe(i.font), a = ze(i.padding), r = i.align; let l = s.lineHeight / 2; "bottom" === e ? (l += a.bottom, Y(i.text) && (l += s.lineHeight * (i.text.length - 1))) : l += a.top; const { titleX: c, titleY: h, maxWidth: d, rotation: u } = function (t, e, i, n) { const { top: s, left: a, bottom: r, right: l } = t; let c, h, d, u = 0; return t.isHorizontal() ? (h = o(n, a, l), d = Hi(t, i, e), c = l - a) : (h = Hi(t, i, e), d = o(n, r, s), u = "left" === i ? -Mt : Mt), { titleX: h, titleY: d, maxWidth: c, rotation: u } }(this, l, e, r); ee(t, i.text, 0, 0, s, { color: i.color, maxWidth: d, rotation: u, textAlign: Ui(r, e, n), textBaseline: "middle", translation: [c, h] }) } draw(t) { const e = this; e._isVisible() && (e.drawBackground(), e.drawGrid(t), e.drawBorder(), e.drawTitle(), e.drawLabels(t)) } _layers() { const t = this, e = t.options, i = e.ticks && e.ticks.z || 0, n = e.grid && e.grid.z || 0; return t._isVisible() && t.draw === Xi.prototype.draw ? [{ z: n, draw(e) { t.drawBackground(), t.drawGrid(e), t.drawTitle() } }, { z: n + 1, draw() { t.drawBorder() } }, { z: i, draw(e) { t.drawLabels(e) } }] : [{ z: i, draw(e) { t.draw(e) } }] } getMatchingVisibleMetas(t) { const e = this, i = e.chart.getSortedVisibleDatasetMetas(), n = e.axis + "AxisID", o = []; let s, a; for (s = 0, a = i.length; s < a; ++s) { const a = i[s]; a[n] !== e.id || t && a.type !== t || o.push(a) } return o } _resolveTickFontOptions(t) { return Fe(this.options.ticks.setContext(this.getContext(t)).font) } _maxDigits() { const t = this, e = t._resolveTickFontOptions(0).lineHeight; return (t.isHorizontal() ? t.width : t.height) / e } } function qi(t, e = [""], i = t, n, o = (() => t[0])) { ht(n) || (n = an("_fallback", t)); const s = { [Symbol.toStringTag]: "Object", _cacheable: !0, _scopes: t, _rootScopes: i, _fallback: n, _getTarget: o, override: o => qi([o, ...t], e, i, n) }; return new Proxy(s, { deleteProperty: (e, i) => (delete e[i], delete e._keys, delete t[0][i], !0), get: (i, n) => Ji(i, n, (() => function (t, e, i, n) { let o; for (const s of e) if (o = an(Zi(s, t), i), ht(o)) return Qi(t, o) ? on(i, n, t, o) : o }(n, e, t, i))), getOwnPropertyDescriptor: (t, e) => Reflect.getOwnPropertyDescriptor(t._scopes[0], e), getPrototypeOf: () => Reflect.getPrototypeOf(t[0]), has: (t, e) => rn(t).includes(e), ownKeys: t => rn(t), set: (t, e, i) => ((t._storage || (t._storage = o()))[e] = i, delete t[e], delete t._keys, !0) }) } function Ki(t, e, i, n) { const o = { _cacheable: !1, _proxy: t, _context: e, _subProxy: i, _stack: new Set, _descriptors: Gi(t, n), setContext: e => Ki(t, e, i, n), override: o => Ki(t.override(o), e, i, n) }; return new Proxy(o, { deleteProperty: (e, i) => (delete e[i], delete t[i], !0), get: (t, e, i) => Ji(t, e, (() => function (t, e, i) { const { _proxy: n, _context: o, _subProxy: s, _descriptors: a } = t; let r = n[e]; dt(r) && a.isScriptable(e) && (r = function (t, e, i, n) { const { _proxy: o, _context: s, _subProxy: a, _stack: r } = i; if (r.has(t)) throw new Error("Recursion detected: " + [...r].join("->") + "->" + t); r.add(t), e = e(s, a || n), r.delete(t), U(e) && (e = on(o._scopes, o, t, e)); return e }(e, r, t, i)); Y(r) && r.length && (r = function (t, e, i, n) { const { _proxy: o, _context: s, _subProxy: a, _descriptors: r } = i; if (ht(s.index) && n(t)) e = e[s.index % e.length]; else if (U(e[0])) { const i = e, n = o._scopes.filter((t => t !== i)); e = []; for (const l of i) { const i = on(n, o, t, l); e.push(Ki(i, s, a && a[t], r)) } } return e }(e, r, t, a.isIndexable)); Qi(e, r) && (r = Ki(r, o, s && s[e], a)); return r }(t, e, i))), getOwnPropertyDescriptor: (e, i) => e._descriptors.allKeys ? Reflect.has(t, i) ? { enumerable: !0, configurable: !0 } : void 0 : Reflect.getOwnPropertyDescriptor(t, i), getPrototypeOf: () => Reflect.getPrototypeOf(t), has: (e, i) => Reflect.has(t, i), ownKeys: () => Reflect.ownKeys(t), set: (e, i, n) => (t[i] = n, delete e[i], !0) }) } function Gi(t, e = { scriptable: !0, indexable: !0 }) { const { _scriptable: i = e.scriptable, _indexable: n = e.indexable, _allKeys: o = e.allKeys } = t; return { allKeys: o, scriptable: i, indexable: n, isScriptable: dt(i) ? i : () => i, isIndexable: dt(n) ? n : () => n } } const Zi = (t, e) => t ? t + ct(e) : e, Qi = (t, e) => U(e) && "adapters" !== t; function Ji(t, e, i) { let n = t[e]; return ht(n) || (n = i(), ht(n) && (t[e] = n)), n } function tn(t, e, i) { return dt(t) ? t(e, i) : t } const en = (t, e) => !0 === t ? e : "string" == typeof t ? lt(e, t) : void 0; function nn(t, e, i, n) { for (const o of e) { const e = en(i, o); if (e) { t.add(e); const o = tn(e._fallback, i, e); if (ht(o) && o !== i && o !== n) return o } else if (!1 === e && ht(n) && i !== n) return null } return !1 } function on(t, e, i, n) { const o = e._rootScopes, s = tn(e._fallback, i, n), a = [...t, ...o], r = new Set; r.add(n); let l = sn(r, a, i, s || i); return null !== l && ((!ht(s) || s === i || (l = sn(r, a, s, l), null !== l)) && qi([...r], [""], o, s, (() => function (t, e, i) { const n = t._getTarget(); e in n || (n[e] = {}); const o = n[e]; if (Y(o) && U(i)) return i; return o }(e, i, n)))) } function sn(t, e, i, n) { for (; i;)i = nn(t, e, i, n); return i } function an(t, e) { for (const i of e) { if (!i) continue; const e = i[t]; if (ht(e)) return e } } function rn(t) { let e = t._keys; return e || (e = t._keys = function (t) { const e = new Set; for (const i of t) for (const t of Object.keys(i).filter((t => !t.startsWith("_")))) e.add(t); return [...e] }(t._scopes)), e } const ln = Number.EPSILON || 1e-14, cn = (t, e) => e < t.length && !t[e].skip && t[e], hn = t => "x" === t ? "y" : "x"; function dn(t, e, i, n) { const o = t.skip ? e : t, s = e, a = i.skip ? e : i, r = Vt(s, o), l = Vt(a, s); let c = r / (r + l), h = l / (r + l); c = isNaN(c) ? 0 : c, h = isNaN(h) ? 0 : h; const d = n * c, u = n * h; return { previous: { x: s.x - d * (a.x - o.x), y: s.y - d * (a.y - o.y) }, next: { x: s.x + u * (a.x - o.x), y: s.y + u * (a.y - o.y) } } } function un(t, e = "x") { const i = hn(e), n = t.length, o = Array(n).fill(0), s = Array(n); let a, r, l, c = cn(t, 0); for (a = 0; a < n; ++a)if (r = l, l = c, c = cn(t, a + 1), l) { if (c) { const t = c[e] - l[e]; o[a] = 0 !== t ? (c[i] - l[i]) / t : 0 } s[a] = r ? c ? Dt(o[a - 1]) !== Dt(o[a]) ? 0 : (o[a - 1] + o[a]) / 2 : o[a - 1] : o[a] } !function (t, e, i) { const n = t.length; let o, s, a, r, l, c = cn(t, 0); for (let h = 0; h < n - 1; ++h)l = c, c = cn(t, h + 1), l && c && (At(e[h], 0, ln) ? i[h] = i[h + 1] = 0 : (o = i[h] / e[h], s = i[h + 1] / e[h], r = Math.pow(o, 2) + Math.pow(s, 2), r <= 9 || (a = 3 / Math.sqrt(r), i[h] = o * a * e[h], i[h + 1] = s * a * e[h]))) }(t, o, s), function (t, e, i = "x") { const n = hn(i), o = t.length; let s, a, r, l = cn(t, 0); for (let c = 0; c < o; ++c) { if (a = r, r = l, l = cn(t, c + 1), !r) continue; const o = r[i], h = r[n]; a && (s = (o - a[i]) / 3, r[`cp1${i}`] = o - s, r[`cp1${n}`] = h - s * e[c]), l && (s = (l[i] - o) / 3, r[`cp2${i}`] = o + s, r[`cp2${n}`] = h + s * e[c]) } }(t, s, e) } function fn(t, e, i) { return Math.max(Math.min(t, i), e) } function gn(t, e, i, n, o) { let s, a, r, l; if (e.spanGaps && (t = t.filter((t => !t.skip))), "monotone" === e.cubicInterpolationMode) un(t, o); else { let i = n ? t[t.length - 1] : t[0]; for (s = 0, a = t.length; s < a; ++s)r = t[s], l = dn(i, r, t[Math.min(s + 1, a - (n ? 0 : 1)) % a], e.tension), r.cp1x = l.previous.x, r.cp1y = l.previous.y, r.cp2x = l.next.x, r.cp2y = l.next.y, i = r } e.capBezierPoints && function (t, e) { let i, n, o, s, a, r = Gt(t[0], e); for (i = 0, n = t.length; i < n; ++i)a = s, s = r, r = i < n - 1 && Gt(t[i + 1], e), s && (o = t[i], a && (o.cp1x = fn(o.cp1x, e.left, e.right), o.cp1y = fn(o.cp1y, e.top, e.bottom)), r && (o.cp2x = fn(o.cp2x, e.left, e.right), o.cp2y = fn(o.cp2y, e.top, e.bottom))) }(t, i) } function pn(t, e, i, n) { return { x: t.x + i * (e.x - t.x), y: t.y + i * (e.y - t.y) } } function mn(t, e, i, n) { return { x: t.x + i * (e.x - t.x), y: "middle" === n ? i < .5 ? t.y : e.y : "after" === n ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y } } function xn(t, e, i, n) { const o = { x: t.cp2x, y: t.cp2y }, s = { x: e.cp1x, y: e.cp1y }, a = pn(t, o, i), r = pn(o, s, i), l = pn(s, e, i), c = pn(a, r, i), h = pn(r, l, i); return pn(c, h, i) } function bn(t, e, i) { return t ? function (t, e) { return { x: i => t + t + e - i, setWidth(t) { e = t }, textAlign: t => "center" === t ? t : "right" === t ? "left" : "right", xPlus: (t, e) => t - e, leftForLtr: (t, e) => t - e } }(e, i) : { x: t => t, setWidth(t) { }, textAlign: t => t, xPlus: (t, e) => t + e, leftForLtr: (t, e) => t } } function _n(t, e) { let i, n; "ltr" !== e && "rtl" !== e || (i = t.canvas.style, n = [i.getPropertyValue("direction"), i.getPropertyPriority("direction")], i.setProperty("direction", e, "important"), t.prevTextDirection = n) } function yn(t, e) { void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1])) } function vn(t) { return "angle" === t ? { between: Ht, compare: Bt, normalize: Wt } : { between: (t, e, i) => t >= Math.min(e, i) && t <= Math.max(i, e), compare: (t, e) => t - e, normalize: t => t } } function wn({ start: t, end: e, count: i, loop: n, style: o }) { return { start: t % i, end: e % i, loop: n && (e - t + 1) % i == 0, style: o } } function Mn(t, e, i) { if (!i) return [t]; const { property: n, start: o, end: s } = i, a = e.length, { compare: r, between: l, normalize: c } = vn(n), { start: h, end: d, loop: u, style: f } = function (t, e, i) { const { property: n, start: o, end: s } = i, { between: a, normalize: r } = vn(n), l = e.length; let c, h, { start: d, end: u, loop: f } = t; if (f) { for (d += l, u += l, c = 0, h = l; c < h && a(r(e[d % l][n]), o, s); ++c)d--, u--; d %= l, u %= l } return u < d && (u += l), { start: d, end: u, loop: f, style: t.style } }(t, e, i), g = []; let p, m, x, b = !1, _ = null; const y = () => b || l(o, x, p) && 0 !== r(o, x), v = () => !b || 0 === r(s, p) || l(s, x, p); for (let t = h, i = h; t <= d; ++t)m = e[t % a], m.skip || (p = c(m[n]), p !== x && (b = l(p, o, s), null === _ && y() && (_ = 0 === r(p, o) ? t : i), null !== _ && v() && (g.push(wn({ start: _, end: t, loop: u, count: a, style: f })), _ = null), i = t, x = p)); return null !== _ && g.push(wn({ start: _, end: d, loop: u, count: a, style: f })), g } function kn(t, e) { const i = [], n = t.segments; for (let o = 0; o < n.length; o++) { const s = Mn(n[o], t.points, e); s.length && i.push(...s) } return i } function Sn(t, e) { const i = t.points, n = t.options.spanGaps, o = i.length; if (!o) return []; const s = !!t._loop, { start: a, end: r } = function (t, e, i, n) { let o = 0, s = e - 1; if (i && !n) for (; o < e && !t[o].skip;)o++; for (; o < e && t[o].skip;)o++; for (o %= e, i && (s += o); s > o && t[s % e].skip;)s--; return s %= e, { start: o, end: s } }(i, o, s, n); if (!0 === n) return Pn([{ start: a, end: r, loop: s }], i, e); return Pn(function (t, e, i, n) { const o = t.length, s = []; let a, r = e, l = t[e]; for (a = e + 1; a <= i; ++a) { const i = t[a % o]; i.skip || i.stop ? l.skip || (n = !1, s.push({ start: e % o, end: (a - 1) % o, loop: n }), e = r = i.stop ? a : null) : (r = a, l.skip && (e = a)), l = i } return null !== r && s.push({ start: e % o, end: r % o, loop: n }), s }(i, a, r < a ? r + o : r, !!t._fullLoop && 0 === a && r === o - 1), i, e) } function Pn(t, e, i) { return i && i.setContext && e ? function (t, e, i) { const n = e.length, o = []; let s = t[0].start, a = s; for (const r of t) { let t, l, c = e[s % n]; for (a = s + 1; a <= r.end; a++) { const h = e[a % n]; l = Dn(i.setContext({ type: "segment", p0: c, p1: h })), Cn(l, t) && (o.push({ start: s, end: a - 1, loop: r.loop, style: t }), t = l, s = a - 1), c = h, t = l } s < a - 1 && (o.push({ start: s, end: a - 1, loop: r.loop, style: l }), s = a - 1) } return o }(t, e, i) : t } function Dn(t) { return { backgroundColor: t.backgroundColor, borderCapStyle: t.borderCapStyle, borderDash: t.borderDash, borderDashOffset: t.borderDashOffset, borderJoinStyle: t.borderJoinStyle, borderWidth: t.borderWidth, borderColor: t.borderColor } } function Cn(t, e) { return e && JSON.stringify(t) !== JSON.stringify(e) } var On = Object.freeze({ __proto__: null, easingEffects: mi, color: W, getHoverColor: H, noop: N, uid: j, isNullOrUndef: $, isArray: Y, isObject: U, isFinite: X, finiteOrDefault: q, valueOrDefault: K, toPercentage: G, toDimension: Z, callback: Q, each: J, _elementsEqual: tt, clone: et, _merger: nt, merge: ot, mergeIf: st, _mergerIf: at, _deprecated: function (t, e, i, n) { void 0 !== e && console.warn(t + ': "' + i + '" is deprecated. Please use "' + n + '" instead') }, resolveObjectKey: lt, _capitalize: ct, defined: ht, isFunction: dt, setsEqual: ut, toFontString: $t, _measureText: Yt, _longestText: Ut, _alignPixel: Xt, clearCanvas: qt, drawPoint: Kt, _isPointInArea: Gt, clipArea: Zt, unclipArea: Qt, _steppedLineTo: Jt, _bezierCurveTo: te, renderText: ee, addRoundedRectPath: ie, _lookup: ne, _lookupByKey: oe, _rlookupByKey: se, _filterBetween: ae, listenArrayEvents: le, unlistenArrayEvents: ce, _arrayUnique: he, _createResolver: qi, _attachContext: Ki, _descriptors: Gi, splineCurve: dn, splineCurveMonotone: un, _updateBezierControlPoints: gn, _getParentNode: de, getStyle: ge, getRelativePosition: xe, getMaximumSize: _e, retinaScale: ye, supportsEventListenerOptions: ve, readUsedSize: we, fontString: function (t, e, i) { return e + " " + t + "px " + i }, requestAnimFrame: t, throttled: e, debounce: i, _toLeftRightCenter: n, _alignStartEnd: o, _textX: s, _pointInLine: pn, _steppedInterpolation: mn, _bezierInterpolation: xn, formatNumber: zi, toLineHeight: Le, _readValueToProps: Re, toTRBL: Ee, toTRBLCorners: Ie, toPadding: ze, toFont: Fe, resolve: Ve, _addGrace: Be, PI: bt, TAU: _t, PITAU: yt, INFINITY: vt, RAD_PER_DEG: wt, HALF_PI: Mt, QUARTER_PI: kt, TWO_THIRDS_PI: St, log10: Pt, sign: Dt, niceNum: Ct, _factorize: Ot, isNumber: Tt, almostEquals: At, almostWhole: Lt, _setMinAndMaxByKey: Rt, toRadians: Et, toDegrees: It, _decimalPlaces: zt, getAngleFromPoint: Ft, distanceBetweenPoints: Vt, _angleDiff: Bt, _normalizeAngle: Wt, _angleBetween: Ht, _limitValue: Nt, _int16Range: jt, getRtlAdapter: bn, overrideTextDirection: _n, restoreTextDirection: yn, _boundSegment: Mn, _boundSegments: kn, _computeSegments: Sn }); class Tn { constructor(t, e, i) { this.type = t, this.scope = e, this.override = i, this.items = Object.create(null) } isForType(t) { return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype) } register(t) { const e = this, i = Object.getPrototypeOf(t); let n; (function (t) { return "id" in t && "defaults" in t })(i) && (n = e.register(i)); const o = e.items, s = t.id, a = e.scope + "." + s; if (!s) throw new Error("class does not have id: " + t); return s in o || (o[s] = t, function (t, e, i) { const n = ot(Object.create(null), [i ? xt.get(i) : {}, xt.get(e), t.defaults]); xt.set(e, n), t.defaultRoutes && function (t, e) { Object.keys(e).forEach((i => { const n = i.split("."), o = n.pop(), s = [t].concat(n).join("."), a = e[i].split("."), r = a.pop(), l = a.join("."); xt.route(s, o, l, r) })) }(e, t.defaultRoutes); t.descriptors && xt.describe(e, t.descriptors) }(t, a, n), e.override && xt.override(t.id, t.overrides)), a } get(t) { return this.items[t] } unregister(t) { const e = this.items, i = t.id, n = this.scope; i in e && delete e[i], n && i in xt[n] && (delete xt[n][i], this.override && delete ft[i]) } } var An = new class { constructor() { this.controllers = new Tn(Ri, "datasets", !0), this.elements = new Tn(Ei, "elements"), this.plugins = new Tn(Object, "plugins"), this.scales = new Tn(Xi, "scales"), this._typedRegistries = [this.controllers, this.scales, this.elements] } add(...t) { this._each("register", t) } remove(...t) { this._each("unregister", t) } addControllers(...t) { this._each("register", t, this.controllers) } addElements(...t) { this._each("register", t, this.elements) } addPlugins(...t) { this._each("register", t, this.plugins) } addScales(...t) { this._each("register", t, this.scales) } getController(t) { return this._get(t, this.controllers, "controller") } getElement(t) { return this._get(t, this.elements, "element") } getPlugin(t) { return this._get(t, this.plugins, "plugin") } getScale(t) { return this._get(t, this.scales, "scale") } removeControllers(...t) { this._each("unregister", t, this.controllers) } removeElements(...t) { this._each("unregister", t, this.elements) } removePlugins(...t) { this._each("unregister", t, this.plugins) } removeScales(...t) { this._each("unregister", t, this.scales) } _each(t, e, i) { const n = this;[...e].forEach((e => { const o = i || n._getRegistryForType(e); i || o.isForType(e) || o === n.plugins && e.id ? n._exec(t, o, e) : J(e, (e => { const o = i || n._getRegistryForType(e); n._exec(t, o, e) })) })) } _exec(t, e, i) { const n = ct(t); Q(i["before" + n], [], i), e[t](i), Q(i["after" + n], [], i) } _getRegistryForType(t) { for (let e = 0; e < this._typedRegistries.length; e++) { const i = this._typedRegistries[e]; if (i.isForType(t)) return i } return this.plugins } _get(t, e, i) { const n = e.get(t); if (void 0 === n) throw new Error('"' + t + '" is not a registered ' + i + "."); return n } }; class Ln { constructor() { this._init = [] } notify(t, e, i, n) { const o = this; "beforeInit" === e && (o._init = o._createDescriptors(t, !0), o._notify(o._init, t, "install")); const s = n ? o._descriptors(t).filter(n) : o._descriptors(t), a = o._notify(s, t, e, i); return "destroy" === e && (o._notify(s, t, "stop"), o._notify(o._init, t, "uninstall")), a } _notify(t, e, i, n) { n = n || {}; for (const o of t) { const t = o.plugin; if (!1 === Q(t[i], [e, n, o.options], t) && n.cancelable) return !1 } return !0 } invalidate() { $(this._cache) || (this._oldCache = this._cache, this._cache = void 0) } _descriptors(t) { if (this._cache) return this._cache; const e = this._cache = this._createDescriptors(t); return this._notifyStateChanges(t), e } _createDescriptors(t, e) { const i = t && t.config, n = K(i.options && i.options.plugins, {}), o = function (t) { const e = [], i = Object.keys(An.plugins.items); for (let t = 0; t < i.length; t++)e.push(An.getPlugin(i[t])); const n = t.plugins || []; for (let t = 0; t < n.length; t++) { const i = n[t]; -1 === e.indexOf(i) && e.push(i) } return e }(i); return !1 !== n || e ? function (t, e, i, n) { const o = [], s = t.getContext(); for (let a = 0; a < e.length; a++) { const r = e[a], l = Rn(i[r.id], n); null !== l && o.push({ plugin: r, options: En(t.config, r, l, s) }) } return o }(t, o, n, e) : [] } _notifyStateChanges(t) { const e = this._oldCache || [], i = this._cache, n = (t, e) => t.filter((t => !e.some((e => t.plugin.id === e.plugin.id)))); this._notify(n(e, i), t, "stop"), this._notify(n(i, e), t, "start") } } function Rn(t, e) { return e || !1 !== t ? !0 === t ? {} : t : null } function En(t, e, i, n) { const o = t.pluginScopeKeys(e), s = t.getOptionScopes(i, o); return t.createResolver(s, n, [""], { scriptable: !1, indexable: !1, allKeys: !0 }) } function In(t, e) { const i = xt.datasets[t] || {}; return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || "x" } function zn(t, e) { return "x" === t || "y" === t ? t : e.axis || ("top" === (i = e.position) || "bottom" === i ? "x" : "left" === i || "right" === i ? "y" : void 0) || t.charAt(0).toLowerCase(); var i } function Fn(t) { const e = t.options || (t.options = {}); e.plugins = K(e.plugins, {}), e.scales = function (t, e) { const i = ft[t.type] || { scales: {} }, n = e.scales || {}, o = In(t.type, e), s = Object.create(null), a = Object.create(null); return Object.keys(n).forEach((t => { const e = n[t], r = zn(t, e), l = function (t, e) { return t === e ? "_index_" : "_value_" }(r, o), c = i.scales || {}; s[r] = s[r] || t, a[t] = st(Object.create(null), [{ axis: r }, e, c[r], c[l]]) })), t.data.datasets.forEach((i => { const o = i.type || t.type, r = i.indexAxis || In(o, e), l = (ft[o] || {}).scales || {}; Object.keys(l).forEach((t => { const e = function (t, e) { let i = t; return "_index_" === t ? i = e : "_value_" === t && (i = "x" === e ? "y" : "x"), i }(t, r), o = i[e + "AxisID"] || s[e] || e; a[o] = a[o] || Object.create(null), st(a[o], [{ axis: e }, n[o], l[t]]) })) })), Object.keys(a).forEach((t => { const e = a[t]; st(e, [xt.scales[e.type], xt.scale]) })), a }(t, e) } function Vn(t) { return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t } const Bn = new Map, Wn = new Set; function Hn(t, e) { let i = Bn.get(t); return i || (i = e(), Bn.set(t, i), Wn.add(i)), i } const Nn = (t, e, i) => { const n = lt(e, i); void 0 !== n && t.add(n) }; class jn { constructor(t) { this._config = function (t) { return (t = t || {}).data = Vn(t.data), Fn(t), t }(t), this._scopeCache = new Map, this._resolverCache = new Map } get type() { return this._config.type } set type(t) { this._config.type = t } get data() { return this._config.data } set data(t) { this._config.data = Vn(t) } get options() { return this._config.options } set options(t) { this._config.options = t } get plugins() { return this._config.plugins } update() { const t = this._config; this.clearCache(), Fn(t) } clearCache() { this._scopeCache.clear(), this._resolverCache.clear() } datasetScopeKeys(t) { return Hn(t, (() => [[`datasets.${t}`, ""]])) } datasetAnimationScopeKeys(t, e) { return Hn(`${t}.transition.${e}`, (() => [[`datasets.${t}.transitions.${e}`, `transitions.${e}`], [`datasets.${t}`, ""]])) } datasetElementScopeKeys(t, e) { return Hn(`${t}-${e}`, (() => [[`datasets.${t}.elements.${e}`, `datasets.${t}`, `elements.${e}`, ""]])) } pluginScopeKeys(t) { const e = t.id; return Hn(`${this.type}-plugin-${e}`, (() => [[`plugins.${e}`, ...t.additionalOptionScopes || []]])) } _cachedScopes(t, e) { const i = this._scopeCache; let n = i.get(t); return n && !e || (n = new Map, i.set(t, n)), n } getOptionScopes(t, e, i) { const { options: n, type: o } = this, s = this._cachedScopes(t, i), a = s.get(e); if (a) return a; const r = new Set; e.forEach((e => { t && (r.add(t), e.forEach((e => Nn(r, t, e)))), e.forEach((t => Nn(r, n, t))), e.forEach((t => Nn(r, ft[o] || {}, t))), e.forEach((t => Nn(r, xt, t))), e.forEach((t => Nn(r, gt, t))) })); const l = [...r]; return Wn.has(e) && s.set(e, l), l } chartOptionScopes() { const { options: t, type: e } = this; return [t, ft[e] || {}, xt.datasets[e] || {}, { type: e }, xt, gt] } resolveNamedOptions(t, e, i, n = [""]) { const o = { $shared: !0 }, { resolver: s, subPrefixes: a } = $n(this._resolverCache, t, n); let r = s; if (function (t, e) { const { isScriptable: i, isIndexable: n } = Gi(t); for (const o of e) if (i(o) && dt(t[o]) || n(o) && Y(t[o])) return !0; return !1 }(s, e)) { o.$shared = !1; r = Ki(s, i = dt(i) ? i() : i, this.createResolver(t, i, a)) } for (const t of e) o[t] = r[t]; return o } createResolver(t, e, i = [""], n) { const { resolver: o } = $n(this._resolverCache, t, i); return U(e) ? Ki(o, e, void 0, n) : o } } function $n(t, e, i) { let n = t.get(e); n || (n = new Map, t.set(e, n)); const o = i.join(); let s = n.get(o); if (!s) { s = { resolver: qi(e, i), subPrefixes: i.filter((t => !t.toLowerCase().includes("hover"))) }, n.set(o, s) } return s } const Yn = ["top", "bottom", "left", "right", "chartArea"]; function Un(t, e) { return "top" === t || "bottom" === t || -1 === Yn.indexOf(t) && "x" === e } function Xn(t, e) { return function (i, n) { return i[t] === n[t] ? i[e] - n[e] : i[t] - n[t] } } function qn(t) { const e = t.chart, i = e.options.animation; e.notifyPlugins("afterRender"), Q(i && i.onComplete, [t], e) } function Kn(t) { const e = t.chart, i = e.options.animation; Q(i && i.onProgress, [t], e) } function Gn() { return "undefined" != typeof window && "undefined" != typeof document } function Zn(t) { return Gn() && "string" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t } const Qn = {}, Jn = t => { const e = Zn(t); return Object.values(Qn).filter((t => t.canvas === e)).pop() }; class to { constructor(t, e) { const n = this; this.config = e = new jn(e); const o = Zn(t), s = Jn(o); if (s) throw new Error("Canvas is already in use. Chart with ID '" + s.id + "' must be destroyed before the canvas can be reused."); const r = e.createResolver(e.chartOptionScopes(), n.getContext()); this.platform = n._initializePlatform(o, e); const l = n.platform.acquireContext(o, r.aspectRatio), c = l && l.canvas, h = c && c.height, d = c && c.width; this.id = j(), this.ctx = l, this.canvas = c, this.width = d, this.height = h, this._options = r, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this.scale = void 0, this._plugins = new Ln, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = i((() => this.update("resize")), r.resizeDelay || 0), Qn[n.id] = n, l && c ? (a.listen(n, "complete", qn), a.listen(n, "progress", Kn), n._initialize(), n.attached && n.update()) : console.error("Failed to create chart: can't acquire context from the given item") } get aspectRatio() { const { options: { aspectRatio: t, maintainAspectRatio: e }, width: i, height: n, _aspectRatio: o } = this; return $(t) ? e && o ? o : n ? i / n : null : t } get data() { return this.config.data } set data(t) { this.config.data = t } get options() { return this._options } set options(t) { this.config.options = t } _initialize() { const t = this; return t.notifyPlugins("beforeInit"), t.options.responsive ? t.resize() : ye(t, t.options.devicePixelRatio), t.bindEvents(), t.notifyPlugins("afterInit"), t } _initializePlatform(t, e) { return e.platform ? new e.platform : !Gn() || "undefined" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? new Qe : new di } clear() { return qt(this.canvas, this.ctx), this } stop() { return a.stop(this), this } resize(t, e) { a.running(this) ? this._resizeBeforeDraw = { width: t, height: e } : this._resize(t, e) } _resize(t, e) { const i = this, n = i.options, o = i.canvas, s = n.maintainAspectRatio && i.aspectRatio, a = i.platform.getMaximumSize(o, t, e, s), r = n.devicePixelRatio || i.platform.getDevicePixelRatio(); i.width = a.width, i.height = a.height, i._aspectRatio = i.aspectRatio, ye(i, r, !0) && (i.notifyPlugins("resize", { size: a }), Q(n.onResize, [i, a], i), i.attached && i._doResize() && i.render()) } ensureScalesHaveIDs() { J(this.options.scales || {}, ((t, e) => { t.id = e })) } buildOrUpdateScales() { const t = this, e = t.options, i = e.scales, n = t.scales, o = Object.keys(n).reduce(((t, e) => (t[e] = !1, t)), {}); let s = []; i && (s = s.concat(Object.keys(i).map((t => { const e = i[t], n = zn(t, e), o = "r" === n, s = "x" === n; return { options: e, dposition: o ? "chartArea" : s ? "bottom" : "left", dtype: o ? "radialLinear" : s ? "category" : "linear" } })))), J(s, (i => { const s = i.options, a = s.id, r = zn(a, s), l = K(s.type, i.dtype); void 0 !== s.position && Un(s.position, r) === Un(i.dposition) || (s.position = i.dposition), o[a] = !0; let c = null; if (a in n && n[a].type === l) c = n[a]; else { c = new (An.getScale(l))({ id: a, type: l, ctx: t.ctx, chart: t }), n[c.id] = c } c.init(s, e) })), J(o, ((t, e) => { t || delete n[e] })), J(n, (e => { Ge.configure(t, e, e.options), Ge.addBox(t, e) })) } _updateMetasets() { const t = this, e = t._metasets, i = t.data.datasets.length, n = e.length; if (e.sort(((t, e) => t.index - e.index)), n > i) { for (let e = i; e < n; ++e)t._destroyDatasetMeta(e); e.splice(i, n - i) } t._sortedMetasets = e.slice(0).sort(Xn("order", "index")) } _removeUnreferencedMetasets() { const t = this, { _metasets: e, data: { datasets: i } } = t; e.length > i.length && delete t._stacks, e.forEach(((e, n) => { 0 === i.filter((t => t === e._dataset)).length && t._destroyDatasetMeta(n) })) } buildOrUpdateControllers() { const t = this, e = [], i = t.data.datasets; let n, o; for (t._removeUnreferencedMetasets(), n = 0, o = i.length; n < o; n++) { const o = i[n]; let s = t.getDatasetMeta(n); const a = o.type || t.config.type; if (s.type && s.type !== a && (t._destroyDatasetMeta(n), s = t.getDatasetMeta(n)), s.type = a, s.indexAxis = o.indexAxis || In(a, t.options), s.order = o.order || 0, s.index = n, s.label = "" + o.label, s.visible = t.isDatasetVisible(n), s.controller) s.controller.updateIndex(n), s.controller.linkScales(); else { const i = An.getController(a), { datasetElementType: o, dataElementType: r } = xt.datasets[a]; Object.assign(i.prototype, { dataElementType: An.getElement(r), datasetElementType: o && An.getElement(o) }), s.controller = new i(t, n), e.push(s.controller) } } return t._updateMetasets(), e } _resetElements() { const t = this; J(t.data.datasets, ((e, i) => { t.getDatasetMeta(i).controller.reset() }), t) } reset() { this._resetElements(), this.notifyPlugins("reset") } update(t) { const e = this, i = e.config; i.update(), e._options = i.createResolver(i.chartOptionScopes(), e.getContext()), J(e.scales, (t => { Ge.removeBox(e, t) })); const n = e._animationsDisabled = !e.options.animation; e.ensureScalesHaveIDs(), e.buildOrUpdateScales(); const o = new Set(Object.keys(e._listeners)), s = new Set(e.options.events); if (ut(o, s) && !!this._responsiveListeners === e.options.responsive || (e.unbindEvents(), e.bindEvents()), e._plugins.invalidate(), !1 === e.notifyPlugins("beforeUpdate", { mode: t, cancelable: !0 })) return; const a = e.buildOrUpdateControllers(); e.notifyPlugins("beforeElementsUpdate"); let r = 0; for (let t = 0, i = e.data.datasets.length; t < i; t++) { const { controller: i } = e.getDatasetMeta(t), o = !n && -1 === a.indexOf(i); i.buildOrUpdateElements(o), r = Math.max(+i.getMaxOverflow(), r) } e._minPadding = r, e._updateLayout(r), n || J(a, (t => { t.reset() })), e._updateDatasets(t), e.notifyPlugins("afterUpdate", { mode: t }), e._layers.sort(Xn("z", "_idx")), e._lastEvent && e._eventHandler(e._lastEvent, !0), e.render() } _updateLayout(t) { const e = this; if (!1 === e.notifyPlugins("beforeLayout", { cancelable: !0 })) return; Ge.update(e, e.width, e.height, t); const i = e.chartArea, n = i.width <= 0 || i.height <= 0; e._layers = [], J(e.boxes, (t => { n && "chartArea" === t.position || (t.configure && t.configure(), e._layers.push(...t._layers())) }), e), e._layers.forEach(((t, e) => { t._idx = e })), e.notifyPlugins("afterLayout") } _updateDatasets(t) { const e = this, i = "function" == typeof t; if (!1 !== e.notifyPlugins("beforeDatasetsUpdate", { mode: t, cancelable: !0 })) { for (let n = 0, o = e.data.datasets.length; n < o; ++n)e._updateDataset(n, i ? t({ datasetIndex: n }) : t); e.notifyPlugins("afterDatasetsUpdate", { mode: t }) } } _updateDataset(t, e) { const i = this, n = i.getDatasetMeta(t), o = { meta: n, index: t, mode: e, cancelable: !0 }; !1 !== i.notifyPlugins("beforeDatasetUpdate", o) && (n.controller._update(e), o.cancelable = !1, i.notifyPlugins("afterDatasetUpdate", o)) } render() { const t = this; !1 !== t.notifyPlugins("beforeRender", { cancelable: !0 }) && (a.has(t) ? t.attached && !a.running(t) && a.start(t) : (t.draw(), qn({ chart: t }))) } draw() { const t = this; let e; if (t._resizeBeforeDraw) { const { width: e, height: i } = t._resizeBeforeDraw; t._resize(e, i), t._resizeBeforeDraw = null } if (t.clear(), t.width <= 0 || t.height <= 0) return; if (!1 === t.notifyPlugins("beforeDraw", { cancelable: !0 })) return; const i = t._layers; for (e = 0; e < i.length && i[e].z <= 0; ++e)i[e].draw(t.chartArea); for (t._drawDatasets(); e < i.length; ++e)i[e].draw(t.chartArea); t.notifyPlugins("afterDraw") } _getSortedDatasetMetas(t) { const e = this._sortedMetasets, i = []; let n, o; for (n = 0, o = e.length; n < o; ++n) { const o = e[n]; t && !o.visible || i.push(o) } return i } getSortedVisibleDatasetMetas() { return this._getSortedDatasetMetas(!0) } _drawDatasets() { const t = this; if (!1 === t.notifyPlugins("beforeDatasetsDraw", { cancelable: !0 })) return; const e = t.getSortedVisibleDatasetMetas(); for (let i = e.length - 1; i >= 0; --i)t._drawDataset(e[i]); t.notifyPlugins("afterDatasetsDraw") } _drawDataset(t) { const e = this, i = e.ctx, n = t._clip, o = e.chartArea, s = { meta: t, index: t.index, cancelable: !0 }; !1 !== e.notifyPlugins("beforeDatasetDraw", s) && (Zt(i, { left: !1 === n.left ? 0 : o.left - n.left, right: !1 === n.right ? e.width : o.right + n.right, top: !1 === n.top ? 0 : o.top - n.top, bottom: !1 === n.bottom ? e.height : o.bottom + n.bottom }), t.controller.draw(), Qt(i), s.cancelable = !1, e.notifyPlugins("afterDatasetDraw", s)) } getElementsAtEventForMode(t, e, i, n) { const o = Oe.modes[e]; return "function" == typeof o ? o(this, t, i, n) : [] } getDatasetMeta(t) { const e = this.data.datasets[t], i = this._metasets; let n = i.filter((t => t && t._dataset === e)).pop(); return n || (n = { type: null, data: [], dataset: null, controller: null, hidden: null, xAxisID: null, yAxisID: null, order: e && e.order || 0, index: t, _dataset: e, _parsed: [], _sorted: !1 }, i.push(n)), n } getContext() { return this.$context || (this.$context = { chart: this, type: "chart" }) } getVisibleDatasetCount() { return this.getSortedVisibleDatasetMetas().length } isDatasetVisible(t) { const e = this.data.datasets[t]; if (!e) return !1; const i = this.getDatasetMeta(t); return "boolean" == typeof i.hidden ? !i.hidden : !e.hidden } setDatasetVisibility(t, e) { this.getDatasetMeta(t).hidden = !e } toggleDataVisibility(t) { this._hiddenIndices[t] = !this._hiddenIndices[t] } getDataVisibility(t) { return !this._hiddenIndices[t] } _updateDatasetVisibility(t, e) { const i = this, n = e ? "show" : "hide", o = i.getDatasetMeta(t), s = o.controller._resolveAnimations(void 0, n); i.setDatasetVisibility(t, e), s.update(o, { visible: e }), i.update((e => e.datasetIndex === t ? n : void 0)) } hide(t) { this._updateDatasetVisibility(t, !1) } show(t) { this._updateDatasetVisibility(t, !0) } _destroyDatasetMeta(t) { const e = this, i = e._metasets && e._metasets[t]; i && i.controller && (i.controller._destroy(), delete e._metasets[t]) } destroy() { const t = this, { canvas: e, ctx: i } = t; let n, o; for (t.stop(), a.remove(t), n = 0, o = t.data.datasets.length; n < o; ++n)t._destroyDatasetMeta(n); t.config.clearCache(), e && (t.unbindEvents(), qt(e, i), t.platform.releaseContext(i), t.canvas = null, t.ctx = null), t.notifyPlugins("destroy"), delete Qn[t.id] } toBase64Image(...t) { return this.canvas.toDataURL(...t) } bindEvents() { this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0 } bindUserEvents() { const t = this, e = t._listeners, i = t.platform, n = function (e, i, n) { e.offsetX = i, e.offsetY = n, t._eventHandler(e) }; J(t.options.events, (o => ((n, o) => { i.addEventListener(t, n, o), e[n] = o })(o, n))) } bindResponsiveEvents() { const t = this; t._responsiveListeners || (t._responsiveListeners = {}); const e = t._responsiveListeners, i = t.platform, n = (n, o) => { i.addEventListener(t, n, o), e[n] = o }, o = (n, o) => { e[n] && (i.removeEventListener(t, n, o), delete e[n]) }, s = (e, i) => { t.canvas && t.resize(e, i) }; let a; const r = () => { o("attach", r), t.attached = !0, t.resize(), n("resize", s), n("detach", a) }; a = () => { t.attached = !1, o("resize", s), n("attach", r) }, i.isAttached(t.canvas) ? r() : a() } unbindEvents() { const t = this; J(t._listeners, ((e, i) => { t.platform.removeEventListener(t, i, e) })), t._listeners = {}, J(t._responsiveListeners, ((e, i) => { t.platform.removeEventListener(t, i, e) })), t._responsiveListeners = void 0 } updateHoverStyle(t, e, i) { const n = i ? "set" : "remove"; let o, s, a, r; for ("dataset" === e && (o = this.getDatasetMeta(t[0].datasetIndex), o.controller["_" + n + "DatasetHoverStyle"]()), a = 0, r = t.length; a < r; ++a) { s = t[a]; const e = s && this.getDatasetMeta(s.datasetIndex).controller; e && e[n + "HoverStyle"](s.element, s.datasetIndex, s.index) } } getActiveElements() { return this._active || [] } setActiveElements(t) { const e = this, i = e._active || [], n = t.map((({ datasetIndex: t, index: i }) => { const n = e.getDatasetMeta(t); if (!n) throw new Error("No dataset found at index " + t); return { datasetIndex: t, element: n.data[i], index: i } })); !tt(n, i) && (e._active = n, e._updateHoverStyles(n, i)) } notifyPlugins(t, e, i) { return this._plugins.notify(this, t, e, i) } _updateHoverStyles(t, e, i) { const n = this, o = n.options.hover, s = (t, e) => t.filter((t => !e.some((e => t.datasetIndex === e.datasetIndex && t.index === e.index)))), a = s(e, t), r = i ? t : s(t, e); a.length && n.updateHoverStyle(a, o.mode, !1), r.length && o.mode && n.updateHoverStyle(r, o.mode, !0) } _eventHandler(t, e) { const i = this, n = { event: t, replay: e, cancelable: !0 }, o = e => (e.options.events || this.options.events).includes(t.type); if (!1 === i.notifyPlugins("beforeEvent", n, o)) return; const s = i._handleEvent(t, e); return n.cancelable = !1, i.notifyPlugins("afterEvent", n, o), (s || n.changed) && i.render(), i } _handleEvent(t, e) { const i = this, { _active: n = [], options: o } = i, s = o.hover, a = e; let r = [], l = !1, c = null; return "mouseout" !== t.type && (r = i.getElementsAtEventForMode(t, s.mode, s, a), c = "click" === t.type ? i._lastEvent : t), i._lastEvent = null, Gt(t, i.chartArea, i._minPadding) && (Q(o.onHover, [t, r, i], i), "mouseup" !== t.type && "click" !== t.type && "contextmenu" !== t.type || Q(o.onClick, [t, r, i], i)), l = !tt(r, n), (l || e) && (i._active = r, i._updateHoverStyles(r, n, e)), i._lastEvent = c, l } } const eo = () => J(to.instances, (t => t._plugins.invalidate())), io = !0; function no() { throw new Error("This method is not implemented: Check that a complete date adapter is provided.") } Object.defineProperties(to, { defaults: { enumerable: io, value: xt }, instances: { enumerable: io, value: Qn }, overrides: { enumerable: io, value: ft }, registry: { enumerable: io, value: An }, version: { enumerable: io, value: "3.3.2" }, getChart: { enumerable: io, value: Jn }, register: { enumerable: io, value: (...t) => { An.add(...t), eo() } }, unregister: { enumerable: io, value: (...t) => { An.remove(...t), eo() } } }); class oo { constructor(t) { this.options = t || {} } formats() { return no() } parse(t, e) { return no() } format(t, e) { return no() } add(t, e, i) { return no() } diff(t, e, i) { return no() } startOf(t, e, i) { return no() } endOf(t, e) { return no() } } oo.override = function (t) { Object.assign(oo.prototype, t) }; var so = { _date: oo }; function ao(t) { const e = function (t) { if (!t._cache.$bar) { const e = t.getMatchingVisibleMetas("bar"); let i = []; for (let n = 0, o = e.length; n < o; n++)i = i.concat(e[n].controller.getAllParsedValues(t)); t._cache.$bar = he(i.sort(((t, e) => t - e))) } return t._cache.$bar }(t); let i, n, o, s, a = t._length; const r = () => { 32767 !== o && -32768 !== o && (ht(s) && (a = Math.min(a, Math.abs(o - s) || a)), s = o) }; for (i = 0, n = e.length; i < n; ++i)o = t.getPixelForValue(e[i]), r(); for (s = void 0, i = 0, n = t.ticks.length; i < n; ++i)o = t.getPixelForTick(i), r(); return a } function ro(t, e, i, n) { return Y(t) ? function (t, e, i, n) { const o = i.parse(t[0], n), s = i.parse(t[1], n), a = Math.min(o, s), r = Math.max(o, s); let l = a, c = r; Math.abs(a) > Math.abs(r) && (l = r, c = a), e[i.axis] = c, e._custom = { barStart: l, barEnd: c, start: o, end: s, min: a, max: r } }(t, e, i, n) : e[i.axis] = i.parse(t, n), e } function lo(t, e, i, n) { const o = t.iScale, s = t.vScale, a = o.getLabels(), r = o === s, l = []; let c, h, d, u; for (c = i, h = i + n; c < h; ++c)u = e[c], d = {}, d[o.axis] = r || o.parse(a[c], c), l.push(ro(u, d, s, c)); return l } function co(t) { return t && void 0 !== t.barStart && void 0 !== t.barEnd } class ho extends Ri { parsePrimitiveData(t, e, i, n) { return lo(t, e, i, n) } parseArrayData(t, e, i, n) { return lo(t, e, i, n) } parseObjectData(t, e, i, n) { const { iScale: o, vScale: s } = t, { xAxisKey: a = "x", yAxisKey: r = "y" } = this._parsing, l = "x" === o.axis ? a : r, c = "x" === s.axis ? a : r, h = []; let d, u, f, g; for (d = i, u = i + n; d < u; ++d)g = e[d], f = {}, f[o.axis] = o.parse(lt(g, l), d), h.push(ro(lt(g, c), f, s, d)); return h } updateRangeFromParsed(t, e, i, n) { super.updateRangeFromParsed(t, e, i, n); const o = i._custom; o && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, o.min), t.max = Math.max(t.max, o.max)) } getLabelAndValue(t) { const e = this._cachedMeta, { iScale: i, vScale: n } = e, o = this.getParsed(t), s = o._custom, a = co(s) ? "[" + s.start + ", " + s.end + "]" : "" + n.getLabelForValue(o[n.axis]); return { label: "" + i.getLabelForValue(o[i.axis]), value: a } } initialize() { const t = this; t.enableOptionSharing = !0, super.initialize(); t._cachedMeta.stack = t.getDataset().stack } update(t) { const e = this._cachedMeta; this.updateElements(e.data, 0, e.data.length, t) } updateElements(t, e, i, n) { const o = this, s = "reset" === n, a = o._cachedMeta.vScale, r = a.getBasePixel(), l = a.isHorizontal(), c = o._getRuler(), h = o.resolveDataElementOptions(e, n), d = o.getSharedOptions(h), u = o.includeOptions(n, d); o.updateSharedOptions(d, n, h); for (let h = e; h < e + i; h++) { const e = o.getParsed(h), i = s || $(e[a.axis]) ? { base: r, head: r } : o._calculateBarValuePixels(h), f = o._calculateBarIndexPixels(h, c), g = (e._stacks || {})[a.axis], p = { horizontal: l, base: i.base, enableBorderRadius: !g || co(e._custom) || o.index === g._top || o.index === g._bottom, x: l ? i.head : f.center, y: l ? f.center : i.head, height: l ? f.size : void 0, width: l ? void 0 : f.size }; u && (p.options = d || o.resolveDataElementOptions(h, n)), o.updateElement(t[h], h, p, n) } } _getStacks(t, e) { const i = this._cachedMeta.iScale, n = i.getMatchingVisibleMetas(this._type), o = i.options.stacked, s = n.length, a = []; let r, l; for (r = 0; r < s; ++r) { if (l = n[r], void 0 !== e) { const t = l.controller.getParsed(e)[l.controller._cachedMeta.vScale.axis]; if ($(t) || isNaN(t)) continue } if ((!1 === o || -1 === a.indexOf(l.stack) || void 0 === o && void 0 === l.stack) && a.push(l.stack), l.index === t) break } return a.length || a.push(void 0), a } _getStackCount(t) { return this._getStacks(void 0, t).length } _getStackIndex(t, e, i) { const n = this._getStacks(t, i), o = void 0 !== e ? n.indexOf(e) : -1; return -1 === o ? n.length - 1 : o } _getRuler() { const t = this, e = t.options, i = t._cachedMeta, n = i.iScale, o = []; let s, a; for (s = 0, a = i.data.length; s < a; ++s)o.push(n.getPixelForValue(t.getParsed(s)[n.axis], s)); const r = e.barThickness; return { min: r || ao(n), pixels: o, start: n._startPixel, end: n._endPixel, stackCount: t._getStackCount(), scale: n, grouped: e.grouped, ratio: r ? 1 : e.categoryPercentage * e.barPercentage } } _calculateBarValuePixels(t) { const e = this, { vScale: i, _stacked: n } = e._cachedMeta, { base: o, minBarLength: s } = e.options, a = e.getParsed(t), r = a._custom, l = co(r); let c, h, d = a[i.axis], u = 0, f = n ? e.applyStack(i, a, n) : d; f !== d && (u = f - d, f = d), l && (d = r.barStart, f = r.barEnd - r.barStart, 0 !== d && Dt(d) !== Dt(r.barEnd) && (u = 0), u += d); const g = $(o) || l ? u : o; let p = i.getPixelForValue(g); c = this.chart.getDataVisibility(t) ? i.getPixelForValue(u + f) : p, h = c - p, void 0 !== s && Math.abs(h) < s && (h = h < 0 ? -s : s, 0 === d && (p -= h / 2), c = p + h); const m = o || 0; if (p === i.getPixelForValue(m)) { const t = i.getLineWidthForValue(m) / 2; h > 0 ? (p += t, h -= t) : h < 0 && (p -= t, h += t) } return { size: h, base: p, head: c, center: c + h / 2 } } _calculateBarIndexPixels(t, e) { const i = this, n = e.scale, o = i.options, s = o.skipNull, a = K(o.maxBarThickness, 1 / 0); let r, l; if (e.grouped) { const n = s ? i._getStackCount(t) : e.stackCount, c = "flex" === o.barThickness ? function (t, e, i, n) { const o = e.pixels, s = o[t]; let a = t > 0 ? o[t - 1] : null, r = t < o.length - 1 ? o[t + 1] : null; const l = i.categoryPercentage; null === a && (a = s - (null === r ? e.end - e.start : r - s)), null === r && (r = s + s - a); const c = s - (s - Math.min(a, r)) / 2 * l; return { chunk: Math.abs(r - a) / 2 * l / n, ratio: i.barPercentage, start: c } }(t, e, o, n) : function (t, e, i, n) { const o = i.barThickness; let s, a; return $(o) ? (s = e.min * i.categoryPercentage, a = i.barPercentage) : (s = o * n, a = 1), { chunk: s / n, ratio: a, start: e.pixels[t] - s / 2 } }(t, e, o, n), h = i._getStackIndex(i.index, i._cachedMeta.stack, s ? t : void 0); r = c.start + c.chunk * h + c.chunk / 2, l = Math.min(a, c.chunk * c.ratio) } else r = n.getPixelForValue(i.getParsed(t)[n.axis], t), l = Math.min(a, e.min * e.ratio); return { base: r - l / 2, head: r + l / 2, center: r, size: l } } draw() { const t = this, e = t.chart, i = t._cachedMeta, n = i.vScale, o = i.data, s = o.length; let a = 0; for (Zt(e.ctx, e.chartArea); a < s; ++a)null !== t.getParsed(a)[n.axis] && o[a].draw(t._ctx); Qt(e.ctx) } } ho.id = "bar", ho.defaults = { datasetElementType: !1, dataElementType: "bar", categoryPercentage: .8, barPercentage: .9, grouped: !0, animations: { numbers: { type: "number", properties: ["x", "y", "base", "width", "height"] } } }, ho.overrides = { interaction: { mode: "index" }, scales: { _index_: { type: "category", offset: !0, grid: { offset: !0 } }, _value_: { type: "linear", beginAtZero: !0 } } }; class uo extends Ri { initialize() { this.enableOptionSharing = !0, super.initialize() } parseObjectData(t, e, i, n) { const { xScale: o, yScale: s } = t, { xAxisKey: a = "x", yAxisKey: r = "y" } = this._parsing, l = []; let c, h, d; for (c = i, h = i + n; c < h; ++c)d = e[c], l.push({ x: o.parse(lt(d, a), c), y: s.parse(lt(d, r), c), _custom: d && d.r && +d.r }); return l } getMaxOverflow() { const { data: t, _parsed: e } = this._cachedMeta; let i = 0; for (let n = t.length - 1; n >= 0; --n)i = Math.max(i, t[n].size() / 2, e[n]._custom); return i > 0 && i } getLabelAndValue(t) { const e = this._cachedMeta, { xScale: i, yScale: n } = e, o = this.getParsed(t), s = i.getLabelForValue(o.x), a = n.getLabelForValue(o.y), r = o._custom; return { label: e.label, value: "(" + s + ", " + a + (r ? ", " + r : "") + ")" } } update(t) { const e = this._cachedMeta.data; this.updateElements(e, 0, e.length, t) } updateElements(t, e, i, n) { const o = this, s = "reset" === n, { iScale: a, vScale: r } = o._cachedMeta, l = o.resolveDataElementOptions(e, n), c = o.getSharedOptions(l), h = o.includeOptions(n, c), d = a.axis, u = r.axis; for (let l = e; l < e + i; l++) { const e = t[l], i = !s && o.getParsed(l), c = {}, f = c[d] = s ? a.getPixelForDecimal(.5) : a.getPixelForValue(i[d]), g = c[u] = s ? r.getBasePixel() : r.getPixelForValue(i[u]); c.skip = isNaN(f) || isNaN(g), h && (c.options = o.resolveDataElementOptions(l, n), s && (c.options.radius = 0)), o.updateElement(e, l, c, n) } o.updateSharedOptions(c, n, l) } resolveDataElementOptions(t, e) { const i = this.getParsed(t); let n = super.resolveDataElementOptions(t, e); n.$shared && (n = Object.assign({}, n, { $shared: !1 })); const o = n.radius; return "active" !== e && (n.radius = 0), n.radius += K(i && i._custom, o), n } } uo.id = "bubble", uo.defaults = { datasetElementType: !1, dataElementType: "point", animations: { numbers: { type: "number", properties: ["x", "y", "borderWidth", "radius"] } } }, uo.overrides = { scales: { x: { type: "linear" }, y: { type: "linear" } }, plugins: { tooltip: { callbacks: { title: () => "" } } } }; class fo extends Ri { constructor(t, e) { super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0 } linkScales() { } parse(t, e) { const i = this.getDataset().data, n = this._cachedMeta; let o, s; for (o = t, s = t + e; o < s; ++o)n._parsed[o] = +i[o] } _getRotation() { return Et(this.options.rotation - 90) } _getCircumference() { return Et(this.options.circumference) } _getRotationExtents() { let t = _t, e = -_t; const i = this; for (let n = 0; n < i.chart.data.datasets.length; ++n)if (i.chart.isDatasetVisible(n)) { const o = i.chart.getDatasetMeta(n).controller, s = o._getRotation(), a = o._getCircumference(); t = Math.min(t, s), e = Math.max(e, s + a) } return { rotation: t, circumference: e - t } } update(t) { const e = this, i = e.chart, { chartArea: n } = i, o = e._cachedMeta, s = o.data, a = e.getMaxBorderWidth() + e.getMaxOffset(s), r = Math.max((Math.min(n.width, n.height) - a) / 2, 0), l = Math.min(G(e.options.cutout, r), 1), c = e._getRingWeight(e.index), { circumference: h, rotation: d } = e._getRotationExtents(), { ratioX: u, ratioY: f, offsetX: g, offsetY: p } = function (t, e, i) { let n = 1, o = 1, s = 0, a = 0; if (e < _t) { const r = t, l = r + e, c = Math.cos(r), h = Math.sin(r), d = Math.cos(l), u = Math.sin(l), f = (t, e, n) => Ht(t, r, l, !0) ? 1 : Math.max(e, e * i, n, n * i), g = (t, e, n) => Ht(t, r, l, !0) ? -1 : Math.min(e, e * i, n, n * i), p = f(0, c, d), m = f(Mt, h, u), x = g(bt, c, d), b = g(bt + Mt, h, u); n = (p - x) / 2, o = (m - b) / 2, s = -(p + x) / 2, a = -(m + b) / 2 } return { ratioX: n, ratioY: o, offsetX: s, offsetY: a } }(d, h, l), m = (n.width - a) / u, x = (n.height - a) / f, b = Math.max(Math.min(m, x) / 2, 0), _ = Z(e.options.radius, b), y = (_ - Math.max(_ * l, 0)) / e._getVisibleDatasetWeightTotal(); e.offsetX = g * _, e.offsetY = p * _, o.total = e.calculateTotal(), e.outerRadius = _ - y * e._getRingWeightOffset(e.index), e.innerRadius = Math.max(e.outerRadius - y * c, 0), e.updateElements(s, 0, s.length, t) } _circumference(t, e) { const i = this, n = i.options, o = i._cachedMeta, s = i._getCircumference(); return e && n.animation.animateRotate || !this.chart.getDataVisibility(t) || null === o._parsed[t] ? 0 : i.calculateCircumference(o._parsed[t] * s / _t) } updateElements(t, e, i, n) { const o = this, s = "reset" === n, a = o.chart, r = a.chartArea, l = a.options.animation, c = (r.left + r.right) / 2, h = (r.top + r.bottom) / 2, d = s && l.animateScale, u = d ? 0 : o.innerRadius, f = d ? 0 : o.outerRadius, g = o.resolveDataElementOptions(e, n), p = o.getSharedOptions(g), m = o.includeOptions(n, p); let x, b = o._getRotation(); for (x = 0; x < e; ++x)b += o._circumference(x, s); for (x = e; x < e + i; ++x) { const e = o._circumference(x, s), i = t[x], a = { x: c + o.offsetX, y: h + o.offsetY, startAngle: b, endAngle: b + e, circumference: e, outerRadius: f, innerRadius: u }; m && (a.options = p || o.resolveDataElementOptions(x, n)), b += e, o.updateElement(i, x, a, n) } o.updateSharedOptions(p, n, g) } calculateTotal() { const t = this._cachedMeta, e = t.data; let i, n = 0; for (i = 0; i < e.length; i++) { const e = t._parsed[i]; null !== e && !isNaN(e) && this.chart.getDataVisibility(i) && (n += Math.abs(e)) } return n } calculateCircumference(t) { const e = this._cachedMeta.total; return e > 0 && !isNaN(t) ? _t * (Math.abs(t) / e) : 0 } getLabelAndValue(t) { const e = this._cachedMeta, i = this.chart, n = i.data.labels || [], o = zi(e._parsed[t], i.options.locale); return { label: n[t] || "", value: o } } getMaxBorderWidth(t) { const e = this; let i = 0; const n = e.chart; let o, s, a, r, l; if (!t) for (o = 0, s = n.data.datasets.length; o < s; ++o)if (n.isDatasetVisible(o)) { a = n.getDatasetMeta(o), t = a.data, r = a.controller, r !== e && r.configure(); break } if (!t) return 0; for (o = 0, s = t.length; o < s; ++o)l = r.resolveDataElementOptions(o), "inner" !== l.borderAlign && (i = Math.max(i, l.borderWidth || 0, l.hoverBorderWidth || 0)); return i } getMaxOffset(t) { let e = 0; for (let i = 0, n = t.length; i < n; ++i) { const t = this.resolveDataElementOptions(i); e = Math.max(e, t.offset || 0, t.hoverOffset || 0) } return e } _getRingWeightOffset(t) { let e = 0; for (let i = 0; i < t; ++i)this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i)); return e } _getRingWeight(t) { return Math.max(K(this.chart.data.datasets[t].weight, 1), 0) } _getVisibleDatasetWeightTotal() { return this._getRingWeightOffset(this.chart.data.datasets.length) || 1 } } fo.id = "doughnut", fo.defaults = { datasetElementType: !1, dataElementType: "arc", animation: { animateRotate: !0, animateScale: !1 }, animations: { numbers: { type: "number", properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth"] } }, cutout: "50%", rotation: 0, circumference: 360, radius: "100%", indexAxis: "r" }, fo.overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) { const e = t.data; return e.labels.length && e.datasets.length ? e.labels.map(((e, i) => { const n = t.getDatasetMeta(0).controller.getStyle(i); return { text: e, fillStyle: n.backgroundColor, strokeStyle: n.borderColor, lineWidth: n.borderWidth, hidden: !t.getDataVisibility(i), index: i } })) : [] } }, onClick(t, e, i) { i.chart.toggleDataVisibility(e.index), i.chart.update() } }, tooltip: { callbacks: { title: () => "", label(t) { let e = t.label; const i = ": " + t.formattedValue; return Y(e) ? (e = e.slice(), e[0] += i) : e += i, e } } } } }; class go extends Ri { initialize() { this.enableOptionSharing = !0, super.initialize() } update(t) { const e = this, i = e._cachedMeta, { dataset: n, data: o = [], _dataset: s } = i, a = e.chart._animationsDisabled; let { start: r, count: l } = function (t, e, i) { const n = e.length; let o = 0, s = n; if (t._sorted) { const { iScale: a, _parsed: r } = t, l = a.axis, { min: c, max: h, minDefined: d, maxDefined: u } = a.getUserBounds(); d && (o = Nt(Math.min(oe(r, a.axis, c).lo, i ? n : oe(e, l, a.getPixelForValue(c)).lo), 0, n - 1)), s = u ? Nt(Math.max(oe(r, a.axis, h).hi + 1, i ? 0 : oe(e, l, a.getPixelForValue(h)).hi + 1), o, n) - o : n - o } return { start: o, count: s } }(i, o, a); e._drawStart = r, e._drawCount = l, function (t) { const { xScale: e, yScale: i, _scaleRanges: n } = t, o = { xmin: e.min, xmax: e.max, ymin: i.min, ymax: i.max }; if (!n) return t._scaleRanges = o, !0; const s = n.xmin !== e.min || n.xmax !== e.max || n.ymin !== i.min || n.ymax !== i.max; return Object.assign(n, o), s }(i) && (r = 0, l = o.length), n._decimated = !!s._decimated, n.points = o; const c = e.resolveDatasetElementOptions(t); e.options.showLine || (c.borderWidth = 0), c.segment = e.options.segment, e.updateElement(n, void 0, { animated: !a, options: c }, t), e.updateElements(o, r, l, t) } updateElements(t, e, i, n) { const o = this, s = "reset" === n, { iScale: a, vScale: r, _stacked: l } = o._cachedMeta, c = o.resolveDataElementOptions(e, n), h = o.getSharedOptions(c), d = o.includeOptions(n, h), u = a.axis, f = r.axis, g = o.options.spanGaps, p = Tt(g) ? g : Number.POSITIVE_INFINITY, m = o.chart._animationsDisabled || s || "none" === n; let x = e > 0 && o.getParsed(e - 1); for (let c = e; c < e + i; ++c) { const e = t[c], i = o.getParsed(c), g = m ? e : {}, b = $(i[f]), _ = g[u] = a.getPixelForValue(i[u], c), y = g[f] = s || b ? r.getBasePixel() : r.getPixelForValue(l ? o.applyStack(r, i, l) : i[f], c); g.skip = isNaN(_) || isNaN(y) || b, g.stop = c > 0 && i[u] - x[u] > p, g.parsed = i, d && (g.options = h || o.resolveDataElementOptions(c, n)), m || o.updateElement(e, c, g, n), x = i } o.updateSharedOptions(h, n, c) } getMaxOverflow() { const t = this, e = t._cachedMeta, i = e.dataset, n = i.options && i.options.borderWidth || 0, o = e.data || []; if (!o.length) return n; const s = o[0].size(t.resolveDataElementOptions(0)), a = o[o.length - 1].size(t.resolveDataElementOptions(o.length - 1)); return Math.max(n, s, a) / 2 } draw() { const t = this._cachedMeta; t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw() } } go.id = "line", go.defaults = { datasetElementType: "line", dataElementType: "point", showLine: !0, spanGaps: !1 }, go.overrides = { scales: { _index_: { type: "category" }, _value_: { type: "linear" } } }; class po extends Ri { constructor(t, e) { super(t, e), this.innerRadius = void 0, this.outerRadius = void 0 } getLabelAndValue(t) { const e = this._cachedMeta, i = this.chart, n = i.data.labels || [], o = zi(e._parsed[t].r, i.options.locale); return { label: n[t] || "", value: o } } update(t) { const e = this._cachedMeta.data; this._updateRadius(), this.updateElements(e, 0, e.length, t) } _updateRadius() { const t = this, e = t.chart, i = e.chartArea, n = e.options, o = Math.min(i.right - i.left, i.bottom - i.top), s = Math.max(o / 2, 0), a = (s - Math.max(n.cutoutPercentage ? s / 100 * n.cutoutPercentage : 1, 0)) / e.getVisibleDatasetCount(); t.outerRadius = s - a * t.index, t.innerRadius = t.outerRadius - a } updateElements(t, e, i, n) { const o = this, s = "reset" === n, a = o.chart, r = o.getDataset(), l = a.options.animation, c = o._cachedMeta.rScale, h = c.xCenter, d = c.yCenter, u = c.getIndexAngle(0) - .5 * bt; let f, g = u; const p = 360 / o.countVisibleElements(); for (f = 0; f < e; ++f)g += o._computeAngle(f, n, p); for (f = e; f < e + i; f++) { const e = t[f]; let i = g, m = g + o._computeAngle(f, n, p), x = a.getDataVisibility(f) ? c.getDistanceFromCenterForValue(r.data[f]) : 0; g = m, s && (l.animateScale && (x = 0), l.animateRotate && (i = m = u)); const b = { x: h, y: d, innerRadius: 0, outerRadius: x, startAngle: i, endAngle: m, options: o.resolveDataElementOptions(f, n) }; o.updateElement(e, f, b, n) } } countVisibleElements() { const t = this.getDataset(), e = this._cachedMeta; let i = 0; return e.data.forEach(((e, n) => { !isNaN(t.data[n]) && this.chart.getDataVisibility(n) && i++ })), i } _computeAngle(t, e, i) { return this.chart.getDataVisibility(t) ? Et(this.resolveDataElementOptions(t, e).angle || i) : 0 } } po.id = "polarArea", po.defaults = { dataElementType: "arc", animation: { animateRotate: !0, animateScale: !0 }, animations: { numbers: { type: "number", properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"] } }, indexAxis: "r", startAngle: 0 }, po.overrides = { aspectRatio: 1, plugins: { legend: { labels: { generateLabels(t) { const e = t.data; return e.labels.length && e.datasets.length ? e.labels.map(((e, i) => { const n = t.getDatasetMeta(0).controller.getStyle(i); return { text: e, fillStyle: n.backgroundColor, strokeStyle: n.borderColor, lineWidth: n.borderWidth, hidden: !t.getDataVisibility(i), index: i } })) : [] } }, onClick(t, e, i) { i.chart.toggleDataVisibility(e.index), i.chart.update() } }, tooltip: { callbacks: { title: () => "", label: t => t.chart.data.labels[t.dataIndex] + ": " + t.formattedValue } } }, scales: { r: { type: "radialLinear", angleLines: { display: !1 }, beginAtZero: !0, grid: { circular: !0 }, pointLabels: { display: !1 }, startAngle: 0 } } }; class mo extends fo { } mo.id = "pie", mo.defaults = { cutout: 0, rotation: 0, circumference: 360, radius: "100%" }; class xo extends Ri { getLabelAndValue(t) { const e = this._cachedMeta.vScale, i = this.getParsed(t); return { label: e.getLabels()[t], value: "" + e.getLabelForValue(i[e.axis]) } } update(t) { const e = this, i = e._cachedMeta, n = i.dataset, o = i.data || [], s = i.iScale.getLabels(); if (n.points = o, "resize" !== t) { const i = e.resolveDatasetElementOptions(t); e.options.showLine || (i.borderWidth = 0); const a = { _loop: !0, _fullLoop: s.length === o.length, options: i }; e.updateElement(n, void 0, a, t) } e.updateElements(o, 0, o.length, t) } updateElements(t, e, i, n) { const o = this, s = o.getDataset(), a = o._cachedMeta.rScale, r = "reset" === n; for (let l = e; l < e + i; l++) { const e = t[l], i = o.resolveDataElementOptions(l, n), c = a.getPointPositionForValue(l, s.data[l]), h = r ? a.xCenter : c.x, d = r ? a.yCenter : c.y, u = { x: h, y: d, angle: c.angle, skip: isNaN(h) || isNaN(d), options: i }; o.updateElement(e, l, u, n) } } } xo.id = "radar", xo.defaults = { datasetElementType: "line", dataElementType: "point", indexAxis: "r", showLine: !0, elements: { line: { fill: "start" } } }, xo.overrides = { aspectRatio: 1, scales: { r: { type: "radialLinear" } } }; class bo extends go { } bo.id = "scatter", bo.defaults = { showLine: !1, fill: !1 }, bo.overrides = { interaction: { mode: "point" }, plugins: { tooltip: { callbacks: { title: () => "", label: t => "(" + t.label + ", " + t.formattedValue + ")" } } }, scales: { x: { type: "linear" }, y: { type: "linear" } } }; var _o = Object.freeze({ __proto__: null, BarController: ho, BubbleController: uo, DoughnutController: fo, LineController: go, PolarAreaController: po, PieController: mo, RadarController: xo, ScatterController: bo }); function yo(t, e, i) { const { startAngle: n, pixelMargin: o, x: s, y: a, outerRadius: r, innerRadius: l } = e; let c = o / r; t.beginPath(), t.arc(s, a, r, n - c, i + c), l > o ? (c = o / l, t.arc(s, a, l, i + c, n - c, !0)) : t.arc(s, a, o, i + Mt, n - Mt), t.closePath(), t.clip() } function vo(t, e, i, n) { const o = Re(t.options.borderRadius, ["outerStart", "outerEnd", "innerStart", "innerEnd"]); const s = (i - e) / 2, a = Math.min(s, n * e / 2), r = t => { const e = (i - Math.min(s, t)) * n / 2; return Nt(t, 0, Math.min(s, e)) }; return { outerStart: r(o.outerStart), outerEnd: r(o.outerEnd), innerStart: Nt(o.innerStart, 0, a), innerEnd: Nt(o.innerEnd, 0, a) } } function wo(t, e, i, n) { return { x: i + t * Math.cos(e), y: n + t * Math.sin(e) } } function Mo(t, e, i, n) { const { x: o, y: s, startAngle: a, pixelMargin: r, innerRadius: l } = e, c = Math.max(e.outerRadius + i - r, 0), h = l > 0 ? l + i + r : 0, d = n - a, u = (d - Math.max(.001, d * c - i / bt) / c) / 2, f = a + u, g = n - u, { outerStart: p, outerEnd: m, innerStart: x, innerEnd: b } = vo(e, h, c, g - f), _ = c - p, y = c - m, v = f + p / _, w = g - m / y, M = h + x, k = h + b, S = f + x / M, P = g - b / k; if (t.beginPath(), t.arc(o, s, c, v, w), m > 0) { const e = wo(y, w, o, s); t.arc(e.x, e.y, m, w, g + Mt) } const D = wo(k, g, o, s); if (t.lineTo(D.x, D.y), b > 0) { const e = wo(k, P, o, s); t.arc(e.x, e.y, b, g + Mt, P + Math.PI) } if (t.arc(o, s, h, g - b / h, f + x / h, !0), x > 0) { const e = wo(M, S, o, s); t.arc(e.x, e.y, x, S + Math.PI, f - Mt) } const C = wo(_, f, o, s); if (t.lineTo(C.x, C.y), p > 0) { const e = wo(_, v, o, s); t.arc(e.x, e.y, p, f - Mt, v) } t.closePath() } function ko(t, e, i, n) { const { options: o } = e, s = "inner" === o.borderAlign; o.borderWidth && (s ? (t.lineWidth = 2 * o.borderWidth, t.lineJoin = "round") : (t.lineWidth = o.borderWidth, t.lineJoin = "bevel"), e.fullCircles && function (t, e, i) { const { x: n, y: o, startAngle: s, pixelMargin: a, fullCircles: r } = e, l = Math.max(e.outerRadius - a, 0), c = e.innerRadius + a; let h; for (i && yo(t, e, s + _t), t.beginPath(), t.arc(n, o, c, s + _t, s, !0), h = 0; h < r; ++h)t.stroke(); for (t.beginPath(), t.arc(n, o, l, s, s + _t), h = 0; h < r; ++h)t.stroke() }(t, e, s), s && yo(t, e, n), Mo(t, e, i, n), t.stroke()) } class So extends Ei { constructor(t) { super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t) } inRange(t, e, i) { const n = this.getProps(["x", "y"], i), { angle: o, distance: s } = Ft(n, { x: t, y: e }), { startAngle: a, endAngle: r, innerRadius: l, outerRadius: c, circumference: h } = this.getProps(["startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], i); return (h >= _t || Ht(o, a, r)) && (s >= l && s <= c) } getCenterPoint(t) { const { x: e, y: i, startAngle: n, endAngle: o, innerRadius: s, outerRadius: a } = this.getProps(["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius", "circumference"], t), r = (n + o) / 2, l = (s + a) / 2; return { x: e + Math.cos(r) * l, y: i + Math.sin(r) * l } } tooltipPosition(t) { return this.getCenterPoint(t) } draw(t) { const e = this, { options: i, circumference: n } = e, o = (i.offset || 0) / 2; if (e.pixelMargin = "inner" === i.borderAlign ? .33 : 0, e.fullCircles = n > _t ? Math.floor(n / _t) : 0, 0 === n || e.innerRadius < 0 || e.outerRadius < 0) return; t.save(); let s = 0; if (o) { s = o / 2; const i = (e.startAngle + e.endAngle) / 2; t.translate(Math.cos(i) * s, Math.sin(i) * s), e.circumference >= bt && (s = o) } t.fillStyle = i.backgroundColor, t.strokeStyle = i.borderColor; const a = function (t, e, i) { const { fullCircles: n, startAngle: o, circumference: s } = e; let a = e.endAngle; if (n) { Mo(t, e, i, o + _t); for (let e = 0; e < n; ++e)t.fill(); isNaN(s) || (a = o + s % _t, s % _t == 0 && (a += _t)) } return Mo(t, e, i, a), t.fill(), a }(t, e, s); ko(t, e, s, a), t.restore() } } function Po(t, e, i = e) { t.lineCap = K(i.borderCapStyle, e.borderCapStyle), t.setLineDash(K(i.borderDash, e.borderDash)), t.lineDashOffset = K(i.borderDashOffset, e.borderDashOffset), t.lineJoin = K(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = K(i.borderWidth, e.borderWidth), t.strokeStyle = K(i.borderColor, e.borderColor) } function Do(t, e, i) { t.lineTo(i.x, i.y) } function Co(t, e, i = {}) { const n = t.length, { start: o = 0, end: s = n - 1 } = i, { start: a, end: r } = e, l = Math.max(o, a), c = Math.min(s, r), h = o < a && s < a || o > r && s > r; return { count: n, start: l, loop: e.loop, ilen: c < l && !h ? n + c - l : c - l } } function Oo(t, e, i, n) { const { points: o, options: s } = e, { count: a, start: r, loop: l, ilen: c } = Co(o, i, n), h = function (t) { return t.stepped ? Jt : t.tension || "monotone" === t.cubicInterpolationMode ? te : Do }(s); let d, u, f, { move: g = !0, reverse: p } = n || {}; for (d = 0; d <= c; ++d)u = o[(r + (p ? c - d : d)) % a], u.skip || (g ? (t.moveTo(u.x, u.y), g = !1) : h(t, f, u, p, s.stepped), f = u); return l && (u = o[(r + (p ? c : 0)) % a], h(t, f, u, p, s.stepped)), !!l } function To(t, e, i, n) { const o = e.points, { count: s, start: a, ilen: r } = Co(o, i, n), { move: l = !0, reverse: c } = n || {}; let h, d, u, f, g, p, m = 0, x = 0; const b = t => (a + (c ? r - t : t)) % s, _ = () => { f !== g && (t.lineTo(m, g), t.lineTo(m, f), t.lineTo(m, p)) }; for (l && (d = o[b(0)], t.moveTo(d.x, d.y)), h = 0; h <= r; ++h) { if (d = o[b(h)], d.skip) continue; const e = d.x, i = d.y, n = 0 | e; n === u ? (i < f ? f = i : i > g && (g = i), m = (x * m + e) / ++x) : (_(), t.lineTo(e, i), u = n, x = 0, f = g = i), p = i } _() } function Ao(t) { const e = t.options, i = e.borderDash && e.borderDash.length; return !(t._decimated || t._loop || e.tension || "monotone" === e.cubicInterpolationMode || e.stepped || i) ? To : Oo } So.id = "arc", So.defaults = { borderAlign: "center", borderColor: "#fff", borderRadius: 0, borderWidth: 2, offset: 0, angle: void 0 }, So.defaultRoutes = { backgroundColor: "backgroundColor" }; const Lo = "function" == typeof Path2D; function Ro(t, e, i, n) { Lo && 1 === e.segments.length ? function (t, e, i, n) { let o = e._path; o || (o = e._path = new Path2D, e.path(o, i, n) && o.closePath()), Po(t, e.options), t.stroke(o) }(t, e, i, n) : function (t, e, i, n) { const { segments: o, options: s } = e, a = Ao(e); for (const r of o) Po(t, s, r.style), t.beginPath(), a(t, e, r, { start: i, end: i + n - 1 }) && t.closePath(), t.stroke() }(t, e, i, n) } class Eo extends Ei { constructor(t) { super(), this.animated = !0, this.options = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, t && Object.assign(this, t) } updateControlPoints(t, e) { const i = this, n = i.options; if ((n.tension || "monotone" === n.cubicInterpolationMode) && !n.stepped && !i._pointsUpdated) { const o = n.spanGaps ? i._loop : i._fullLoop; gn(i._points, n, t, o, e), i._pointsUpdated = !0 } } set points(t) { const e = this; e._points = t, delete e._segments, delete e._path, e._pointsUpdated = !1 } get points() { return this._points } get segments() { return this._segments || (this._segments = Sn(this, this.options.segment)) } first() { const t = this.segments, e = this.points; return t.length && e[t[0].start] } last() { const t = this.segments, e = this.points, i = t.length; return i && e[t[i - 1].end] } interpolate(t, e) { const i = this, n = i.options, o = t[e], s = i.points, a = kn(i, { property: e, start: o, end: o }); if (!a.length) return; const r = [], l = function (t) { return t.stepped ? mn : t.tension || "monotone" === t.cubicInterpolationMode ? xn : pn }(n); let c, h; for (c = 0, h = a.length; c < h; ++c) { const { start: i, end: h } = a[c], d = s[i], u = s[h]; if (d === u) { r.push(d); continue } const f = l(d, u, Math.abs((o - d[e]) / (u[e] - d[e])), n.stepped); f[e] = t[e], r.push(f) } return 1 === r.length ? r[0] : r } pathSegment(t, e, i) { return Ao(this)(t, this, e, i) } path(t, e, i) { const n = this, o = n.segments, s = Ao(n); let a = n._loop; e = e || 0, i = i || n.points.length - e; for (const r of o) a &= s(t, n, r, { start: e, end: e + i - 1 }); return !!a } draw(t, e, i, n) { const o = this, s = o.options || {}; (o.points || []).length && s.borderWidth && (t.save(), Ro(t, o, i, n), t.restore(), o.animated && (o._pointsUpdated = !1, o._path = void 0)) } } function Io(t, e, i, n) { const o = t.options, { [i]: s } = t.getProps([i], n); return Math.abs(e - s) < o.radius + o.hitRadius } Eo.id = "line", Eo.defaults = { borderCapStyle: "butt", borderDash: [], borderDashOffset: 0, borderJoinStyle: "miter", borderWidth: 3, capBezierPoints: !0, cubicInterpolationMode: "default", fill: !1, spanGaps: !1, stepped: !1, tension: 0 }, Eo.defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" }, Eo.descriptors = { _scriptable: !0, _indexable: t => "borderDash" !== t && "fill" !== t }; class zo extends Ei { constructor(t) { super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t) } inRange(t, e, i) { const n = this.options, { x: o, y: s } = this.getProps(["x", "y"], i); return Math.pow(t - o, 2) + Math.pow(e - s, 2) < Math.pow(n.hitRadius + n.radius, 2) } inXRange(t, e) { return Io(this, t, "x", e) } inYRange(t, e) { return Io(this, t, "y", e) } getCenterPoint(t) { const { x: e, y: i } = this.getProps(["x", "y"], t); return { x: e, y: i } } size(t) { let e = (t = t || this.options || {}).radius || 0; e = Math.max(e, e && t.hoverRadius || 0); return 2 * (e + (e && t.borderWidth || 0)) } draw(t) { const e = this, i = e.options; e.skip || i.radius < .1 || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Kt(t, i, e.x, e.y)) } getRange() { const t = this.options || {}; return t.radius + t.hitRadius } } function Fo(t, e) { const { x: i, y: n, base: o, width: s, height: a } = t.getProps(["x", "y", "base", "width", "height"], e); let r, l, c, h, d; return t.horizontal ? (d = a / 2, r = Math.min(i, o), l = Math.max(i, o), c = n - d, h = n + d) : (d = s / 2, r = i - d, l = i + d, c = Math.min(n, o), h = Math.max(n, o)), { left: r, top: c, right: l, bottom: h } } function Vo(t) { let e = t.options.borderSkipped; const i = {}; return e ? (e = t.horizontal ? Bo(e, "left", "right", t.base > t.x) : Bo(e, "bottom", "top", t.base < t.y), i[e] = !0, i) : i } function Bo(t, e, i, n) { var o, s, a; return n ? (a = i, t = Wo(t = (o = t) === (s = e) ? a : o === a ? s : o, i, e)) : t = Wo(t, e, i), t } function Wo(t, e, i) { return "start" === t ? e : "end" === t ? i : t } function Ho(t, e, i, n) { return t ? 0 : Math.max(Math.min(e, n), i) } function No(t) { const e = Fo(t), i = e.right - e.left, n = e.bottom - e.top, o = function (t, e, i) { const n = t.options.borderWidth, o = Vo(t), s = Ee(n); return { t: Ho(o.top, s.top, 0, i), r: Ho(o.right, s.right, 0, e), b: Ho(o.bottom, s.bottom, 0, i), l: Ho(o.left, s.left, 0, e) } }(t, i / 2, n / 2), s = function (t, e, i) { const { enableBorderRadius: n } = t.getProps(["enableBorderRadius"]), o = t.options.borderRadius, s = Ie(o), a = Math.min(e, i), r = Vo(t), l = n || U(o); return { topLeft: Ho(!l || r.top || r.left, s.topLeft, 0, a), topRight: Ho(!l || r.top || r.right, s.topRight, 0, a), bottomLeft: Ho(!l || r.bottom || r.left, s.bottomLeft, 0, a), bottomRight: Ho(!l || r.bottom || r.right, s.bottomRight, 0, a) } }(t, i / 2, n / 2); return { outer: { x: e.left, y: e.top, w: i, h: n, radius: s }, inner: { x: e.left + o.l, y: e.top + o.t, w: i - o.l - o.r, h: n - o.t - o.b, radius: { topLeft: Math.max(0, s.topLeft - Math.max(o.t, o.l)), topRight: Math.max(0, s.topRight - Math.max(o.t, o.r)), bottomLeft: Math.max(0, s.bottomLeft - Math.max(o.b, o.l)), bottomRight: Math.max(0, s.bottomRight - Math.max(o.b, o.r)) } } } } function jo(t, e, i, n) { const o = null === e, s = null === i, a = t && !(o && s) && Fo(t, n); return a && (o || e >= a.left && e <= a.right) && (s || i >= a.top && i <= a.bottom) } function $o(t, e) { t.rect(e.x, e.y, e.w, e.h) } zo.id = "point", zo.defaults = { borderWidth: 1, hitRadius: 1, hoverBorderWidth: 1, hoverRadius: 4, pointStyle: "circle", radius: 3, rotation: 0 }, zo.defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" }; class Yo extends Ei { constructor(t) { super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, t && Object.assign(this, t) } draw(t) { const e = this.options, { inner: i, outer: n } = No(this), o = (s = n.radius).topLeft || s.topRight || s.bottomLeft || s.bottomRight ? ie : $o; var s; t.save(), n.w === i.w && n.h === i.h || (t.beginPath(), o(t, n), t.clip(), o(t, i), t.fillStyle = e.borderColor, t.fill("evenodd")), t.beginPath(), o(t, i), t.fillStyle = e.backgroundColor, t.fill(), t.restore() } inRange(t, e, i) { return jo(this, t, e, i) } inXRange(t, e) { return jo(this, t, null, e) } inYRange(t, e) { return jo(this, null, t, e) } getCenterPoint(t) { const { x: e, y: i, base: n, horizontal: o } = this.getProps(["x", "y", "base", "horizontal"], t); return { x: o ? (e + n) / 2 : e, y: o ? i : (i + n) / 2 } } getRange(t) { return "x" === t ? this.width / 2 : this.height / 2 } } Yo.id = "bar", Yo.defaults = { borderSkipped: "start", borderWidth: 0, borderRadius: 0, enableBorderRadius: !0, pointStyle: void 0 }, Yo.defaultRoutes = { backgroundColor: "backgroundColor", borderColor: "borderColor" }; var Uo = Object.freeze({ __proto__: null, ArcElement: So, LineElement: Eo, PointElement: zo, BarElement: Yo }); function Xo(t) { if (t._decimated) { const e = t._data; delete t._decimated, delete t._data, Object.defineProperty(t, "data", { value: e }) } } function qo(t) { t.data.datasets.forEach((t => { Xo(t) })) } var Ko = { id: "decimation", defaults: { algorithm: "min-max", enabled: !1 }, beforeElementsUpdate: (t, e, i) => { if (!i.enabled) return void qo(t); const n = t.width; t.data.datasets.forEach(((e, o) => { const { _data: s, indexAxis: a } = e, r = t.getDatasetMeta(o), l = s || e.data; if ("y" === Ve([a, t.options.indexAxis])) return; if ("line" !== r.type) return; const c = t.scales[r.xAxisID]; if ("linear" !== c.type && "time" !== c.type) return; if (t.options.parsing) return; let h, { start: d, count: u } = function (t, e) { const i = e.length; let n, o = 0; const { iScale: s } = t, { min: a, max: r, minDefined: l, maxDefined: c } = s.getUserBounds(); return l && (o = Nt(oe(e, s.axis, a).lo, 0, i - 1)), n = c ? Nt(oe(e, s.axis, r).hi + 1, o, i) - o : i - o, { start: o, count: n } }(r, l); if (u <= 4 * n) Xo(e); else { switch ($(s) && (e._data = l, delete e.data, Object.defineProperty(e, "data", { configurable: !0, enumerable: !0, get: function () { return this._decimated }, set: function (t) { this._data = t } })), i.algorithm) { case "lttb": h = function (t, e, i, n, o) { const s = o.samples || n; if (s >= i) return t.slice(e, e + i); const a = [], r = (i - 2) / (s - 2); let l = 0; const c = e + i - 1; let h, d, u, f, g, p = e; for (a[l++] = t[p], h = 0; h < s - 2; h++) { let n, o = 0, s = 0; const c = Math.floor((h + 1) * r) + 1 + e, m = Math.min(Math.floor((h + 2) * r) + 1, i) + e, x = m - c; for (n = c; n < m; n++)o += t[n].x, s += t[n].y; o /= x, s /= x; const b = Math.floor(h * r) + 1 + e, _ = Math.floor((h + 1) * r) + 1 + e, { x: y, y: v } = t[p]; for (u = f = -1, n = b; n < _; n++)f = .5 * Math.abs((y - o) * (t[n].y - v) - (y - t[n].x) * (s - v)), f > u && (u = f, d = t[n], g = n); a[l++] = d, p = g } return a[l++] = t[c], a }(l, d, u, n, i); break; case "min-max": h = function (t, e, i, n) { let o, s, a, r, l, c, h, d, u, f, g = 0, p = 0; const m = [], x = e + i - 1, b = t[e].x, _ = t[x].x - b; for (o = e; o < e + i; ++o) { s = t[o], a = (s.x - b) / _ * n, r = s.y; const e = 0 | a; if (e === l) r < u ? (u = r, c = o) : r > f && (f = r, h = o), g = (p * g + s.x) / ++p; else { const i = o - 1; if (!$(c) && !$(h)) { const e = Math.min(c, h), n = Math.max(c, h); e !== d && e !== i && m.push({ ...t[e], x: g }), n !== d && n !== i && m.push({ ...t[n], x: g }) } o > 0 && i !== d && m.push(t[i]), m.push(s), l = e, p = 0, u = f = r, c = h = d = o } } return m }(l, d, u, n); break; default: throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`) }e._decimated = h } })) }, destroy(t) { qo(t) } }; function Go(t, e, i) { const n = function (t) { const e = t.options, i = e.fill; let n = K(i && i.target, i); return void 0 === n && (n = !!e.backgroundColor), !1 !== n && null !== n && (!0 === n ? "origin" : n) }(t); if (U(n)) return !isNaN(n.value) && n; let o = parseFloat(n); return X(o) && Math.floor(o) === o ? ("-" !== n[0] && "+" !== n[0] || (o = e + o), !(o === e || o < 0 || o >= i) && o) : ["origin", "start", "end", "stack"].indexOf(n) >= 0 && n } class Zo { constructor(t) { this.x = t.x, this.y = t.y, this.radius = t.radius } pathSegment(t, e, i) { const { x: n, y: o, radius: s } = this; return e = e || { start: 0, end: _t }, t.arc(n, o, s, e.end, e.start, !0), !i.bounds } interpolate(t) { const { x: e, y: i, radius: n } = this, o = t.angle; return { x: e + Math.cos(o) * n, y: i + Math.sin(o) * n, angle: o } } } function Qo(t) { return (t.scale || {}).getPointPositionForValue ? function (t) { const { scale: e, fill: i } = t, n = e.options, o = e.getLabels().length, s = [], a = n.reverse ? e.max : e.min, r = n.reverse ? e.min : e.max; let l, c, h; if (h = "start" === i ? a : "end" === i ? r : U(i) ? i.value : e.getBaseValue(), n.grid.circular) return c = e.getPointPositionForValue(0, a), new Zo({ x: c.x, y: c.y, radius: e.getDistanceFromCenterForValue(h) }); for (l = 0; l < o; ++l)s.push(e.getPointPositionForValue(l, h)); return s }(t) : function (t) { const { scale: e = {}, fill: i } = t; let n, o = null; return "start" === i ? o = e.bottom : "end" === i ? o = e.top : U(i) ? o = e.getPixelForValue(i.value) : e.getBasePixel && (o = e.getBasePixel()), X(o) ? (n = e.isHorizontal(), { x: n ? o : null, y: n ? null : o }) : null }(t) } function Jo(t) { const { chart: e, scale: i, index: n, line: o } = t, s = [], a = o.segments, r = o.points, l = function (t, e) { const i = [], n = t.getSortedVisibleDatasetMetas(); for (let t = 0; t < n.length; t++) { const o = n[t]; if (o.index === e) break; ts(o) && i.unshift(o.dataset) } return i }(e, n); l.push(ns({ x: null, y: i.bottom }, o)); for (let t = 0; t < a.length; t++) { const e = a[t]; for (let t = e.start; t <= e.end; t++)es(s, r[t], l) } return new Eo({ points: s, options: {} }) } const ts = t => "line" === t.type && !t.hidden; function es(t, e, i) { const n = []; for (let o = 0; o < i.length; o++) { const s = i[o], { first: a, last: r, point: l } = is(s, e, "x"); if (!(!l || a && r)) if (a) n.unshift(l); else if (t.push(l), !r) break } t.push(...n) } function is(t, e, i) { const n = t.interpolate(e, i); if (!n) return {}; const o = n[i], s = t.segments, a = t.points; let r = !1, l = !1; for (let t = 0; t < s.length; t++) { const e = s[t], n = a[e.start][i], c = a[e.end][i]; if (o >= n && o <= c) { r = o === n, l = o === c; break } } return { first: r, last: l, point: n } } function ns(t, e) { let i = [], n = !1; return Y(t) ? (n = !0, i = t) : i = function (t, e) { const { x: i = null, y: n = null } = t || {}, o = e.points, s = []; return e.segments.forEach((t => { const e = o[t.start], a = o[t.end]; null !== n ? (s.push({ x: e.x, y: n }), s.push({ x: a.x, y: n })) : null !== i && (s.push({ x: i, y: e.y }), s.push({ x: i, y: a.y })) })), s }(t, e), i.length ? new Eo({ points: i, options: { tension: 0 }, _loop: n, _fullLoop: n }) : null } function os(t, e, i) { let n = t[e].fill; const o = [e]; let s; if (!i) return n; for (; !1 !== n && -1 === o.indexOf(n);) { if (!X(n)) return n; if (s = t[n], !s) return !1; if (s.visible) return n; o.push(n), n = s.fill } return !1 } function ss(t, e, i) { t.beginPath(), e.path(t), t.lineTo(e.last().x, i), t.lineTo(e.first().x, i), t.closePath(), t.clip() } function as(t, e, i, n) { if (n) return; let o = e[t], s = i[t]; return "angle" === t && (o = Wt(o), s = Wt(s)), { property: t, start: o, end: s } } function rs(t, e, i, n) { return t && e ? n(t[i], e[i]) : t ? t[i] : e ? e[i] : 0 } function ls(t, e, i) { const { top: n, bottom: o } = e.chart.chartArea, { property: s, start: a, end: r } = i || {}; "x" === s && (t.beginPath(), t.rect(a, n, r - a, o - n), t.clip()) } function cs(t, e, i, n) { const o = e.interpolate(i, n); o && t.lineTo(o.x, o.y) } function hs(t, e) { const { line: i, target: n, property: o, color: s, scale: a } = e, r = function (t, e, i) { const n = t.segments, o = t.points, s = e.points, a = []; for (const t of n) { const n = as(i, o[t.start], o[t.end], t.loop); if (!e.segments) { a.push({ source: t, target: n, start: o[t.start], end: o[t.end] }); continue } const r = kn(e, n); for (const e of r) { const r = as(i, s[e.start], s[e.end], e.loop), l = Mn(t, o, r); for (const t of l) a.push({ source: t, target: e, start: { [i]: rs(n, r, "start", Math.max) }, end: { [i]: rs(n, r, "end", Math.min) } }) } } return a }(i, n, o); for (const { source: e, target: l, start: c, end: h } of r) { const { style: { backgroundColor: r = s } = {} } = e; t.save(), t.fillStyle = r, ls(t, a, as(o, c, h)), t.beginPath(); const d = !!i.pathSegment(t, e); d ? t.closePath() : cs(t, n, h, o); const u = !!n.pathSegment(t, l, { move: d, reverse: !0 }), f = d && u; f || cs(t, n, c, o), t.closePath(), t.fill(f ? "evenodd" : "nonzero"), t.restore() } } function ds(t, e, i) { const n = function (t) { const { chart: e, fill: i, line: n } = t; if (X(i)) return function (t, e) { const i = t.getDatasetMeta(e); return i && t.isDatasetVisible(e) ? i.dataset : null }(e, i); if ("stack" === i) return Jo(t); const o = Qo(t); return o instanceof Zo ? o : ns(o, n) }(e), { line: o, scale: s, axis: a } = e, r = o.options, l = r.fill, c = r.backgroundColor, { above: h = c, below: d = c } = l || {}; n && o.points.length && (Zt(t, i), function (t, e) { const { line: i, target: n, above: o, below: s, area: a, scale: r } = e, l = i._loop ? "angle" : e.axis; t.save(), "x" === l && s !== o && (ss(t, n, a.top), hs(t, { line: i, target: n, color: o, scale: r, property: l }), t.restore(), t.save(), ss(t, n, a.bottom)), hs(t, { line: i, target: n, color: s, scale: r, property: l }), t.restore() }(t, { line: o, target: n, above: h, below: d, area: i, scale: s, axis: a }), Qt(t)) } var us = { id: "filler", afterDatasetsUpdate(t, e, i) { const n = (t.data.datasets || []).length, o = []; let s, a, r, l; for (a = 0; a < n; ++a)s = t.getDatasetMeta(a), r = s.dataset, l = null, r && r.options && r instanceof Eo && (l = { visible: t.isDatasetVisible(a), index: a, fill: Go(r, a, n), chart: t, axis: s.controller.options.indexAxis, scale: s.vScale, line: r }), s.$filler = l, o.push(l); for (a = 0; a < n; ++a)l = o[a], l && !1 !== l.fill && (l.fill = os(o, a, i.propagate)) }, beforeDraw(t, e, i) { const n = "beforeDraw" === i.drawTime, o = t.getSortedVisibleDatasetMetas(), s = t.chartArea; for (let e = o.length - 1; e >= 0; --e) { const i = o[e].$filler; i && (i.line.updateControlPoints(s, i.axis), n && ds(t.ctx, i, s)) } }, beforeDatasetsDraw(t, e, i) { if ("beforeDatasetsDraw" !== i.drawTime) return; const n = t.getSortedVisibleDatasetMetas(); for (let e = n.length - 1; e >= 0; --e) { const i = n[e].$filler; i && ds(t.ctx, i, t.chartArea) } }, beforeDatasetDraw(t, e, i) { const n = e.meta.$filler; n && !1 !== n.fill && "beforeDatasetDraw" === i.drawTime && ds(t.ctx, n, t.chartArea) }, defaults: { propagate: !0, drawTime: "beforeDatasetDraw" } }; const fs = (t, e) => { let { boxHeight: i = e, boxWidth: n = e } = t; return t.usePointStyle && (i = Math.min(i, e), n = Math.min(n, e)), { boxWidth: n, boxHeight: i, itemHeight: Math.max(e, i) } }; class gs extends Ei { constructor(t) { super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(t, e, i) { const n = this; n.maxWidth = t, n.maxHeight = e, n._margins = i, n.setDimensions(), n.buildLabels(), n.fit() } setDimensions() { const t = this; t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height) } buildLabels() { const t = this, e = t.options.labels || {}; let i = Q(e.generateLabels, [t.chart], t) || []; e.filter && (i = i.filter((i => e.filter(i, t.chart.data)))), e.sort && (i = i.sort(((i, n) => e.sort(i, n, t.chart.data)))), t.options.reverse && i.reverse(), t.legendItems = i } fit() { const t = this, { options: e, ctx: i } = t; if (!e.display) return void (t.width = t.height = 0); const n = e.labels, o = Fe(n.font), s = o.size, a = t._computeTitleHeight(), { boxWidth: r, itemHeight: l } = fs(n, s); let c, h; i.font = o.string, t.isHorizontal() ? (c = t.maxWidth, h = t._fitRows(a, s, r, l) + 10) : (h = t.maxHeight, c = t._fitCols(a, s, r, l) + 10), t.width = Math.min(c, e.maxWidth || t.maxWidth), t.height = Math.min(h, e.maxHeight || t.maxHeight) } _fitRows(t, e, i, n) { const o = this, { ctx: s, maxWidth: a, options: { labels: { padding: r } } } = o, l = o.legendHitBoxes = [], c = o.lineWidths = [0], h = n + r; let d = t; s.textAlign = "left", s.textBaseline = "middle"; let u = -1, f = -h; return o.legendItems.forEach(((t, o) => { const g = i + e / 2 + s.measureText(t.text).width; (0 === o || c[c.length - 1] + g + 2 * r > a) && (d += h, c[c.length - (o > 0 ? 0 : 1)] = 0, f += h, u++), l[o] = { left: 0, top: f, row: u, width: g, height: n }, c[c.length - 1] += g + r })), d } _fitCols(t, e, i, n) { const o = this, { ctx: s, maxHeight: a, options: { labels: { padding: r } } } = o, l = o.legendHitBoxes = [], c = o.columnSizes = [], h = a - t; let d = r, u = 0, f = 0, g = 0, p = 0, m = 0; return o.legendItems.forEach(((t, o) => { const a = i + e / 2 + s.measureText(t.text).width; o > 0 && f + e + 2 * r > h && (d += u + r, c.push({ width: u, height: f }), g += u + r, m++, p = 0, u = f = 0), u = Math.max(u, a), f += e + r, l[o] = { left: g, top: p, col: m, width: a, height: n }, p += n + r })), d += u, c.push({ width: u, height: f }), d } adjustHitBoxes() { const t = this; if (!t.options.display) return; const e = t._computeTitleHeight(), { legendHitBoxes: i, options: { align: n, labels: { padding: s } } } = t; if (this.isHorizontal()) { let a = 0, r = o(n, t.left + s, t.right - t.lineWidths[a]); for (const l of i) a !== l.row && (a = l.row, r = o(n, t.left + s, t.right - t.lineWidths[a])), l.top += t.top + e + s, l.left = r, r += l.width + s } else { let a = 0, r = o(n, t.top + e + s, t.bottom - t.columnSizes[a].height); for (const l of i) l.col !== a && (a = l.col, r = o(n, t.top + e + s, t.bottom - t.columnSizes[a].height)), l.top = r, l.left += t.left + s, r += l.height + s } } isHorizontal() { return "top" === this.options.position || "bottom" === this.options.position } draw() { const t = this; if (t.options.display) { const e = t.ctx; Zt(e, t), t._draw(), Qt(e) } } _draw() { const t = this, { options: e, columnSizes: i, lineWidths: n, ctx: a } = t, { align: r, labels: l } = e, c = xt.color, h = bn(e.rtl, t.left, t.width), d = Fe(l.font), { color: u, padding: f } = l, g = d.size, p = g / 2; let m; t.drawTitle(), a.textAlign = h.textAlign("left"), a.textBaseline = "middle", a.lineWidth = .5, a.font = d.string; const { boxWidth: x, boxHeight: b, itemHeight: _ } = fs(l, g), y = t.isHorizontal(), v = this._computeTitleHeight(); m = y ? { x: o(r, t.left + f, t.right - n[0]), y: t.top + f + v, line: 0 } : { x: t.left + f, y: o(r, t.top + v + f, t.bottom - i[0].height), line: 0 }, _n(t.ctx, e.textDirection); const w = _ + f; t.legendItems.forEach(((e, M) => { a.strokeStyle = e.fontColor || u, a.fillStyle = e.fontColor || u; const k = a.measureText(e.text).width, S = h.textAlign(e.textAlign || (e.textAlign = l.textAlign)), P = x + g / 2 + k; let D = m.x, C = m.y; h.setWidth(t.width), y ? M > 0 && D + P + f > t.right && (C = m.y += w, m.line++, D = m.x = o(r, t.left + f, t.right - n[m.line])) : M > 0 && C + w > t.bottom && (D = m.x = D + i[m.line].width + f, m.line++, C = m.y = o(r, t.top + v + f, t.bottom - i[m.line].height)); !function (t, e, i) { if (isNaN(x) || x <= 0 || isNaN(b) || b < 0) return; a.save(); const n = K(i.lineWidth, 1); if (a.fillStyle = K(i.fillStyle, c), a.lineCap = K(i.lineCap, "butt"), a.lineDashOffset = K(i.lineDashOffset, 0), a.lineJoin = K(i.lineJoin, "miter"), a.lineWidth = n, a.strokeStyle = K(i.strokeStyle, c), a.setLineDash(K(i.lineDash, [])), l.usePointStyle) { const o = { radius: x * Math.SQRT2 / 2, pointStyle: i.pointStyle, rotation: i.rotation, borderWidth: n }, s = h.xPlus(t, x / 2); Kt(a, o, s, e + p) } else { const o = e + Math.max((g - b) / 2, 0), s = h.leftForLtr(t, x), r = Ie(i.borderRadius); a.beginPath(), Object.values(r).some((t => 0 !== t)) ? ie(a, { x: s, y: o, w: x, h: b, radius: r }) : a.rect(s, o, x, b), a.fill(), 0 !== n && a.stroke() } a.restore() }(h.x(D), C, e), D = s(S, D + x + p, t.right), function (t, e, i) { ee(a, i.text, t, e + _ / 2, d, { strikethrough: i.hidden, textAlign: i.textAlign }) }(h.x(D), C, e), y ? m.x += P + f : m.y += w })), yn(t.ctx, e.textDirection) } drawTitle() { const t = this, e = t.options, i = e.title, s = Fe(i.font), a = ze(i.padding); if (!i.display) return; const r = bn(e.rtl, t.left, t.width), l = t.ctx, c = i.position, h = s.size / 2, d = a.top + h; let u, f = t.left, g = t.width; if (this.isHorizontal()) g = Math.max(...t.lineWidths), u = t.top + d, f = o(e.align, f, t.right - g); else { const i = t.columnSizes.reduce(((t, e) => Math.max(t, e.height)), 0); u = d + o(e.align, t.top, t.bottom - i - e.labels.padding - t._computeTitleHeight()) } const p = o(c, f, f + g); l.textAlign = r.textAlign(n(c)), l.textBaseline = "middle", l.strokeStyle = i.color, l.fillStyle = i.color, l.font = s.string, ee(l, i.text, p, u, s) } _computeTitleHeight() { const t = this.options.title, e = Fe(t.font), i = ze(t.padding); return t.display ? e.lineHeight + i.height : 0 } _getLegendItemAt(t, e) { const i = this; let n, o, s; if (t >= i.left && t <= i.right && e >= i.top && e <= i.bottom) for (s = i.legendHitBoxes, n = 0; n < s.length; ++n)if (o = s[n], t >= o.left && t <= o.left + o.width && e >= o.top && e <= o.top + o.height) return i.legendItems[n]; return null } handleEvent(t) { const e = this, i = e.options; if (!function (t, e) { if ("mousemove" === t && (e.onHover || e.onLeave)) return !0; if (e.onClick && ("click" === t || "mouseup" === t)) return !0; return !1 }(t.type, i)) return; const n = e._getLegendItemAt(t.x, t.y); if ("mousemove" === t.type) { const a = e._hoveredItem, r = (s = n, null !== (o = a) && null !== s && o.datasetIndex === s.datasetIndex && o.index === s.index); a && !r && Q(i.onLeave, [t, a, e], e), e._hoveredItem = n, n && !r && Q(i.onHover, [t, n, e], e) } else n && Q(i.onClick, [t, n, e], e); var o, s } } var ps = { id: "legend", _element: gs, start(t, e, i) { const n = t.legend = new gs({ ctx: t.ctx, options: i, chart: t }); Ge.configure(t, n, i), Ge.addBox(t, n) }, stop(t) { Ge.removeBox(t, t.legend), delete t.legend }, beforeUpdate(t, e, i) { const n = t.legend; Ge.configure(t, n, i), n.options = i }, afterUpdate(t) { const e = t.legend; e.buildLabels(), e.adjustHitBoxes() }, afterEvent(t, e) { e.replay || t.legend.handleEvent(e.event) }, defaults: { display: !0, position: "top", align: "center", fullSize: !0, reverse: !1, weight: 1e3, onClick(t, e, i) { const n = e.datasetIndex, o = i.chart; o.isDatasetVisible(n) ? (o.hide(n), e.hidden = !0) : (o.show(n), e.hidden = !1) }, onHover: null, onLeave: null, labels: { color: t => t.chart.options.color, boxWidth: 40, padding: 10, generateLabels(t) { const e = t.data.datasets, { labels: { usePointStyle: i, pointStyle: n, textAlign: o, color: s } } = t.legend.options; return t._getSortedDatasetMetas().map((t => { const a = t.controller.getStyle(i ? 0 : void 0), r = ze(a.borderWidth); return { text: e[t.index].label, fillStyle: a.backgroundColor, fontColor: s, hidden: !t.visible, lineCap: a.borderCapStyle, lineDash: a.borderDash, lineDashOffset: a.borderDashOffset, lineJoin: a.borderJoinStyle, lineWidth: (r.width + r.height) / 4, strokeStyle: a.borderColor, pointStyle: n || a.pointStyle, rotation: a.rotation, textAlign: o || a.textAlign, borderRadius: 0, datasetIndex: t.index } }), this) } }, title: { color: t => t.chart.options.color, display: !1, position: "center", text: "" } }, descriptors: { _scriptable: t => !t.startsWith("on"), labels: { _scriptable: t => !["generateLabels", "filter", "sort"].includes(t) } } }; class ms extends Ei { constructor(t) { super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0 } update(t, e) { const i = this, n = i.options; if (i.left = 0, i.top = 0, !n.display) return void (i.width = i.height = i.right = i.bottom = 0); i.width = i.right = t, i.height = i.bottom = e; const o = Y(n.text) ? n.text.length : 1; i._padding = ze(n.padding); const s = o * Fe(n.font).lineHeight + i._padding.height; i.isHorizontal() ? i.height = s : i.width = s } isHorizontal() { const t = this.options.position; return "top" === t || "bottom" === t } _drawArgs(t) { const { top: e, left: i, bottom: n, right: s, options: a } = this, r = a.align; let l, c, h, d = 0; return this.isHorizontal() ? (c = o(r, i, s), h = e + t, l = s - i) : ("left" === a.position ? (c = i + t, h = o(r, n, e), d = -.5 * bt) : (c = s - t, h = o(r, e, n), d = .5 * bt), l = n - e), { titleX: c, titleY: h, maxWidth: l, rotation: d } } draw() { const t = this, e = t.ctx, i = t.options; if (!i.display) return; const o = Fe(i.font), s = o.lineHeight / 2 + t._padding.top, { titleX: a, titleY: r, maxWidth: l, rotation: c } = t._drawArgs(s); ee(e, i.text, 0, 0, o, { color: i.color, maxWidth: l, rotation: c, textAlign: n(i.align), textBaseline: "middle", translation: [a, r] }) } } var xs = { id: "title", _element: ms, start(t, e, i) { !function (t, e) { const i = new ms({ ctx: t.ctx, options: e, chart: t }); Ge.configure(t, i, e), Ge.addBox(t, i), t.titleBlock = i }(t, i) }, stop(t) { const e = t.titleBlock; Ge.removeBox(t, e), delete t.titleBlock }, beforeUpdate(t, e, i) { const n = t.titleBlock; Ge.configure(t, n, i), n.options = i }, defaults: { align: "center", display: !1, font: { weight: "bold" }, fullSize: !0, padding: 10, position: "top", text: "", weight: 2e3 }, defaultRoutes: { color: "color" }, descriptors: { _scriptable: !0, _indexable: !1 } }; const bs = { average(t) { if (!t.length) return !1; let e, i, n = 0, o = 0, s = 0; for (e = 0, i = t.length; e < i; ++e) { const i = t[e].element; if (i && i.hasValue()) { const t = i.tooltipPosition(); n += t.x, o += t.y, ++s } } return { x: n / s, y: o / s } }, nearest(t, e) { if (!t.length) return !1; let i, n, o, s = e.x, a = e.y, r = Number.POSITIVE_INFINITY; for (i = 0, n = t.length; i < n; ++i) { const n = t[i].element; if (n && n.hasValue()) { const t = Vt(e, n.getCenterPoint()); t < r && (r = t, o = n) } } if (o) { const t = o.tooltipPosition(); s = t.x, a = t.y } return { x: s, y: a } } }; function _s(t, e) { return e && (Y(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t } function ys(t) { return ("string" == typeof t || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t } function vs(t, e) { const { element: i, datasetIndex: n, index: o } = e, s = t.getDatasetMeta(n).controller, { label: a, value: r } = s.getLabelAndValue(o); return { chart: t, label: a, parsed: s.getParsed(o), raw: t.data.datasets[n].data[o], formattedValue: r, dataset: s.getDataset(), dataIndex: o, datasetIndex: n, element: i } } function ws(t, e) { const i = t._chart.ctx, { body: n, footer: o, title: s } = t, { boxWidth: a, boxHeight: r } = e, l = Fe(e.bodyFont), c = Fe(e.titleFont), h = Fe(e.footerFont), d = s.length, u = o.length, f = n.length, g = ze(e.padding); let p = g.height, m = 0, x = n.reduce(((t, e) => t + e.before.length + e.lines.length + e.after.length), 0); if (x += t.beforeBody.length + t.afterBody.length, d && (p += d * c.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), x) { p += f * (e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (x - f) * l.lineHeight + (x - 1) * e.bodySpacing } u && (p += e.footerMarginTop + u * h.lineHeight + (u - 1) * e.footerSpacing); let b = 0; const _ = function (t) { m = Math.max(m, i.measureText(t).width + b) }; return i.save(), i.font = c.string, J(t.title, _), i.font = l.string, J(t.beforeBody.concat(t.afterBody), _), b = e.displayColors ? a + 2 : 0, J(n, (t => { J(t.before, _), J(t.lines, _), J(t.after, _) })), b = 0, i.font = h.string, J(t.footer, _), i.restore(), m += g.width, { width: m, height: p } } function Ms(t, e, i, n) { const { x: o, width: s } = i, { width: a, chartArea: { left: r, right: l } } = t; let c = "center"; return "center" === n ? c = o <= (r + l) / 2 ? "left" : "right" : o <= s / 2 ? c = "left" : o >= a - s / 2 && (c = "right"), function (t, e, i, n) { const { x: o, width: s } = n, a = i.caretSize + i.caretPadding; return "left" === t && o + s + a > e.width || "right" === t && o - s - a < 0 || void 0 }(c, t, e, i) && (c = "center"), c } function ks(t, e, i) { const n = e.yAlign || function (t, e) { const { y: i, height: n } = e; return i < n / 2 ? "top" : i > t.height - n / 2 ? "bottom" : "center" }(t, i); return { xAlign: e.xAlign || Ms(t, e, i, n), yAlign: n } } function Ss(t, e, i, n) { const { caretSize: o, caretPadding: s, cornerRadius: a } = t, { xAlign: r, yAlign: l } = i, c = o + s, h = a + s; let d = function (t, e) { let { x: i, width: n } = t; return "right" === e ? i -= n : "center" === e && (i -= n / 2), i }(e, r); const u = function (t, e, i) { let { y: n, height: o } = t; return "top" === e ? n += i : n -= "bottom" === e ? o + i : o / 2, n }(e, l, c); return "center" === l ? "left" === r ? d += c : "right" === r && (d -= c) : "left" === r ? d -= h : "right" === r && (d += h), { x: Nt(d, 0, n.width - e.width), y: Nt(u, 0, n.height - e.height) } } function Ps(t, e, i) { const n = ze(i.padding); return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - n.right : t.x + n.left } function Ds(t) { return _s([], ys(t)) } function Cs(t, e) { const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks; return i ? t.override(i) : t } class Os extends Ei { constructor(t) { super(), this.opacity = 0, this._active = [], this._chart = t._chart, this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0 } initialize(t) { this.options = t, this._cachedAnimations = void 0, this.$context = void 0 } _resolveAnimations() { const t = this, e = t._cachedAnimations; if (e) return e; const i = t._chart, n = t.options.setContext(t.getContext()), o = n.enabled && i.options.animation && n.animations, s = new vi(t._chart, o); return o._cacheable && (t._cachedAnimations = Object.freeze(s)), s } getContext() { const t = this; return t.$context || (t.$context = (e = t._chart.getContext(), i = t, n = t._tooltipItems, Object.assign(Object.create(e), { tooltip: i, tooltipItems: n, type: "tooltip" }))); var e, i, n } getTitle(t, e) { const i = this, { callbacks: n } = e, o = n.beforeTitle.apply(i, [t]), s = n.title.apply(i, [t]), a = n.afterTitle.apply(i, [t]); let r = []; return r = _s(r, ys(o)), r = _s(r, ys(s)), r = _s(r, ys(a)), r } getBeforeBody(t, e) { return Ds(e.callbacks.beforeBody.apply(this, [t])) } getBody(t, e) { const i = this, { callbacks: n } = e, o = []; return J(t, (t => { const e = { before: [], lines: [], after: [] }, s = Cs(n, t); _s(e.before, ys(s.beforeLabel.call(i, t))), _s(e.lines, s.label.call(i, t)), _s(e.after, ys(s.afterLabel.call(i, t))), o.push(e) })), o } getAfterBody(t, e) { return Ds(e.callbacks.afterBody.apply(this, [t])) } getFooter(t, e) { const i = this, { callbacks: n } = e, o = n.beforeFooter.apply(i, [t]), s = n.footer.apply(i, [t]), a = n.afterFooter.apply(i, [t]); let r = []; return r = _s(r, ys(o)), r = _s(r, ys(s)), r = _s(r, ys(a)), r } _createItems(t) { const e = this, i = e._active, n = e._chart.data, o = [], s = [], a = []; let r, l, c = []; for (r = 0, l = i.length; r < l; ++r)c.push(vs(e._chart, i[r])); return t.filter && (c = c.filter(((e, i, o) => t.filter(e, i, o, n)))), t.itemSort && (c = c.sort(((e, i) => t.itemSort(e, i, n)))), J(c, (i => { const n = Cs(t.callbacks, i); o.push(n.labelColor.call(e, i)), s.push(n.labelPointStyle.call(e, i)), a.push(n.labelTextColor.call(e, i)) })), e.labelColors = o, e.labelPointStyles = s, e.labelTextColors = a, e.dataPoints = c, c } update(t, e) { const i = this, n = i.options.setContext(i.getContext()), o = i._active; let s, a = []; if (o.length) { const t = bs[n.position].call(i, o, i._eventPosition); a = i._createItems(n), i.title = i.getTitle(a, n), i.beforeBody = i.getBeforeBody(a, n), i.body = i.getBody(a, n), i.afterBody = i.getAfterBody(a, n), i.footer = i.getFooter(a, n); const e = i._size = ws(i, n), r = Object.assign({}, t, e), l = ks(i._chart, n, r), c = Ss(n, r, l, i._chart); i.xAlign = l.xAlign, i.yAlign = l.yAlign, s = { opacity: 1, x: c.x, y: c.y, width: e.width, height: e.height, caretX: t.x, caretY: t.y } } else 0 !== i.opacity && (s = { opacity: 0 }); i._tooltipItems = a, i.$context = void 0, s && i._resolveAnimations().update(i, s), t && n.external && n.external.call(i, { chart: i._chart, tooltip: i, replay: e }) } drawCaret(t, e, i, n) { const o = this.getCaretPosition(t, i, n); e.lineTo(o.x1, o.y1), e.lineTo(o.x2, o.y2), e.lineTo(o.x3, o.y3) } getCaretPosition(t, e, i) { const { xAlign: n, yAlign: o } = this, { cornerRadius: s, caretSize: a } = i, { x: r, y: l } = t, { width: c, height: h } = e; let d, u, f, g, p, m; return "center" === o ? (p = l + h / 2, "left" === n ? (d = r, u = d - a, g = p + a, m = p - a) : (d = r + c, u = d + a, g = p - a, m = p + a), f = d) : (u = "left" === n ? r + s + a : "right" === n ? r + c - s - a : this.caretX, "top" === o ? (g = l, p = g - a, d = u - a, f = u + a) : (g = l + h, p = g + a, d = u + a, f = u - a), m = g), { x1: d, x2: u, x3: f, y1: g, y2: p, y3: m } } drawTitle(t, e, i) { const n = this, o = n.title, s = o.length; let a, r, l; if (s) { const c = bn(i.rtl, n.x, n.width); for (t.x = Ps(n, i.titleAlign, i), e.textAlign = c.textAlign(i.titleAlign), e.textBaseline = "middle", a = Fe(i.titleFont), r = i.titleSpacing, e.fillStyle = i.titleColor, e.font = a.string, l = 0; l < s; ++l)e.fillText(o[l], c.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + r, l + 1 === s && (t.y += i.titleMarginBottom - r) } } _drawColorBox(t, e, i, n, o) { const s = this, a = s.labelColors[i], r = s.labelPointStyles[i], { boxHeight: l, boxWidth: c } = o, h = Fe(o.bodyFont), d = Ps(s, "left", o), u = n.x(d), f = l < h.lineHeight ? (h.lineHeight - l) / 2 : 0, g = e.y + f; if (o.usePointStyle) { const e = { radius: Math.min(c, l) / 2, pointStyle: r.pointStyle, rotation: r.rotation, borderWidth: 1 }, i = n.leftForLtr(u, c) + c / 2, s = g + l / 2; t.strokeStyle = o.multiKeyBackground, t.fillStyle = o.multiKeyBackground, Kt(t, e, i, s), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Kt(t, e, i, s) } else { t.lineWidth = a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0; const e = n.leftForLtr(u, c), i = n.leftForLtr(n.xPlus(u, 1), c - 2), s = Ie(a.borderRadius); Object.values(s).some((t => 0 !== t)) ? (t.beginPath(), t.fillStyle = o.multiKeyBackground, ie(t, { x: e, y: g, w: c, h: l, radius: s }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), ie(t, { x: i, y: g + 1, w: c - 2, h: l - 2, radius: s }), t.fill()) : (t.fillStyle = o.multiKeyBackground, t.fillRect(e, g, c, l), t.strokeRect(e, g, c, l), t.fillStyle = a.backgroundColor, t.fillRect(i, g + 1, c - 2, l - 2)) } t.fillStyle = s.labelTextColors[i] } drawBody(t, e, i) { const n = this, { body: o } = n, { bodySpacing: s, bodyAlign: a, displayColors: r, boxHeight: l, boxWidth: c } = i, h = Fe(i.bodyFont); let d = h.lineHeight, u = 0; const f = bn(i.rtl, n.x, n.width), g = function (i) { e.fillText(i, f.x(t.x + u), t.y + d / 2), t.y += d + s }, p = f.textAlign(a); let m, x, b, _, y, v, w; for (e.textAlign = a, e.textBaseline = "middle", e.font = h.string, t.x = Ps(n, p, i), e.fillStyle = i.bodyColor, J(n.beforeBody, g), u = r && "right" !== p ? "center" === a ? c / 2 + 1 : c + 2 : 0, _ = 0, v = o.length; _ < v; ++_) { for (m = o[_], x = n.labelTextColors[_], e.fillStyle = x, J(m.before, g), b = m.lines, r && b.length && (n._drawColorBox(e, t, _, f, i), d = Math.max(h.lineHeight, l)), y = 0, w = b.length; y < w; ++y)g(b[y]), d = h.lineHeight; J(m.after, g) } u = 0, d = h.lineHeight, J(n.afterBody, g), t.y -= s } drawFooter(t, e, i) { const n = this, o = n.footer, s = o.length; let a, r; if (s) { const l = bn(i.rtl, n.x, n.width); for (t.x = Ps(n, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = l.textAlign(i.footerAlign), e.textBaseline = "middle", a = Fe(i.footerFont), e.fillStyle = i.footerColor, e.font = a.string, r = 0; r < s; ++r)e.fillText(o[r], l.x(t.x), t.y + a.lineHeight / 2), t.y += a.lineHeight + i.footerSpacing } } drawBackground(t, e, i, n) { const { xAlign: o, yAlign: s } = this, { x: a, y: r } = t, { width: l, height: c } = i, h = n.cornerRadius; e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, e.lineWidth = n.borderWidth, e.beginPath(), e.moveTo(a + h, r), "top" === s && this.drawCaret(t, e, i, n), e.lineTo(a + l - h, r), e.quadraticCurveTo(a + l, r, a + l, r + h), "center" === s && "right" === o && this.drawCaret(t, e, i, n), e.lineTo(a + l, r + c - h), e.quadraticCurveTo(a + l, r + c, a + l - h, r + c), "bottom" === s && this.drawCaret(t, e, i, n), e.lineTo(a + h, r + c), e.quadraticCurveTo(a, r + c, a, r + c - h), "center" === s && "left" === o && this.drawCaret(t, e, i, n), e.lineTo(a, r + h), e.quadraticCurveTo(a, r, a + h, r), e.closePath(), e.fill(), n.borderWidth > 0 && e.stroke() } _updateAnimationTarget(t) { const e = this, i = e._chart, n = e.$animations, o = n && n.x, s = n && n.y; if (o || s) { const n = bs[t.position].call(e, e._active, e._eventPosition); if (!n) return; const a = e._size = ws(e, t), r = Object.assign({}, n, e._size), l = ks(i, t, r), c = Ss(t, r, l, i); o._to === c.x && s._to === c.y || (e.xAlign = l.xAlign, e.yAlign = l.yAlign, e.width = a.width, e.height = a.height, e.caretX = n.x, e.caretY = n.y, e._resolveAnimations().update(e, c)) } } draw(t) { const e = this, i = e.options.setContext(e.getContext()); let n = e.opacity; if (!n) return; e._updateAnimationTarget(i); const o = { width: e.width, height: e.height }, s = { x: e.x, y: e.y }; n = Math.abs(n) < .001 ? 0 : n; const a = ze(i.padding), r = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length; i.enabled && r && (t.save(), t.globalAlpha = n, e.drawBackground(s, t, o, i), _n(t, i.textDirection), s.y += a.top, e.drawTitle(s, t, i), e.drawBody(s, t, i), e.drawFooter(s, t, i), yn(t, i.textDirection), t.restore()) } getActiveElements() { return this._active || [] } setActiveElements(t, e) { const i = this, n = i._active, o = t.map((({ datasetIndex: t, index: e }) => { const n = i._chart.getDatasetMeta(t); if (!n) throw new Error("Cannot find a dataset at index " + t); return { datasetIndex: t, element: n.data[e], index: e } })), s = !tt(n, o), a = i._positionChanged(o, e); (s || a) && (i._active = o, i._eventPosition = e, i.update(!0)) } handleEvent(t, e) { const i = this, n = i.options, o = i._active || []; let s = !1, a = []; "mouseout" !== t.type && (a = i._chart.getElementsAtEventForMode(t, n.mode, n, e), n.reverse && a.reverse()); const r = i._positionChanged(a, t); return s = e || !tt(a, o) || r, s && (i._active = a, (n.enabled || n.external) && (i._eventPosition = { x: t.x, y: t.y }, i.update(!0, e))), s } _positionChanged(t, e) { const { caretX: i, caretY: n, options: o } = this, s = bs[o.position].call(this, t, e); return !1 !== s && (i !== s.x || n !== s.y) } } Os.positioners = bs; var Ts = { id: "tooltip", _element: Os, positioners: bs, afterInit(t, e, i) { i && (t.tooltip = new Os({ _chart: t, options: i })) }, beforeUpdate(t, e, i) { t.tooltip && t.tooltip.initialize(i) }, reset(t, e, i) { t.tooltip && t.tooltip.initialize(i) }, afterDraw(t) { const e = t.tooltip, i = { tooltip: e }; !1 !== t.notifyPlugins("beforeTooltipDraw", i) && (e && e.draw(t.ctx), t.notifyPlugins("afterTooltipDraw", i)) }, afterEvent(t, e) { if (t.tooltip) { const i = e.replay; t.tooltip.handleEvent(e.event, i) && (e.changed = !0) } }, defaults: { enabled: !0, external: null, position: "average", backgroundColor: "rgba(0,0,0,0.8)", titleColor: "#fff", titleFont: { weight: "bold" }, titleSpacing: 2, titleMarginBottom: 6, titleAlign: "left", bodyColor: "#fff", bodySpacing: 2, bodyFont: {}, bodyAlign: "left", footerColor: "#fff", footerSpacing: 2, footerMarginTop: 6, footerFont: { weight: "bold" }, footerAlign: "left", padding: 6, caretPadding: 2, caretSize: 5, cornerRadius: 6, boxHeight: (t, e) => e.bodyFont.size, boxWidth: (t, e) => e.bodyFont.size, multiKeyBackground: "#fff", displayColors: !0, borderColor: "rgba(0,0,0,0)", borderWidth: 0, animation: { duration: 400, easing: "easeOutQuart" }, animations: { numbers: { type: "number", properties: ["x", "y", "width", "height", "caretX", "caretY"] }, opacity: { easing: "linear", duration: 200 } }, callbacks: { beforeTitle: N, title(t) { if (t.length > 0) { const e = t[0], i = e.chart.data.labels, n = i ? i.length : 0; if (this && this.options && "dataset" === this.options.mode) return e.dataset.label || ""; if (e.label) return e.label; if (n > 0 && e.dataIndex < n) return i[e.dataIndex] } return "" }, afterTitle: N, beforeBody: N, beforeLabel: N, label(t) { if (this && this.options && "dataset" === this.options.mode) return t.label + ": " + t.formattedValue || t.formattedValue; let e = t.dataset.label || ""; e && (e += ": "); const i = t.formattedValue; return $(i) || (e += i), e }, labelColor(t) { const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { borderColor: e.borderColor, backgroundColor: e.backgroundColor, borderWidth: e.borderWidth, borderDash: e.borderDash, borderDashOffset: e.borderDashOffset, borderRadius: 0 } }, labelTextColor() { return this.options.bodyColor }, labelPointStyle(t) { const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex); return { pointStyle: e.pointStyle, rotation: e.rotation } }, afterLabel: N, afterBody: N, beforeFooter: N, footer: N, afterFooter: N } }, defaultRoutes: { bodyFont: "font", footerFont: "font", titleFont: "font" }, descriptors: { _scriptable: t => "filter" !== t && "itemSort" !== t && "external" !== t, _indexable: !1, callbacks: { _scriptable: !1, _indexable: !1 }, animation: { _fallback: !1 }, animations: { _fallback: "animation" } }, additionalOptionScopes: ["interaction"] }, As = Object.freeze({ __proto__: null, Decimation: Ko, Filler: us, Legend: ps, Title: xs, Tooltip: Ts }); function Ls(t, e, i) { const n = t.indexOf(e); if (-1 === n) return ((t, e, i) => "string" == typeof e ? t.push(e) - 1 : isNaN(e) ? null : i)(t, e, i); return n !== t.lastIndexOf(e) ? i : n } class Rs extends Xi { constructor(t) { super(t), this._startValue = void 0, this._valueRange = 0 } parse(t, e) { if ($(t)) return null; const i = this.getLabels(); return ((t, e) => null === t ? null : Nt(Math.round(t), 0, e))(e = isFinite(e) && i[e] === t ? e : Ls(i, t, K(e, t)), i.length - 1) } determineDataLimits() { const t = this, { minDefined: e, maxDefined: i } = t.getUserBounds(); let { min: n, max: o } = t.getMinMax(!0); "ticks" === t.options.bounds && (e || (n = 0), i || (o = t.getLabels().length - 1)), t.min = n, t.max = o } buildTicks() { const t = this, e = t.min, i = t.max, n = t.options.offset, o = []; let s = t.getLabels(); s = 0 === e && i === s.length - 1 ? s : s.slice(e, i + 1), t._valueRange = Math.max(s.length - (n ? 0 : 1), 1), t._startValue = t.min - (n ? .5 : 0); for (let t = e; t <= i; t++)o.push({ value: t }); return o } getLabelForValue(t) { const e = this.getLabels(); return t >= 0 && t < e.length ? e[t] : t } configure() { const t = this; super.configure(), t.isHorizontal() || (t._reversePixels = !t._reversePixels) } getPixelForValue(t) { const e = this; return "number" != typeof t && (t = e.parse(t)), null === t ? NaN : e.getPixelForDecimal((t - e._startValue) / e._valueRange) } getPixelForTick(t) { const e = this.ticks; return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value) } getValueForPixel(t) { const e = this; return Math.round(e._startValue + e.getDecimalForPixel(t) * e._valueRange) } getBasePixel() { return this.bottom } } function Es(t, e, { horizontal: i, minRotation: n }) { const o = Et(n), s = (i ? Math.sin(o) : Math.cos(o)) || .001, a = .75 * e * ("" + t).length; return Math.min(e / s, a) } Rs.id = "category", Rs.defaults = { ticks: { callback: Rs.prototype.getLabelForValue } }; class Is extends Xi { constructor(t) { super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0 } parse(t, e) { return $(t) || ("number" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t } handleTickRangeOptions() { const t = this, { beginAtZero: e } = t.options, { minDefined: i, maxDefined: n } = t.getUserBounds(); let { min: o, max: s } = t; const a = t => o = i ? o : t, r = t => s = n ? s : t; if (e) { const t = Dt(o), e = Dt(s); t < 0 && e < 0 ? r(0) : t > 0 && e > 0 && a(0) } o === s && (r(s + 1), e || a(o - 1)), t.min = o, t.max = s } getTickLimit() { const t = this, e = t.options.ticks; let i, { maxTicksLimit: n, stepSize: o } = e; return o ? i = Math.ceil(t.max / o) - Math.floor(t.min / o) + 1 : (i = t.computeTickLimit(), n = n || 11), n && (i = Math.min(n, i)), i } computeTickLimit() { return Number.POSITIVE_INFINITY } buildTicks() { const t = this, e = t.options, i = e.ticks; let n = t.getTickLimit(); n = Math.max(2, n); const o = function (t, e) { const i = [], { bounds: n, step: o, min: s, max: a, precision: r, count: l, maxTicks: c, maxDigits: h, includeBounds: d } = t, u = o || 1, f = c - 1, { min: g, max: p } = e, m = !$(s), x = !$(a), b = !$(l), _ = (p - g) / (h + 1); let y, v, w, M, k = Ct((p - g) / f / u) * u; if (k < 1e-14 && !m && !x) return [{ value: g }, { value: p }]; M = Math.ceil(p / k) - Math.floor(g / k), M > f && (k = Ct(M * k / f / u) * u), $(r) || (y = Math.pow(10, r), k = Math.ceil(k * y) / y), "ticks" === n ? (v = Math.floor(g / k) * k, w = Math.ceil(p / k) * k) : (v = g, w = p), m && x && o && Lt((a - s) / o, k / 1e3) ? (M = Math.min((a - s) / k, c), k = (a - s) / M, v = s, w = a) : b ? (v = m ? s : v, w = x ? a : w, M = l - 1, k = (w - v) / M) : (M = (w - v) / k, M = At(M, Math.round(M), k / 1e3) ? Math.round(M) : Math.ceil(M)); const S = Math.max(zt(k), zt(v)); y = Math.pow(10, $(r) ? S : r), v = Math.round(v * y) / y, w = Math.round(w * y) / y; let P = 0; for (m && (d && v !== s ? (i.push({ value: s }), v < s && P++, At(Math.round((v + P * k) * y) / y, s, Es(s, _, t)) && P++) : v < s && P++); P < M; ++P)i.push({ value: Math.round((v + P * k) * y) / y }); return x && d && w !== a ? At(i[i.length - 1].value, a, Es(a, _, t)) ? i[i.length - 1].value = a : i.push({ value: a }) : x && w !== a || i.push({ value: w }), i }({ maxTicks: n, bounds: e.bounds, min: e.min, max: e.max, precision: i.precision, step: i.stepSize, count: i.count, maxDigits: t._maxDigits(), horizontal: t.isHorizontal(), minRotation: i.minRotation || 0, includeBounds: !1 !== i.includeBounds }, t._range || t); return "ticks" === e.bounds && Rt(o, t, "value"), e.reverse ? (o.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), o } configure() { const t = this, e = t.ticks; let i = t.min, n = t.max; if (super.configure(), t.options.offset && e.length) { const t = (n - i) / Math.max(e.length - 1, 1) / 2; i -= t, n += t } t._startValue = i, t._endValue = n, t._valueRange = n - i } getLabelForValue(t) { return zi(t, this.chart.options.locale) } } class zs extends Is { determineDataLimits() { const t = this, { min: e, max: i } = t.getMinMax(!0); t.min = X(e) ? e : 0, t.max = X(i) ? i : 1, t.handleTickRangeOptions() } computeTickLimit() { const t = this, e = t.isHorizontal(), i = e ? t.width : t.height, n = Et(t.options.ticks.minRotation), o = (e ? Math.sin(n) : Math.cos(n)) || .001, s = t._resolveTickFontOptions(0); return Math.ceil(i / Math.min(40, s.lineHeight / o)) } getPixelForValue(t) { return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange) } getValueForPixel(t) { return this._startValue + this.getDecimalForPixel(t) * this._valueRange } } function Fs(t) { return 1 === t / Math.pow(10, Math.floor(Pt(t))) } zs.id = "linear", zs.defaults = { ticks: { callback: Vi.formatters.numeric } }; class Vs extends Xi { constructor(t) { super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0 } parse(t, e) { const i = Is.prototype.parse.apply(this, [t, e]); if (0 !== i) return X(i) && i > 0 ? i : null; this._zero = !0 } determineDataLimits() { const t = this, { min: e, max: i } = t.getMinMax(!0); t.min = X(e) ? Math.max(0, e) : null, t.max = X(i) ? Math.max(0, i) : null, t.options.beginAtZero && (t._zero = !0), t.handleTickRangeOptions() } handleTickRangeOptions() { const t = this, { minDefined: e, maxDefined: i } = t.getUserBounds(); let n = t.min, o = t.max; const s = t => n = e ? n : t, a = t => o = i ? o : t, r = (t, e) => Math.pow(10, Math.floor(Pt(t)) + e); n === o && (n <= 0 ? (s(1), a(10)) : (s(r(n, -1)), a(r(o, 1)))), n <= 0 && s(r(o, -1)), o <= 0 && a(r(n, 1)), t._zero && t.min !== t._suggestedMin && n === r(t.min, 0) && s(r(n, -1)), t.min = n, t.max = o } buildTicks() { const t = this, e = t.options, i = function (t, e) { const i = Math.floor(Pt(e.max)), n = Math.ceil(e.max / Math.pow(10, i)), o = []; let s = q(t.min, Math.pow(10, Math.floor(Pt(e.min)))), a = Math.floor(Pt(s)), r = Math.floor(s / Math.pow(10, a)), l = a < 0 ? Math.pow(10, Math.abs(a)) : 1; do { o.push({ value: s, major: Fs(s) }), ++r, 10 === r && (r = 1, ++a, l = a >= 0 ? 1 : l), s = Math.round(r * Math.pow(10, a) * l) / l } while (a < i || a === i && r < n); const c = q(t.max, s); return o.push({ value: c, major: Fs(s) }), o }({ min: t._userMin, max: t._userMax }, t); return "ticks" === e.bounds && Rt(i, t, "value"), e.reverse ? (i.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), i } getLabelForValue(t) { return void 0 === t ? "0" : zi(t, this.chart.options.locale) } configure() { const t = this, e = t.min; super.configure(), t._startValue = Pt(e), t._valueRange = Pt(t.max) - Pt(e) } getPixelForValue(t) { const e = this; return void 0 !== t && 0 !== t || (t = e.min), null === t || isNaN(t) ? NaN : e.getPixelForDecimal(t === e.min ? 0 : (Pt(t) - e._startValue) / e._valueRange) } getValueForPixel(t) { const e = this, i = e.getDecimalForPixel(t); return Math.pow(10, e._startValue + i * e._valueRange) } } function Bs(t) { const e = t.ticks; if (e.display && t.display) { const t = ze(e.backdropPadding); return K(e.font && e.font.size, xt.font.size) + t.height } return 0 } function Ws(t, e, i, n, o) { return t === n || t === o ? { start: e - i / 2, end: e + i / 2 } : t < n || t > o ? { start: e - i, end: e } : { start: e, end: e + i } } function Hs(t) { return 0 === t || 180 === t ? "center" : t < 180 ? "left" : "right" } function Ns(t, e, i) { 90 === t || 270 === t ? i.y -= e.h / 2 : (t > 270 || t < 90) && (i.y -= e.h) } function js(t, e, i, n) { const { ctx: o } = t; if (i) o.arc(t.xCenter, t.yCenter, e, 0, _t); else { let i = t.getPointPosition(0, e); o.moveTo(i.x, i.y); for (let s = 1; s < n; s++)i = t.getPointPosition(s, e), o.lineTo(i.x, i.y) } } function $s(t) { return Tt(t) ? t : 0 } Vs.id = "logarithmic", Vs.defaults = { ticks: { callback: Vi.formatters.logarithmic, major: { enabled: !0 } } }; class Ys extends Is { constructor(t) { super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [] } setDimensions() { const t = this; t.width = t.maxWidth, t.height = t.maxHeight, t.paddingTop = Bs(t.options) / 2, t.xCenter = Math.floor(t.width / 2), t.yCenter = Math.floor((t.height - t.paddingTop) / 2), t.drawingArea = Math.min(t.height - t.paddingTop, t.width) / 2 } determineDataLimits() { const t = this, { min: e, max: i } = t.getMinMax(!1); t.min = X(e) && !isNaN(e) ? e : 0, t.max = X(i) && !isNaN(i) ? i : 0, t.handleTickRangeOptions() } computeTickLimit() { return Math.ceil(this.drawingArea / Bs(this.options)) } generateTickLabels(t) { const e = this; Is.prototype.generateTickLabels.call(e, t), e._pointLabels = e.getLabels().map(((t, i) => { const n = Q(e.options.pointLabels.callback, [t, i], e); return n || 0 === n ? n : "" })) } fit() { const t = this, e = t.options; e.display && e.pointLabels.display ? function (t) { const e = { l: 0, r: t.width, t: 0, b: t.height - t.paddingTop }, i = {}; let n, o, s; const a = [], r = [], l = t.getLabels().length; for (n = 0; n < l; n++) { const l = t.options.pointLabels.setContext(t.getContext(n)); r[n] = l.padding, s = t.getPointPosition(n, t.drawingArea + r[n]); const u = Fe(l.font); t.ctx.font = u.string, c = t.ctx, h = u.lineHeight, o = Y(d = t._pointLabels[n]) ? { w: Ut(c, c.font, d), h: d.length * h } : { w: c.measureText(d).width, h: h }, a[n] = o; const f = t.getIndexAngle(n), g = It(f), p = Ws(g, s.x, o.w, 0, 180), m = Ws(g, s.y, o.h, 90, 270); p.start < e.l && (e.l = p.start, i.l = f), p.end > e.r && (e.r = p.end, i.r = f), m.start < e.t && (e.t = m.start, i.t = f), m.end > e.b && (e.b = m.end, i.b = f) } var c, h, d; t._setReductions(t.drawingArea, e, i), t._pointLabelItems = []; const u = t.options, f = Bs(u), g = t.getDistanceFromCenterForValue(u.ticks.reverse ? t.min : t.max); for (n = 0; n < l; n++) { const e = 0 === n ? f / 2 : 0, i = t.getPointPosition(n, g + e + r[n]), o = It(t.getIndexAngle(n)), s = a[n]; Ns(o, s, i); const l = Hs(o); let c; c = "left" === l ? i.x : "center" === l ? i.x - s.w / 2 : i.x - s.w; const h = c + s.w; t._pointLabelItems[n] = { x: i.x, y: i.y, textAlign: l, left: c, top: i.y, right: h, bottom: i.y + s.h } } }(t) : t.setCenterPoint(0, 0, 0, 0) } _setReductions(t, e, i) { const n = this; let o = e.l / Math.sin(i.l), s = Math.max(e.r - n.width, 0) / Math.sin(i.r), a = -e.t / Math.cos(i.t), r = -Math.max(e.b - (n.height - n.paddingTop), 0) / Math.cos(i.b); o = $s(o), s = $s(s), a = $s(a), r = $s(r), n.drawingArea = Math.max(t / 2, Math.min(Math.floor(t - (o + s) / 2), Math.floor(t - (a + r) / 2))), n.setCenterPoint(o, s, a, r) } setCenterPoint(t, e, i, n) { const o = this, s = o.width - e - o.drawingArea, a = t + o.drawingArea, r = i + o.drawingArea, l = o.height - o.paddingTop - n - o.drawingArea; o.xCenter = Math.floor((a + s) / 2 + o.left), o.yCenter = Math.floor((r + l) / 2 + o.top + o.paddingTop) } getIndexAngle(t) { return Wt(t * (_t / this.getLabels().length) + Et(this.options.startAngle || 0)) } getDistanceFromCenterForValue(t) { const e = this; if ($(t)) return NaN; const i = e.drawingArea / (e.max - e.min); return e.options.reverse ? (e.max - t) * i : (t - e.min) * i } getValueForDistanceFromCenter(t) { if ($(t)) return NaN; const e = this, i = t / (e.drawingArea / (e.max - e.min)); return e.options.reverse ? e.max - i : e.min + i } getPointPosition(t, e) { const i = this, n = i.getIndexAngle(t) - Mt; return { x: Math.cos(n) * e + i.xCenter, y: Math.sin(n) * e + i.yCenter, angle: n } } getPointPositionForValue(t, e) { return this.getPointPosition(t, this.getDistanceFromCenterForValue(e)) } getBasePosition(t) { return this.getPointPositionForValue(t || 0, this.getBaseValue()) } getPointLabelPosition(t) { const { left: e, top: i, right: n, bottom: o } = this._pointLabelItems[t]; return { left: e, top: i, right: n, bottom: o } } drawBackground() { const t = this, { backgroundColor: e, grid: { circular: i } } = t.options; if (e) { const n = t.ctx; n.save(), n.beginPath(), js(t, t.getDistanceFromCenterForValue(t._endValue), i, t.getLabels().length), n.closePath(), n.fillStyle = e, n.fill(), n.restore() } } drawGrid() { const t = this, e = t.ctx, i = t.options, { angleLines: n, grid: o } = i, s = t.getLabels().length; let a, r, l; if (i.pointLabels.display && function (t, e) { const { ctx: i, options: { pointLabels: n } } = t; for (let o = e - 1; o >= 0; o--) { const e = n.setContext(t.getContext(o)), s = Fe(e.font), { x: a, y: r, textAlign: l, left: c, top: h, right: d, bottom: u } = t._pointLabelItems[o], { backdropColor: f } = e; if (!$(f)) { const t = ze(e.backdropPadding); i.fillStyle = f, i.fillRect(c - t.left, h - t.top, d - c + t.width, u - h + t.height) } ee(i, t._pointLabels[o], a, r + s.lineHeight / 2, s, { color: e.color, textAlign: l, textBaseline: "middle" }) } }(t, s), o.display && t.ticks.forEach(((e, i) => { if (0 !== i) { r = t.getDistanceFromCenterForValue(e.value); const n = o.setContext(t.getContext(i - 1)); !function (t, e, i, n) { const o = t.ctx, s = e.circular, { color: a, lineWidth: r } = e; !s && !n || !a || !r || i < 0 || (o.save(), o.strokeStyle = a, o.lineWidth = r, o.setLineDash(e.borderDash), o.lineDashOffset = e.borderDashOffset, o.beginPath(), js(t, i, s, n), o.closePath(), o.stroke(), o.restore()) }(t, n, r, s) } })), n.display) { for (e.save(), a = t.getLabels().length - 1; a >= 0; a--) { const o = n.setContext(t.getContext(a)), { color: s, lineWidth: c } = o; c && s && (e.lineWidth = c, e.strokeStyle = s, e.setLineDash(o.borderDash), e.lineDashOffset = o.borderDashOffset, r = t.getDistanceFromCenterForValue(i.ticks.reverse ? t.min : t.max), l = t.getPointPosition(a, r), e.beginPath(), e.moveTo(t.xCenter, t.yCenter), e.lineTo(l.x, l.y), e.stroke()) } e.restore() } } drawBorder() { } drawLabels() { const t = this, e = t.ctx, i = t.options, n = i.ticks; if (!n.display) return; const o = t.getIndexAngle(0); let s, a; e.save(), e.translate(t.xCenter, t.yCenter), e.rotate(o), e.textAlign = "center", e.textBaseline = "middle", t.ticks.forEach(((o, r) => { if (0 === r && !i.reverse) return; const l = n.setContext(t.getContext(r)), c = Fe(l.font); if (s = t.getDistanceFromCenterForValue(t.ticks[r].value), l.showLabelBackdrop) { a = e.measureText(o.label).width, e.fillStyle = l.backdropColor; const t = ze(l.backdropPadding); e.fillRect(-a / 2 - t.left, -s - c.size / 2 - t.top, a + t.width, c.size + t.height) } ee(e, o.label, 0, -s, c, { color: l.color }) })), e.restore() } drawTitle() { } } Ys.id = "radialLinear", Ys.defaults = { display: !0, animate: !0, position: "chartArea", angleLines: { display: !0, lineWidth: 1, borderDash: [], borderDashOffset: 0 }, grid: { circular: !1 }, startAngle: 0, ticks: { showLabelBackdrop: !0, callback: Vi.formatters.numeric }, pointLabels: { backdropColor: void 0, backdropPadding: 2, display: !0, font: { size: 10 }, callback: t => t, padding: 5 } }, Ys.defaultRoutes = { "angleLines.color": "borderColor", "pointLabels.color": "color", "ticks.color": "color" }, Ys.descriptors = { angleLines: { _fallback: "grid" } }; const Us = { millisecond: { common: !0, size: 1, steps: 1e3 }, second: { common: !0, size: 1e3, steps: 60 }, minute: { common: !0, size: 6e4, steps: 60 }, hour: { common: !0, size: 36e5, steps: 24 }, day: { common: !0, size: 864e5, steps: 30 }, week: { common: !1, size: 6048e5, steps: 4 }, month: { common: !0, size: 2628e6, steps: 12 }, quarter: { common: !1, size: 7884e6, steps: 4 }, year: { common: !0, size: 3154e7 } }, Xs = Object.keys(Us); function qs(t, e) { return t - e } function Ks(t, e) { if ($(e)) return null; const i = t._adapter, { parser: n, round: o, isoWeekday: s } = t._parseOpts; let a = e; return "function" == typeof n && (a = n(a)), X(a) || (a = "string" == typeof n ? i.parse(a, n) : i.parse(a)), null === a ? null : (o && (a = "week" !== o || !Tt(s) && !0 !== s ? i.startOf(a, o) : i.startOf(a, "isoWeek", s)), +a) } function Gs(t, e, i, n) { const o = Xs.length; for (let s = Xs.indexOf(t); s < o - 1; ++s) { const t = Us[Xs[s]], o = t.steps ? t.steps : Number.MAX_SAFE_INTEGER; if (t.common && Math.ceil((i - e) / (o * t.size)) <= n) return Xs[s] } return Xs[o - 1] } function Zs(t, e, i) { if (i) { if (i.length) { const { lo: n, hi: o } = ne(i, e); t[i[n] >= e ? i[n] : i[o]] = !0 } } else t[e] = !0 } function Qs(t, e, i) { const n = [], o = {}, s = e.length; let a, r; for (a = 0; a < s; ++a)r = e[a], o[r] = a, n.push({ value: r, major: !1 }); return 0 !== s && i ? function (t, e, i, n) { const o = t._adapter, s = +o.startOf(e[0].value, n), a = e[e.length - 1].value; let r, l; for (r = s; r <= a; r = +o.add(r, 1, n))l = i[r], l >= 0 && (e[l].major = !0); return e }(t, n, o, i) : n } class Js extends Xi { constructor(t) { super(t), this._cache = { data: [], labels: [], all: [] }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0 } init(t, e) { const i = t.time || (t.time = {}), n = this._adapter = new so._date(t.adapters.date); st(i.displayFormats, n.formats()), this._parseOpts = { parser: i.parser, round: i.round, isoWeekday: i.isoWeekday }, super.init(t), this._normalized = e.normalized } parse(t, e) { return void 0 === t ? null : Ks(this, t) } beforeLayout() { super.beforeLayout(), this._cache = { data: [], labels: [], all: [] } } determineDataLimits() { const t = this, e = t.options, i = t._adapter, n = e.time.unit || "day"; let { min: o, max: s, minDefined: a, maxDefined: r } = t.getUserBounds(); function l(t) { a || isNaN(t.min) || (o = Math.min(o, t.min)), r || isNaN(t.max) || (s = Math.max(s, t.max)) } a && r || (l(t._getLabelBounds()), "ticks" === e.bounds && "labels" === e.ticks.source || l(t.getMinMax(!1))), o = X(o) && !isNaN(o) ? o : +i.startOf(Date.now(), n), s = X(s) && !isNaN(s) ? s : +i.endOf(Date.now(), n) + 1, t.min = Math.min(o, s - 1), t.max = Math.max(o + 1, s) } _getLabelBounds() { const t = this.getLabelTimestamps(); let e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY; return t.length && (e = t[0], i = t[t.length - 1]), { min: e, max: i } } buildTicks() { const t = this, e = t.options, i = e.time, n = e.ticks, o = "labels" === n.source ? t.getLabelTimestamps() : t._generate(); "ticks" === e.bounds && o.length && (t.min = t._userMin || o[0], t.max = t._userMax || o[o.length - 1]); const s = t.min, a = ae(o, s, t.max); return t._unit = i.unit || (n.autoSkip ? Gs(i.minUnit, t.min, t.max, t._getLabelCapacity(s)) : function (t, e, i, n, o) { for (let s = Xs.length - 1; s >= Xs.indexOf(i); s--) { const i = Xs[s]; if (Us[i].common && t._adapter.diff(o, n, i) >= e - 1) return i } return Xs[i ? Xs.indexOf(i) : 0] }(t, a.length, i.minUnit, t.min, t.max)), t._majorUnit = n.major.enabled && "year" !== t._unit ? function (t) { for (let e = Xs.indexOf(t) + 1, i = Xs.length; e < i; ++e)if (Us[Xs[e]].common) return Xs[e] }(t._unit) : void 0, t.initOffsets(o), e.reverse && a.reverse(), Qs(t, a, t._majorUnit) } initOffsets(t) { const e = this; let i, n, o = 0, s = 0; e.options.offset && t.length && (i = e.getDecimalForValue(t[0]), o = 1 === t.length ? 1 - i : (e.getDecimalForValue(t[1]) - i) / 2, n = e.getDecimalForValue(t[t.length - 1]), s = 1 === t.length ? n : (n - e.getDecimalForValue(t[t.length - 2])) / 2); const a = t.length < 3 ? .5 : .25; o = Nt(o, 0, a), s = Nt(s, 0, a), e._offsets = { start: o, end: s, factor: 1 / (o + 1 + s) } } _generate() { const t = this, e = t._adapter, i = t.min, n = t.max, o = t.options, s = o.time, a = s.unit || Gs(s.minUnit, i, n, t._getLabelCapacity(i)), r = K(s.stepSize, 1), l = "week" === a && s.isoWeekday, c = Tt(l) || !0 === l, h = {}; let d, u, f = i; if (c && (f = +e.startOf(f, "isoWeek", l)), f = +e.startOf(f, c ? "day" : a), e.diff(n, i, a) > 1e5 * r) throw new Error(i + " and " + n + " are too far apart with stepSize of " + r + " " + a); const g = "data" === o.ticks.source && t.getDataTimestamps(); for (d = f, u = 0; d < n; d = +e.add(d, r, a), u++)Zs(h, d, g); return d !== n && "ticks" !== o.bounds && 1 !== u || Zs(h, d, g), Object.keys(h).sort(((t, e) => t - e)).map((t => +t)) } getLabelForValue(t) { const e = this._adapter, i = this.options.time; return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime) } _tickFormatFunction(t, e, i, n) { const o = this, s = o.options, a = s.time.displayFormats, r = o._unit, l = o._majorUnit, c = r && a[r], h = l && a[l], d = i[e], u = l && h && d && d.major, f = o._adapter.format(t, n || (u ? h : c)), g = s.ticks.callback; return g ? Q(g, [f, e, i], o) : f } generateTickLabels(t) { let e, i, n; for (e = 0, i = t.length; e < i; ++e)n = t[e], n.label = this._tickFormatFunction(n.value, e, t) } getDecimalForValue(t) { const e = this; return null === t ? NaN : (t - e.min) / (e.max - e.min) } getPixelForValue(t) { const e = this, i = e._offsets, n = e.getDecimalForValue(t); return e.getPixelForDecimal((i.start + n) * i.factor) } getValueForPixel(t) { const e = this, i = e._offsets, n = e.getDecimalForPixel(t) / i.factor - i.end; return e.min + n * (e.max - e.min) } _getLabelSize(t) { const e = this, i = e.options.ticks, n = e.ctx.measureText(t).width, o = Et(e.isHorizontal() ? i.maxRotation : i.minRotation), s = Math.cos(o), a = Math.sin(o), r = e._resolveTickFontOptions(0).size; return { w: n * s + r * a, h: n * a + r * s } } _getLabelCapacity(t) { const e = this, i = e.options.time, n = i.displayFormats, o = n[i.unit] || n.millisecond, s = e._tickFormatFunction(t, 0, Qs(e, [t], e._majorUnit), o), a = e._getLabelSize(s), r = Math.floor(e.isHorizontal() ? e.width / a.w : e.height / a.h) - 1; return r > 0 ? r : 1 } getDataTimestamps() { const t = this; let e, i, n = t._cache.data || []; if (n.length) return n; const o = t.getMatchingVisibleMetas(); if (t._normalized && o.length) return t._cache.data = o[0].controller.getAllParsedValues(t); for (e = 0, i = o.length; e < i; ++e)n = n.concat(o[e].controller.getAllParsedValues(t)); return t._cache.data = t.normalize(n) } getLabelTimestamps() { const t = this, e = t._cache.labels || []; let i, n; if (e.length) return e; const o = t.getLabels(); for (i = 0, n = o.length; i < n; ++i)e.push(Ks(t, o[i])); return t._cache.labels = t._normalized ? e : t.normalize(e) } normalize(t) { return he(t.sort(qs)) } } function ta(t, e, i) { let n, o, s, a; if (i) n = Math.floor(e), o = Math.ceil(e), s = t[n], a = t[o]; else { const i = ne(t, e); s = i.lo, a = i.hi, n = t[s], o = t[a] } const r = o - n; return r ? s + (a - s) * (e - n) / r : s } Js.id = "time", Js.defaults = { bounds: "data", adapters: {}, time: { parser: !1, unit: !1, round: !1, isoWeekday: !1, minUnit: "millisecond", displayFormats: {} }, ticks: { source: "auto", major: { enabled: !1 } } }; class ea extends Js { constructor(t) { super(t), this._table = [], this._maxIndex = void 0 } initOffsets() { const t = this, e = t._getTimestampsForTable(); t._table = t.buildLookupTable(e), t._maxIndex = t._table.length - 1, super.initOffsets(e) } buildLookupTable(t) { const { min: e, max: i } = this; if (!t.length) return [{ time: e, pos: 0 }, { time: i, pos: 1 }]; const n = [e]; let o, s, a; for (o = 0, s = t.length; o < s; ++o)a = t[o], a > e && a < i && n.push(a); return n.push(i), n } _getTimestampsForTable() { const t = this; let e = t._cache.all || []; if (e.length) return e; const i = t.getDataTimestamps(), n = t.getLabelTimestamps(); return e = i.length && n.length ? t.normalize(i.concat(n)) : i.length ? i : n, e = t._cache.all = e, e } getPixelForValue(t, e) { const i = this, n = i._offsets, o = i._normalized && i._maxIndex > 0 && !$(e) ? e / i._maxIndex : i.getDecimalForValue(t); return i.getPixelForDecimal((n.start + o) * n.factor) } getDecimalForValue(t) { return ta(this._table, t) / this._maxIndex } getValueForPixel(t) { const e = this, i = e._offsets, n = e.getDecimalForPixel(t) / i.factor - i.end; return ta(e._table, n * this._maxIndex, !0) } } ea.id = "timeseries", ea.defaults = Js.defaults; var ia = Object.freeze({ __proto__: null, CategoryScale: Rs, LinearScale: zs, LogarithmicScale: Vs, RadialLinearScale: Ys, TimeScale: Js, TimeSeriesScale: ea }); return to.register(_o, ia, Uo, As), to.helpers = { ...On }, to._adapters = so, to.Animation = _i, to.Animations = vi, to.animator = a, to.controllers = An.controllers.items, to.DatasetController = Ri, to.Element = Ei, to.elements = Uo, to.Interaction = Oe, to.layouts = Ge, to.platforms = ui, to.Scale = Xi, to.Ticks = Vi, Object.assign(to, _o, ia, Uo, As, ui), to.Chart = to, "undefined" != typeof window && (window.Chart = to), to
}));

/*! jQuery UI - v1.12.1 - 2021-01-27
* http://jqueryui.com
* Includes: keycode.js, widgets/datepicker.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

!function (e) { "function" == typeof define && define.amd ? define(["jquery"], e) : e(jQuery) }(function (M) { M.ui = M.ui || {}; var r; M.ui.version = "1.12.1", M.ui.keyCode = { BACKSPACE: 8, COMMA: 188, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, LEFT: 37, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SPACE: 32, TAB: 9, UP: 38 }; function e() { this._curInst = null, this._keyEvent = !1, this._disabledInputs = [], this._datepickerShowing = !1, this._inDialog = !1, this._mainDivId = "ui-datepicker-div", this._inlineClass = "ui-datepicker-inline", this._appendClass = "ui-datepicker-append", this._triggerClass = "ui-datepicker-trigger", this._dialogClass = "ui-datepicker-dialog", this._disableClass = "ui-datepicker-disabled", this._unselectableClass = "ui-datepicker-unselectable", this._currentClass = "ui-datepicker-current-day", this._dayOverClass = "ui-datepicker-days-cell-over", this.regional = [], this.regional[""] = { closeText: "Done", prevText: "Prev", nextText: "Next", currentText: "Today", monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], weekHeader: "Wk", dateFormat: "mm/dd/yy", firstDay: 0, isRTL: !1, showMonthAfterYear: !1, yearSuffix: "" }, this._defaults = { showOn: "focus", showAnim: "fadeIn", showOptions: {}, defaultDate: null, appendText: "", buttonText: "...", buttonImage: "", buttonImageOnly: !1, hideIfNoPrevNext: !1, navigationAsDateFormat: !1, gotoCurrent: !1, changeMonth: !1, changeYear: !1, yearRange: "c-10:c+10", showOtherMonths: !1, selectOtherMonths: !1, showWeek: !1, calculateWeek: this.iso8601Week, shortYearCutoff: "+10", minDate: null, maxDate: null, duration: "fast", beforeShowDay: null, beforeShow: null, onSelect: null, onChangeMonthYear: null, onClose: null, numberOfMonths: 1, showCurrentAtPos: 0, stepMonths: 1, stepBigMonths: 12, altField: "", altFormat: "", constrainInput: !0, showButtonPanel: !1, autoSize: !1, disabled: !1 }, M.extend(this._defaults, this.regional[""]), this.regional.en = M.extend(!0, {}, this.regional[""]), this.regional["en-US"] = M.extend(!0, {}, this.regional.en), this.dpDiv = a(M("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")) } function a(e) { var t = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a"; return e.on("mouseout", t, function () { M(this).removeClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && M(this).removeClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && M(this).removeClass("ui-datepicker-next-hover") }).on("mouseover", t, n) } function n() { M.datepicker._isDisabledDatepicker((r.inline ? r.dpDiv.parent() : r.input)[0]) || (M(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"), M(this).addClass("ui-state-hover"), -1 !== this.className.indexOf("ui-datepicker-prev") && M(this).addClass("ui-datepicker-prev-hover"), -1 !== this.className.indexOf("ui-datepicker-next") && M(this).addClass("ui-datepicker-next-hover")) } function o(e, t) { for (var a in M.extend(e, t), t) null == t[a] && (e[a] = t[a]); return e } M.extend(M.ui, { datepicker: { version: "1.12.1" } }), M.extend(e.prototype, { markerClassName: "hasDatepicker", maxRows: 4, _widgetDatepicker: function () { return this.dpDiv }, setDefaults: function (e) { return o(this._defaults, e || {}), this }, _attachDatepicker: function (e, t) { var a, i = e.nodeName.toLowerCase(), s = "div" === i || "span" === i; e.id || (this.uuid += 1, e.id = "dp" + this.uuid), (a = this._newInst(M(e), s)).settings = M.extend({}, t || {}), "input" === i ? this._connectDatepicker(e, a) : s && this._inlineDatepicker(e, a) }, _newInst: function (e, t) { return { id: e[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"), input: e, selectedDay: 0, selectedMonth: 0, selectedYear: 0, drawMonth: 0, drawYear: 0, inline: t, dpDiv: t ? a(M("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")) : this.dpDiv } }, _connectDatepicker: function (e, t) { var a = M(e); t.append = M([]), t.trigger = M([]), a.hasClass(this.markerClassName) || (this._attachments(a, t), a.addClass(this.markerClassName).on("keydown", this._doKeyDown).on("keypress", this._doKeyPress).on("keyup", this._doKeyUp), this._autoSize(t), M.data(e, "datepicker", t), t.settings.disabled && this._disableDatepicker(e)) }, _attachments: function (e, t) { var a, i = this._get(t, "appendText"), s = this._get(t, "isRTL"); t.append && t.append.remove(), i && (t.append = M("<span class='" + this._appendClass + "'>" + i + "</span>"), e[s ? "before" : "after"](t.append)), e.off("focus", this._showDatepicker), t.trigger && t.trigger.remove(), "focus" !== (a = this._get(t, "showOn")) && "both" !== a || e.on("focus", this._showDatepicker), "button" !== a && "both" !== a || (i = this._get(t, "buttonText"), a = this._get(t, "buttonImage"), t.trigger = M(this._get(t, "buttonImageOnly") ? M("<img/>").addClass(this._triggerClass).attr({ src: a, alt: i, title: i }) : M("<button type='button'></button>").addClass(this._triggerClass).html(a ? M("<img/>").attr({ src: a, alt: i, title: i }) : i)), e[s ? "before" : "after"](t.trigger), t.trigger.on("click", function () { return M.datepicker._datepickerShowing && M.datepicker._lastInput === e[0] ? M.datepicker._hideDatepicker() : (M.datepicker._datepickerShowing && M.datepicker._lastInput !== e[0] && M.datepicker._hideDatepicker(), M.datepicker._showDatepicker(e[0])), !1 })) }, _autoSize: function (e) { var t, a, i, s, r, n; this._get(e, "autoSize") && !e.inline && (r = new Date(2009, 11, 20), (n = this._get(e, "dateFormat")).match(/[DM]/) && (t = function (e) { for (s = i = a = 0; s < e.length; s++)e[s].length > a && (a = e[s].length, i = s); return i }, r.setMonth(t(this._get(e, n.match(/MM/) ? "monthNames" : "monthNamesShort"))), r.setDate(t(this._get(e, n.match(/DD/) ? "dayNames" : "dayNamesShort")) + 20 - r.getDay())), e.input.attr("size", this._formatDate(e, r).length)) }, _inlineDatepicker: function (e, t) { var a = M(e); a.hasClass(this.markerClassName) || (a.addClass(this.markerClassName).append(t.dpDiv), M.data(e, "datepicker", t), this._setDate(t, this._getDefaultDate(t), !0), this._updateDatepicker(t), this._updateAlternate(t), t.settings.disabled && this._disableDatepicker(e), t.dpDiv.css("display", "block")) }, _dialogDatepicker: function (e, t, a, i, s) { var r, n = this._dialogInst; return n || (this.uuid += 1, r = "dp" + this.uuid, this._dialogInput = M("<input type='text' id='" + r + "' style='position: absolute; top: -100px; width: 0px;'/>"), this._dialogInput.on("keydown", this._doKeyDown), M("body").append(this._dialogInput), (n = this._dialogInst = this._newInst(this._dialogInput, !1)).settings = {}, M.data(this._dialogInput[0], "datepicker", n)), o(n.settings, i || {}), t = t && t.constructor === Date ? this._formatDate(n, t) : t, this._dialogInput.val(t), this._pos = s ? s.length ? s : [s.pageX, s.pageY] : null, this._pos || (r = document.documentElement.clientWidth, i = document.documentElement.clientHeight, t = document.documentElement.scrollLeft || document.body.scrollLeft, s = document.documentElement.scrollTop || document.body.scrollTop, this._pos = [r / 2 - 100 + t, i / 2 - 150 + s]), this._dialogInput.css("left", this._pos[0] + 20 + "px").css("top", this._pos[1] + "px"), n.settings.onSelect = a, this._inDialog = !0, this.dpDiv.addClass(this._dialogClass), this._showDatepicker(this._dialogInput[0]), M.blockUI && M.blockUI(this.dpDiv), M.data(this._dialogInput[0], "datepicker", n), this }, _destroyDatepicker: function (e) { var t, a = M(e), i = M.data(e, "datepicker"); a.hasClass(this.markerClassName) && (t = e.nodeName.toLowerCase(), M.removeData(e, "datepicker"), "input" === t ? (i.append.remove(), i.trigger.remove(), a.removeClass(this.markerClassName).off("focus", this._showDatepicker).off("keydown", this._doKeyDown).off("keypress", this._doKeyPress).off("keyup", this._doKeyUp)) : "div" !== t && "span" !== t || a.removeClass(this.markerClassName).empty(), r === i && (r = null)) }, _enableDatepicker: function (t) { var e, a = M(t), i = M.data(t, "datepicker"); a.hasClass(this.markerClassName) && ("input" === (e = t.nodeName.toLowerCase()) ? (t.disabled = !1, i.trigger.filter("button").each(function () { this.disabled = !1 }).end().filter("img").css({ opacity: "1.0", cursor: "" })) : "div" !== e && "span" !== e || ((a = a.children("." + this._inlineClass)).children().removeClass("ui-state-disabled"), a.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !1)), this._disabledInputs = M.map(this._disabledInputs, function (e) { return e === t ? null : e })) }, _disableDatepicker: function (t) { var e, a = M(t), i = M.data(t, "datepicker"); a.hasClass(this.markerClassName) && ("input" === (e = t.nodeName.toLowerCase()) ? (t.disabled = !0, i.trigger.filter("button").each(function () { this.disabled = !0 }).end().filter("img").css({ opacity: "0.5", cursor: "default" })) : "div" !== e && "span" !== e || ((a = a.children("." + this._inlineClass)).children().addClass("ui-state-disabled"), a.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", !0)), this._disabledInputs = M.map(this._disabledInputs, function (e) { return e === t ? null : e }), this._disabledInputs[this._disabledInputs.length] = t) }, _isDisabledDatepicker: function (e) { if (!e) return !1; for (var t = 0; t < this._disabledInputs.length; t++)if (this._disabledInputs[t] === e) return !0; return !1 }, _getInst: function (e) { try { return M.data(e, "datepicker") } catch (e) { throw "Missing instance data for this datepicker" } }, _optionDatepicker: function (e, t, a) { var i, s, r, n, d = this._getInst(e); if (2 === arguments.length && "string" == typeof t) return "defaults" === t ? M.extend({}, M.datepicker._defaults) : d ? "all" === t ? M.extend({}, d.settings) : this._get(d, t) : null; i = t || {}, "string" == typeof t && ((i = {})[t] = a), d && (this._curInst === d && this._hideDatepicker(), s = this._getDateDatepicker(e, !0), r = this._getMinMaxDate(d, "min"), n = this._getMinMaxDate(d, "max"), o(d.settings, i), null !== r && void 0 !== i.dateFormat && void 0 === i.minDate && (d.settings.minDate = this._formatDate(d, r)), null !== n && void 0 !== i.dateFormat && void 0 === i.maxDate && (d.settings.maxDate = this._formatDate(d, n)), "disabled" in i && (i.disabled ? this._disableDatepicker(e) : this._enableDatepicker(e)), this._attachments(M(e), d), this._autoSize(d), this._setDate(d, s), this._updateAlternate(d), this._updateDatepicker(d)) }, _changeDatepicker: function (e, t, a) { this._optionDatepicker(e, t, a) }, _refreshDatepicker: function (e) { e = this._getInst(e); e && this._updateDatepicker(e) }, _setDateDatepicker: function (e, t) { e = this._getInst(e); e && (this._setDate(e, t), this._updateDatepicker(e), this._updateAlternate(e)) }, _getDateDatepicker: function (e, t) { e = this._getInst(e); return e && !e.inline && this._setDateFromField(e, t), e ? this._getDate(e) : null }, _doKeyDown: function (e) { var t, a, i = M.datepicker._getInst(e.target), s = !0, r = i.dpDiv.is(".ui-datepicker-rtl"); if (i._keyEvent = !0, M.datepicker._datepickerShowing) switch (e.keyCode) { case 9: M.datepicker._hideDatepicker(), s = !1; break; case 13: return (a = M("td." + M.datepicker._dayOverClass + ":not(." + M.datepicker._currentClass + ")", i.dpDiv))[0] && M.datepicker._selectDay(e.target, i.selectedMonth, i.selectedYear, a[0]), (t = M.datepicker._get(i, "onSelect")) ? (a = M.datepicker._formatDate(i), t.apply(i.input ? i.input[0] : null, [a, i])) : M.datepicker._hideDatepicker(), !1; case 27: M.datepicker._hideDatepicker(); break; case 33: M.datepicker._adjustDate(e.target, e.ctrlKey ? -M.datepicker._get(i, "stepBigMonths") : -M.datepicker._get(i, "stepMonths"), "M"); break; case 34: M.datepicker._adjustDate(e.target, e.ctrlKey ? +M.datepicker._get(i, "stepBigMonths") : +M.datepicker._get(i, "stepMonths"), "M"); break; case 35: (e.ctrlKey || e.metaKey) && M.datepicker._clearDate(e.target), s = e.ctrlKey || e.metaKey; break; case 36: (e.ctrlKey || e.metaKey) && M.datepicker._gotoToday(e.target), s = e.ctrlKey || e.metaKey; break; case 37: (e.ctrlKey || e.metaKey) && M.datepicker._adjustDate(e.target, r ? 1 : -1, "D"), s = e.ctrlKey || e.metaKey, e.originalEvent.altKey && M.datepicker._adjustDate(e.target, e.ctrlKey ? -M.datepicker._get(i, "stepBigMonths") : -M.datepicker._get(i, "stepMonths"), "M"); break; case 38: (e.ctrlKey || e.metaKey) && M.datepicker._adjustDate(e.target, -7, "D"), s = e.ctrlKey || e.metaKey; break; case 39: (e.ctrlKey || e.metaKey) && M.datepicker._adjustDate(e.target, r ? -1 : 1, "D"), s = e.ctrlKey || e.metaKey, e.originalEvent.altKey && M.datepicker._adjustDate(e.target, e.ctrlKey ? +M.datepicker._get(i, "stepBigMonths") : +M.datepicker._get(i, "stepMonths"), "M"); break; case 40: (e.ctrlKey || e.metaKey) && M.datepicker._adjustDate(e.target, 7, "D"), s = e.ctrlKey || e.metaKey; break; default: s = !1 } else 36 === e.keyCode && e.ctrlKey ? M.datepicker._showDatepicker(this) : s = !1; s && (e.preventDefault(), e.stopPropagation()) }, _doKeyPress: function (e) { var t, a = M.datepicker._getInst(e.target); if (M.datepicker._get(a, "constrainInput")) return t = M.datepicker._possibleChars(M.datepicker._get(a, "dateFormat")), a = String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), e.ctrlKey || e.metaKey || a < " " || !t || -1 < t.indexOf(a) }, _doKeyUp: function (e) { var t = M.datepicker._getInst(e.target); if (t.input.val() !== t.lastVal) try { M.datepicker.parseDate(M.datepicker._get(t, "dateFormat"), t.input ? t.input.val() : null, M.datepicker._getFormatConfig(t)) && (M.datepicker._setDateFromField(t), M.datepicker._updateAlternate(t), M.datepicker._updateDatepicker(t)) } catch (e) { } return !0 }, _showDatepicker: function (e) { var t, a, i, s; "input" !== (e = e.target || e).nodeName.toLowerCase() && (e = M("input", e.parentNode)[0]), M.datepicker._isDisabledDatepicker(e) || M.datepicker._lastInput === e || (s = M.datepicker._getInst(e), M.datepicker._curInst && M.datepicker._curInst !== s && (M.datepicker._curInst.dpDiv.stop(!0, !0), s && M.datepicker._datepickerShowing && M.datepicker._hideDatepicker(M.datepicker._curInst.input[0])), !1 !== (a = (i = M.datepicker._get(s, "beforeShow")) ? i.apply(e, [e, s]) : {}) && (o(s.settings, a), s.lastVal = null, M.datepicker._lastInput = e, M.datepicker._setDateFromField(s), M.datepicker._inDialog && (e.value = ""), M.datepicker._pos || (M.datepicker._pos = M.datepicker._findPos(e), M.datepicker._pos[1] += e.offsetHeight), t = !1, M(e).parents().each(function () { return !(t |= "fixed" === M(this).css("position")) }), i = { left: M.datepicker._pos[0], top: M.datepicker._pos[1] }, M.datepicker._pos = null, s.dpDiv.empty(), s.dpDiv.css({ position: "absolute", display: "block", top: "-1000px" }), M.datepicker._updateDatepicker(s), i = M.datepicker._checkOffset(s, i, t), s.dpDiv.css({ position: M.datepicker._inDialog && M.blockUI ? "static" : t ? "fixed" : "absolute", display: "none", left: i.left + "px", top: i.top + "px" }), s.inline || (a = M.datepicker._get(s, "showAnim"), i = M.datepicker._get(s, "duration"), s.dpDiv.css("z-index", function (e) { for (var t, a; e.length && e[0] !== document;) { if (("absolute" === (t = e.css("position")) || "relative" === t || "fixed" === t) && (a = parseInt(e.css("zIndex"), 10), !isNaN(a) && 0 !== a)) return a; e = e.parent() } return 0 }(M(e)) + 1), M.datepicker._datepickerShowing = !0, M.effects && M.effects.effect[a] ? s.dpDiv.show(a, M.datepicker._get(s, "showOptions"), i) : s.dpDiv[a || "show"](a ? i : null), M.datepicker._shouldFocusInput(s) && s.input.trigger("focus"), M.datepicker._curInst = s))) }, _updateDatepicker: function (e) { this.maxRows = 4, (r = e).dpDiv.empty().append(this._generateHTML(e)), this._attachHandlers(e); var t, a = this._getNumberOfMonths(e), i = a[1], s = e.dpDiv.find("." + this._dayOverClass + " a"); 0 < s.length && n.apply(s.get(0)), e.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""), 1 < i && e.dpDiv.addClass("ui-datepicker-multi-" + i).css("width", 17 * i + "em"), e.dpDiv[(1 !== a[0] || 1 !== a[1] ? "add" : "remove") + "Class"]("ui-datepicker-multi"), e.dpDiv[(this._get(e, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl"), e === M.datepicker._curInst && M.datepicker._datepickerShowing && M.datepicker._shouldFocusInput(e) && e.input.trigger("focus"), e.yearshtml && (t = e.yearshtml, setTimeout(function () { t === e.yearshtml && e.yearshtml && e.dpDiv.find("select.ui-datepicker-year:first").replaceWith(e.yearshtml), t = e.yearshtml = null }, 0)) }, _shouldFocusInput: function (e) { return e.input && e.input.is(":visible") && !e.input.is(":disabled") && !e.input.is(":focus") }, _checkOffset: function (e, t, a) { var i = e.dpDiv.outerWidth(), s = e.dpDiv.outerHeight(), r = e.input ? e.input.outerWidth() : 0, n = e.input ? e.input.outerHeight() : 0, d = document.documentElement.clientWidth + (a ? 0 : M(document).scrollLeft()), o = document.documentElement.clientHeight + (a ? 0 : M(document).scrollTop()); return t.left -= this._get(e, "isRTL") ? i - r : 0, t.left -= a && t.left === e.input.offset().left ? M(document).scrollLeft() : 0, t.top -= a && t.top === e.input.offset().top + n ? M(document).scrollTop() : 0, t.left -= Math.min(t.left, t.left + i > d && i < d ? Math.abs(t.left + i - d) : 0), t.top -= Math.min(t.top, t.top + s > o && s < o ? Math.abs(s + n) : 0), t }, _findPos: function (e) { for (var t = this._getInst(e), a = this._get(t, "isRTL"); e && ("hidden" === e.type || 1 !== e.nodeType || M.expr.filters.hidden(e));)e = e[a ? "previousSibling" : "nextSibling"]; return [(t = M(e).offset()).left, t.top] }, _hideDatepicker: function (e) { var t, a, i = this._curInst; !i || e && i !== M.data(e, "datepicker") || this._datepickerShowing && (t = this._get(i, "showAnim"), a = this._get(i, "duration"), e = function () { M.datepicker._tidyDialog(i) }, M.effects && (M.effects.effect[t] || M.effects[t]) ? i.dpDiv.hide(t, M.datepicker._get(i, "showOptions"), a, e) : i.dpDiv["slideDown" === t ? "slideUp" : "fadeIn" === t ? "fadeOut" : "hide"](t ? a : null, e), t || e(), this._datepickerShowing = !1, (e = this._get(i, "onClose")) && e.apply(i.input ? i.input[0] : null, [i.input ? i.input.val() : "", i]), this._lastInput = null, this._inDialog && (this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" }), M.blockUI && (M.unblockUI(), M("body").append(this.dpDiv))), this._inDialog = !1) }, _tidyDialog: function (e) { e.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar") }, _checkExternalClick: function (e) { var t; M.datepicker._curInst && (t = M(e.target), e = M.datepicker._getInst(t[0]), (t[0].id === M.datepicker._mainDivId || 0 !== t.parents("#" + M.datepicker._mainDivId).length || t.hasClass(M.datepicker.markerClassName) || t.closest("." + M.datepicker._triggerClass).length || !M.datepicker._datepickerShowing || M.datepicker._inDialog && M.blockUI) && (!t.hasClass(M.datepicker.markerClassName) || M.datepicker._curInst === e) || M.datepicker._hideDatepicker()) }, _adjustDate: function (e, t, a) { var i = M(e), e = this._getInst(i[0]); this._isDisabledDatepicker(i[0]) || (this._adjustInstDate(e, t + ("M" === a ? this._get(e, "showCurrentAtPos") : 0), a), this._updateDatepicker(e)) }, _gotoToday: function (e) { var t = M(e), a = this._getInst(t[0]); this._get(a, "gotoCurrent") && a.currentDay ? (a.selectedDay = a.currentDay, a.drawMonth = a.selectedMonth = a.currentMonth, a.drawYear = a.selectedYear = a.currentYear) : (e = new Date, a.selectedDay = e.getDate(), a.drawMonth = a.selectedMonth = e.getMonth(), a.drawYear = a.selectedYear = e.getFullYear()), this._notifyChange(a), this._adjustDate(t) }, _selectMonthYear: function (e, t, a) { var i = M(e), e = this._getInst(i[0]); e["selected" + ("M" === a ? "Month" : "Year")] = e["draw" + ("M" === a ? "Month" : "Year")] = parseInt(t.options[t.selectedIndex].value, 10), this._notifyChange(e), this._adjustDate(i) }, _selectDay: function (e, t, a, i) { var s = M(e); M(i).hasClass(this._unselectableClass) || this._isDisabledDatepicker(s[0]) || ((s = this._getInst(s[0])).selectedDay = s.currentDay = M("a", i).html(), s.selectedMonth = s.currentMonth = t, s.selectedYear = s.currentYear = a, this._selectDate(e, this._formatDate(s, s.currentDay, s.currentMonth, s.currentYear))) }, _clearDate: function (e) { e = M(e); this._selectDate(e, "") }, _selectDate: function (e, t) { var a = M(e), e = this._getInst(a[0]); t = null != t ? t : this._formatDate(e), e.input && e.input.val(t), this._updateAlternate(e), (a = this._get(e, "onSelect")) ? a.apply(e.input ? e.input[0] : null, [t, e]) : e.input && e.input.trigger("change"), e.inline ? this._updateDatepicker(e) : (this._hideDatepicker(), this._lastInput = e.input[0], "object" != typeof e.input[0] && e.input.trigger("focus"), this._lastInput = null) }, _updateAlternate: function (e) { var t, a, i = this._get(e, "altField"); i && (t = this._get(e, "altFormat") || this._get(e, "dateFormat"), a = this._getDate(e), e = this.formatDate(t, a, this._getFormatConfig(e)), M(i).val(e)) }, noWeekends: function (e) { e = e.getDay(); return [0 < e && e < 6, ""] }, iso8601Week: function (e) { var t = new Date(e.getTime()); return t.setDate(t.getDate() + 4 - (t.getDay() || 7)), e = t.getTime(), t.setMonth(0), t.setDate(1), Math.floor(Math.round((e - t) / 864e5) / 7) + 1 }, parseDate: function (t, s, e) { if (null == t || null == s) throw "Invalid arguments"; if ("" === (s = "object" == typeof s ? s.toString() : s + "")) return null; function r(e) { return (e = v + 1 < t.length && t.charAt(v + 1) === e) && v++, e } function a(e) { var t = r(e), t = "@" === e ? 14 : "!" === e ? 20 : "y" === e && t ? 4 : "o" === e ? 3 : 2, t = new RegExp("^\\d{" + ("y" === e ? t : 1) + "," + t + "}"); if (!(t = s.substring(l).match(t))) throw "Missing number at position " + l; return l += t[0].length, parseInt(t[0], 10) } function i(e, t, a) { var i = -1, t = M.map(r(e) ? a : t, function (e, t) { return [[t, e]] }).sort(function (e, t) { return -(e[1].length - t[1].length) }); if (M.each(t, function (e, t) { var a = t[1]; if (s.substr(l, a.length).toLowerCase() === a.toLowerCase()) return i = t[0], l += a.length, !1 }), -1 !== i) return i + 1; throw "Unknown name at position " + l } function n() { if (s.charAt(l) !== t.charAt(v)) throw "Unexpected literal at position " + l; l++ } for (var d, o, c, l = 0, h = (e ? e.shortYearCutoff : null) || this._defaults.shortYearCutoff, h = "string" != typeof h ? h : (new Date).getFullYear() % 100 + parseInt(h, 10), u = (e ? e.dayNamesShort : null) || this._defaults.dayNamesShort, p = (e ? e.dayNames : null) || this._defaults.dayNames, g = (e ? e.monthNamesShort : null) || this._defaults.monthNamesShort, _ = (e ? e.monthNames : null) || this._defaults.monthNames, f = -1, k = -1, D = -1, m = -1, y = !1, v = 0; v < t.length; v++)if (y) "'" !== t.charAt(v) || r("'") ? n() : y = !1; else switch (t.charAt(v)) { case "d": D = a("d"); break; case "D": i("D", u, p); break; case "o": m = a("o"); break; case "m": k = a("m"); break; case "M": k = i("M", g, _); break; case "y": f = a("y"); break; case "@": f = (c = new Date(a("@"))).getFullYear(), k = c.getMonth() + 1, D = c.getDate(); break; case "!": f = (c = new Date((a("!") - this._ticksTo1970) / 1e4)).getFullYear(), k = c.getMonth() + 1, D = c.getDate(); break; case "'": r("'") ? n() : y = !0; break; default: n() }if (l < s.length && (o = s.substr(l), !/^\s+/.test(o))) throw "Extra/unparsed characters found in date: " + o; if (-1 === f ? f = (new Date).getFullYear() : f < 100 && (f += (new Date).getFullYear() - (new Date).getFullYear() % 100 + (f <= h ? 0 : -100)), -1 < m) for (k = 1, D = m; ;) { if (D <= (d = this._getDaysInMonth(f, k - 1))) break; k++, D -= d } if ((c = this._daylightSavingAdjust(new Date(f, k - 1, D))).getFullYear() !== f || c.getMonth() + 1 !== k || c.getDate() !== D) throw "Invalid date"; return c }, ATOM: "yy-mm-dd", COOKIE: "D, dd M yy", ISO_8601: "yy-mm-dd", RFC_822: "D, d M y", RFC_850: "DD, dd-M-y", RFC_1036: "D, d M y", RFC_1123: "D, d M yy", RFC_2822: "D, d M yy", RSS: "D, d M y", TICKS: "!", TIMESTAMP: "@", W3C: "yy-mm-dd", _ticksTo1970: 24 * (718685 + Math.floor(492.5) - Math.floor(19.7) + Math.floor(4.925)) * 60 * 60 * 1e7, formatDate: function (t, e, a) { if (!e) return ""; function s(e) { return (e = n + 1 < t.length && t.charAt(n + 1) === e) && n++, e } function i(e, t, a) { var i = "" + t; if (s(e)) for (; i.length < a;)i = "0" + i; return i } function r(e, t, a, i) { return (s(e) ? i : a)[t] } var n, d = (a ? a.dayNamesShort : null) || this._defaults.dayNamesShort, o = (a ? a.dayNames : null) || this._defaults.dayNames, c = (a ? a.monthNamesShort : null) || this._defaults.monthNamesShort, l = (a ? a.monthNames : null) || this._defaults.monthNames, h = "", u = !1; if (e) for (n = 0; n < t.length; n++)if (u) "'" !== t.charAt(n) || s("'") ? h += t.charAt(n) : u = !1; else switch (t.charAt(n)) { case "d": h += i("d", e.getDate(), 2); break; case "D": h += r("D", e.getDay(), d, o); break; case "o": h += i("o", Math.round((new Date(e.getFullYear(), e.getMonth(), e.getDate()).getTime() - new Date(e.getFullYear(), 0, 0).getTime()) / 864e5), 3); break; case "m": h += i("m", e.getMonth() + 1, 2); break; case "M": h += r("M", e.getMonth(), c, l); break; case "y": h += s("y") ? e.getFullYear() : (e.getFullYear() % 100 < 10 ? "0" : "") + e.getFullYear() % 100; break; case "@": h += e.getTime(); break; case "!": h += 1e4 * e.getTime() + this._ticksTo1970; break; case "'": s("'") ? h += "'" : u = !0; break; default: h += t.charAt(n) }return h }, _possibleChars: function (t) { function e(e) { return (e = s + 1 < t.length && t.charAt(s + 1) === e) && s++, e } for (var a = "", i = !1, s = 0; s < t.length; s++)if (i) "'" !== t.charAt(s) || e("'") ? a += t.charAt(s) : i = !1; else switch (t.charAt(s)) { case "d": case "m": case "y": case "@": a += "0123456789"; break; case "D": case "M": return null; case "'": e("'") ? a += "'" : i = !0; break; default: a += t.charAt(s) }return a }, _get: function (e, t) { return (void 0 !== e.settings[t] ? e.settings : this._defaults)[t] }, _setDateFromField: function (e, t) { if (e.input.val() !== e.lastVal) { var a = this._get(e, "dateFormat"), i = e.lastVal = e.input ? e.input.val() : null, s = this._getDefaultDate(e), r = s, n = this._getFormatConfig(e); try { r = this.parseDate(a, i, n) || s } catch (e) { i = t ? "" : i } e.selectedDay = r.getDate(), e.drawMonth = e.selectedMonth = r.getMonth(), e.drawYear = e.selectedYear = r.getFullYear(), e.currentDay = i ? r.getDate() : 0, e.currentMonth = i ? r.getMonth() : 0, e.currentYear = i ? r.getFullYear() : 0, this._adjustInstDate(e) } }, _getDefaultDate: function (e) { return this._restrictMinMax(e, this._determineDate(e, this._get(e, "defaultDate"), new Date)) }, _determineDate: function (d, e, t) { var a, i, e = null == e || "" === e ? t : "string" == typeof e ? function (e) { try { return M.datepicker.parseDate(M.datepicker._get(d, "dateFormat"), e, M.datepicker._getFormatConfig(d)) } catch (e) { } for (var t = (e.toLowerCase().match(/^c/) ? M.datepicker._getDate(d) : null) || new Date, a = t.getFullYear(), i = t.getMonth(), s = t.getDate(), r = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, n = r.exec(e); n;) { switch (n[2] || "d") { case "d": case "D": s += parseInt(n[1], 10); break; case "w": case "W": s += 7 * parseInt(n[1], 10); break; case "m": case "M": i += parseInt(n[1], 10), s = Math.min(s, M.datepicker._getDaysInMonth(a, i)); break; case "y": case "Y": a += parseInt(n[1], 10), s = Math.min(s, M.datepicker._getDaysInMonth(a, i)) }n = r.exec(e) } return new Date(a, i, s) }(e) : "number" == typeof e ? isNaN(e) ? t : (a = e, (i = new Date).setDate(i.getDate() + a), i) : new Date(e.getTime()); return (e = e && "Invalid Date" === e.toString() ? t : e) && (e.setHours(0), e.setMinutes(0), e.setSeconds(0), e.setMilliseconds(0)), this._daylightSavingAdjust(e) }, _daylightSavingAdjust: function (e) { return e ? (e.setHours(12 < e.getHours() ? e.getHours() + 2 : 0), e) : null }, _setDate: function (e, t, a) { var i = !t, s = e.selectedMonth, r = e.selectedYear, t = this._restrictMinMax(e, this._determineDate(e, t, new Date)); e.selectedDay = e.currentDay = t.getDate(), e.drawMonth = e.selectedMonth = e.currentMonth = t.getMonth(), e.drawYear = e.selectedYear = e.currentYear = t.getFullYear(), s === e.selectedMonth && r === e.selectedYear || a || this._notifyChange(e), this._adjustInstDate(e), e.input && e.input.val(i ? "" : this._formatDate(e)) }, _getDate: function (e) { return !e.currentYear || e.input && "" === e.input.val() ? null : this._daylightSavingAdjust(new Date(e.currentYear, e.currentMonth, e.currentDay)) }, _attachHandlers: function (e) { var t = this._get(e, "stepMonths"), a = "#" + e.id.replace(/\\\\/g, "\\"); e.dpDiv.find("[data-handler]").map(function () { var e = { prev: function () { M.datepicker._adjustDate(a, -t, "M") }, next: function () { M.datepicker._adjustDate(a, +t, "M") }, hide: function () { M.datepicker._hideDatepicker() }, today: function () { M.datepicker._gotoToday(a) }, selectDay: function () { return M.datepicker._selectDay(a, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this), !1 }, selectMonth: function () { return M.datepicker._selectMonthYear(a, this, "M"), !1 }, selectYear: function () { return M.datepicker._selectMonthYear(a, this, "Y"), !1 } }; M(this).on(this.getAttribute("data-event"), e[this.getAttribute("data-handler")]) }) }, _generateHTML: function (e) { var t, a, i, s, r, n, d, o, c, l, h, u, p, g, _, f, k, D, m, y, v, M, b, w, C, I, x, Y, S, N, F, T = new Date, A = this._daylightSavingAdjust(new Date(T.getFullYear(), T.getMonth(), T.getDate())), K = this._get(e, "isRTL"), j = this._get(e, "showButtonPanel"), O = this._get(e, "hideIfNoPrevNext"), E = this._get(e, "navigationAsDateFormat"), R = this._getNumberOfMonths(e), P = this._get(e, "showCurrentAtPos"), T = this._get(e, "stepMonths"), L = 1 !== R[0] || 1 !== R[1], W = this._daylightSavingAdjust(e.currentDay ? new Date(e.currentYear, e.currentMonth, e.currentDay) : new Date(9999, 9, 9)), H = this._getMinMaxDate(e, "min"), U = this._getMinMaxDate(e, "max"), z = e.drawMonth - P, B = e.drawYear; if (z < 0 && (z += 12, B--), U) for (t = this._daylightSavingAdjust(new Date(U.getFullYear(), U.getMonth() - R[0] * R[1] + 1, U.getDate())), t = H && t < H ? H : t; this._daylightSavingAdjust(new Date(B, z, 1)) > t;)--z < 0 && (z = 11, B--); for (e.drawMonth = z, e.drawYear = B, P = this._get(e, "prevText"), P = E ? this.formatDate(P, this._daylightSavingAdjust(new Date(B, z - T, 1)), this._getFormatConfig(e)) : P, a = this._canAdjustMonth(e, -1, B, z) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='" + P + "'><span class='ui-icon ui-icon-circle-triangle-" + (K ? "e" : "w") + "'>" + P + "</span></a>" : O ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + P + "'><span class='ui-icon ui-icon-circle-triangle-" + (K ? "e" : "w") + "'>" + P + "</span></a>", P = this._get(e, "nextText"), P = E ? this.formatDate(P, this._daylightSavingAdjust(new Date(B, z + T, 1)), this._getFormatConfig(e)) : P, i = this._canAdjustMonth(e, 1, B, z) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='" + P + "'><span class='ui-icon ui-icon-circle-triangle-" + (K ? "w" : "e") + "'>" + P + "</span></a>" : O ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + P + "'><span class='ui-icon ui-icon-circle-triangle-" + (K ? "w" : "e") + "'>" + P + "</span></a>", O = this._get(e, "currentText"), P = this._get(e, "gotoCurrent") && e.currentDay ? W : A, O = E ? this.formatDate(O, P, this._getFormatConfig(e)) : O, E = e.inline ? "" : "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(e, "closeText") + "</button>", E = j ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (K ? E : "") + (this._isInRange(e, P) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>" + O + "</button>" : "") + (K ? "" : E) + "</div>" : "", s = parseInt(this._get(e, "firstDay"), 10), s = isNaN(s) ? 0 : s, r = this._get(e, "showWeek"), n = this._get(e, "dayNames"), d = this._get(e, "dayNamesMin"), o = this._get(e, "monthNames"), c = this._get(e, "monthNamesShort"), l = this._get(e, "beforeShowDay"), h = this._get(e, "showOtherMonths"), u = this._get(e, "selectOtherMonths"), p = this._getDefaultDate(e), g = "", f = 0; f < R[0]; f++) { for (k = "", this.maxRows = 4, D = 0; D < R[1]; D++) { if (m = this._daylightSavingAdjust(new Date(B, z, e.selectedDay)), b = " ui-corner-all", y = "", L) { if (y += "<div class='ui-datepicker-group", 1 < R[1]) switch (D) { case 0: y += " ui-datepicker-group-first", b = " ui-corner-" + (K ? "right" : "left"); break; case R[1] - 1: y += " ui-datepicker-group-last", b = " ui-corner-" + (K ? "left" : "right"); break; default: y += " ui-datepicker-group-middle", b = "" }y += "'>" } for (y += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + b + "'>" + (/all|left/.test(b) && 0 === f ? K ? i : a : "") + (/all|right/.test(b) && 0 === f ? K ? a : i : "") + this._generateMonthYearHeader(e, z, B, H, U, 0 < f || 0 < D, o, c) + "</div><table class='ui-datepicker-calendar'><thead><tr>", v = r ? "<th class='ui-datepicker-week-col'>" + this._get(e, "weekHeader") + "</th>" : "", _ = 0; _ < 7; _++)v += "<th scope='col'" + (5 <= (_ + s + 6) % 7 ? " class='ui-datepicker-week-end'" : "") + "><span title='" + n[M = (_ + s) % 7] + "'>" + d[M] + "</span></th>"; for (y += v + "</tr></thead><tbody>", w = this._getDaysInMonth(B, z), B === e.selectedYear && z === e.selectedMonth && (e.selectedDay = Math.min(e.selectedDay, w)), b = (this._getFirstDayOfMonth(B, z) - s + 7) % 7, w = Math.ceil((b + w) / 7), C = L && this.maxRows > w ? this.maxRows : w, this.maxRows = C, I = this._daylightSavingAdjust(new Date(B, z, 1 - b)), x = 0; x < C; x++) { for (y += "<tr>", Y = r ? "<td class='ui-datepicker-week-col'>" + this._get(e, "calculateWeek")(I) + "</td>" : "", _ = 0; _ < 7; _++)S = l ? l.apply(e.input ? e.input[0] : null, [I]) : [!0, ""], F = (N = I.getMonth() !== z) && !u || !S[0] || H && I < H || U && U < I, Y += "<td class='" + (5 <= (_ + s + 6) % 7 ? " ui-datepicker-week-end" : "") + (N ? " ui-datepicker-other-month" : "") + (I.getTime() === m.getTime() && z === e.selectedMonth && e._keyEvent || p.getTime() === I.getTime() && p.getTime() === m.getTime() ? " " + this._dayOverClass : "") + (F ? " " + this._unselectableClass + " ui-state-disabled" : "") + (N && !h ? "" : " " + S[1] + (I.getTime() === W.getTime() ? " " + this._currentClass : "") + (I.getTime() === A.getTime() ? " ui-datepicker-today" : "")) + "'" + (N && !h || !S[2] ? "" : " title='" + S[2].replace(/'/g, "&#39;") + "'") + (F ? "" : " data-handler='selectDay' data-event='click' data-month='" + I.getMonth() + "' data-year='" + I.getFullYear() + "'") + ">" + (N && !h ? "&#xa0;" : F ? "<span class='ui-state-default'>" + I.getDate() + "</span>" : "<a class='ui-state-default" + (I.getTime() === A.getTime() ? " ui-state-highlight" : "") + (I.getTime() === W.getTime() ? " ui-state-active" : "") + (N ? " ui-priority-secondary" : "") + "' href='#'>" + I.getDate() + "</a>") + "</td>", I.setDate(I.getDate() + 1), I = this._daylightSavingAdjust(I); y += Y + "</tr>" } 11 < ++z && (z = 0, B++), k += y += "</tbody></table>" + (L ? "</div>" + (0 < R[0] && D === R[1] - 1 ? "<div class='ui-datepicker-row-break'></div>" : "") : "") } g += k } return g += E, e._keyEvent = !1, g }, _generateMonthYearHeader: function (e, t, a, i, s, r, n, d) { var o, c, l, h, u, p, g, _ = this._get(e, "changeMonth"), f = this._get(e, "changeYear"), k = this._get(e, "showMonthAfterYear"), D = "<div class='ui-datepicker-title'>", m = ""; if (r || !_) m += "<span class='ui-datepicker-month'>" + n[t] + "</span>"; else { for (o = i && i.getFullYear() === a, c = s && s.getFullYear() === a, m += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>", l = 0; l < 12; l++)(!o || l >= i.getMonth()) && (!c || l <= s.getMonth()) && (m += "<option value='" + l + "'" + (l === t ? " selected='selected'" : "") + ">" + d[l] + "</option>"); m += "</select>" } if (k || (D += m + (!r && _ && f ? "" : "&#xa0;")), !e.yearshtml) if (e.yearshtml = "", r || !f) D += "<span class='ui-datepicker-year'>" + a + "</span>"; else { for (h = this._get(e, "yearRange").split(":"), u = (new Date).getFullYear(), p = (n = function (e) { e = e.match(/c[+\-].*/) ? a + parseInt(e.substring(1), 10) : e.match(/[+\-].*/) ? u + parseInt(e, 10) : parseInt(e, 10); return isNaN(e) ? u : e })(h[0]), g = Math.max(p, n(h[1] || "")), p = i ? Math.max(p, i.getFullYear()) : p, g = s ? Math.min(g, s.getFullYear()) : g, e.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>"; p <= g; p++)e.yearshtml += "<option value='" + p + "'" + (p === a ? " selected='selected'" : "") + ">" + p + "</option>"; e.yearshtml += "</select>", D += e.yearshtml, e.yearshtml = null } return D += this._get(e, "yearSuffix"), k && (D += (!r && _ && f ? "" : "&#xa0;") + m), D += "</div>" }, _adjustInstDate: function (e, t, a) { var i = e.selectedYear + ("Y" === a ? t : 0), s = e.selectedMonth + ("M" === a ? t : 0), t = Math.min(e.selectedDay, this._getDaysInMonth(i, s)) + ("D" === a ? t : 0), t = this._restrictMinMax(e, this._daylightSavingAdjust(new Date(i, s, t))); e.selectedDay = t.getDate(), e.drawMonth = e.selectedMonth = t.getMonth(), e.drawYear = e.selectedYear = t.getFullYear(), "M" !== a && "Y" !== a || this._notifyChange(e) }, _restrictMinMax: function (e, t) { var a = this._getMinMaxDate(e, "min"), e = this._getMinMaxDate(e, "max"), t = a && t < a ? a : t; return e && e < t ? e : t }, _notifyChange: function (e) { var t = this._get(e, "onChangeMonthYear"); t && t.apply(e.input ? e.input[0] : null, [e.selectedYear, e.selectedMonth + 1, e]) }, _getNumberOfMonths: function (e) { e = this._get(e, "numberOfMonths"); return null == e ? [1, 1] : "number" == typeof e ? [1, e] : e }, _getMinMaxDate: function (e, t) { return this._determineDate(e, this._get(e, t + "Date"), null) }, _getDaysInMonth: function (e, t) { return 32 - this._daylightSavingAdjust(new Date(e, t, 32)).getDate() }, _getFirstDayOfMonth: function (e, t) { return new Date(e, t, 1).getDay() }, _canAdjustMonth: function (e, t, a, i) { var s = this._getNumberOfMonths(e), s = this._daylightSavingAdjust(new Date(a, i + (t < 0 ? t : s[0] * s[1]), 1)); return t < 0 && s.setDate(this._getDaysInMonth(s.getFullYear(), s.getMonth())), this._isInRange(e, s) }, _isInRange: function (e, t) { var a = this._getMinMaxDate(e, "min"), i = this._getMinMaxDate(e, "max"), s = null, r = null, n = this._get(e, "yearRange"); return n && (e = n.split(":"), n = (new Date).getFullYear(), s = parseInt(e[0], 10), r = parseInt(e[1], 10), e[0].match(/[+\-].*/) && (s += n), e[1].match(/[+\-].*/) && (r += n)), (!a || t.getTime() >= a.getTime()) && (!i || t.getTime() <= i.getTime()) && (!s || t.getFullYear() >= s) && (!r || t.getFullYear() <= r) }, _getFormatConfig: function (e) { var t = this._get(e, "shortYearCutoff"); return { shortYearCutoff: t = "string" != typeof t ? t : (new Date).getFullYear() % 100 + parseInt(t, 10), dayNamesShort: this._get(e, "dayNamesShort"), dayNames: this._get(e, "dayNames"), monthNamesShort: this._get(e, "monthNamesShort"), monthNames: this._get(e, "monthNames") } }, _formatDate: function (e, t, a, i) { t || (e.currentDay = e.selectedDay, e.currentMonth = e.selectedMonth, e.currentYear = e.selectedYear); t = t ? "object" == typeof t ? t : this._daylightSavingAdjust(new Date(i, a, t)) : this._daylightSavingAdjust(new Date(e.currentYear, e.currentMonth, e.currentDay)); return this.formatDate(this._get(e, "dateFormat"), t, this._getFormatConfig(e)) } }), M.fn.datepicker = function (e) { if (!this.length) return this; M.datepicker.initialized || (M(document).on("mousedown", M.datepicker._checkExternalClick), M.datepicker.initialized = !0), 0 === M("#" + M.datepicker._mainDivId).length && M("body").append(M.datepicker.dpDiv); var t = Array.prototype.slice.call(arguments, 1); return "string" == typeof e && ("isDisabled" === e || "getDate" === e || "widget" === e) || "option" === e && 2 === arguments.length && "string" == typeof arguments[1] ? M.datepicker["_" + e + "Datepicker"].apply(M.datepicker, [this[0]].concat(t)) : this.each(function () { "string" == typeof e ? M.datepicker["_" + e + "Datepicker"].apply(M.datepicker, [this].concat(t)) : M.datepicker._attachDatepicker(this, e) }) }, M.datepicker = new e, M.datepicker.initialized = !1, M.datepicker.uuid = (new Date).getTime(), M.datepicker.version = "1.12.1"; M.datepicker });



// jquery.multi-select.js
// by mySociety
// https://github.com/mysociety/jquery-multi-select

; (function ($) {

    "use strict";

    var pluginName = "multiSelect",
        defaults = {
            'containerHTML': '<div class="multi-select-container">',
            'menuHTML': '<div class="multi-select-menu">',
            'buttonHTML': '<span class="multi-select-button">',
            'menuItemsHTML': '<div class="multi-select-menuitems">',
            'menuItemHTML': '<label class="multi-select-menuitem">',
            'presetsHTML': '<div class="multi-select-presets">',
            'modalHTML': undefined,
            'menuItemTitleClass': 'multi-select-menuitem--titled',
            'activeClass': 'multi-select-container--open',
            'noneText': '-- Select --',
            'allText': undefined,
            'presets': undefined,
            'positionedMenuClass': 'multi-select-container--positioned',
            'positionMenuWithin': undefined,
            'viewportBottomGutter': 20,
            'menuMinHeight': 200
        };

    /**
     * @constructor
     */
    function MultiSelect(element, options) {
        this.element = element;
        this.$element = $(element);
        this.settings = $.extend({}, defaults, options);
        this._defaults = defaults;
        this._name = pluginName;
        this.init();
    }

    function arraysAreEqual(array1, array2) {
        if (array1.length != array2.length) {
            return false;
        }

        array1.sort();
        array2.sort();

        for (var i = 0; i < array1.length; i++) {
            if (array1[i] !== array2[i]) {
                return false;
            }
        }

        return true;
    }

    $.extend(MultiSelect.prototype, {

        init: function () {
            this.checkSuitableInput();
            this.findLabels();
            this.constructContainer();
            this.constructButton();
            this.constructMenu();
            this.constructModal();

            this.setUpBodyClickListener();
            this.setUpLabelsClickListener();

            this.$element.hide();
        },

        checkSuitableInput: function (text) {
            if (this.$element.is('select[multiple]') === false) {
                throw new Error('$.multiSelect only works on <select multiple> elements');
            }
        },

        findLabels: function () {
            this.$labels = $('label[for="' + this.$element.attr('id') + '"]');
        },

        constructContainer: function () {
            this.$container = $(this.settings['containerHTML']);
            this.$element.data('multi-select-container', this.$container);
            this.$container.insertAfter(this.$element);
        },

        constructButton: function () {
            var _this = this;
            this.$button = $(this.settings['buttonHTML']);
            this.$button.attr({
                'role': 'button',
                'aria-haspopup': 'true',
                'tabindex': 0,
                'aria-label': this.$labels.eq(0).text()
            })
                .on('keydown.multiselect', function (e) {
                    var key = e.which;
                    var returnKey = 13;
                    var escapeKey = 27;
                    var spaceKey = 32;
                    var downArrow = 40;
                    if ((key === returnKey) || (key === spaceKey)) {
                        e.preventDefault();
                        _this.$button.click();
                    } else if (key === downArrow) {
                        e.preventDefault();
                        _this.menuShow();
                        var group = _this.$presets || _this.$menuItems;
                        group.children(":first").focus();
                    } else if (key === escapeKey) {
                        _this.menuHide();
                    }
                }).on('click.multiselect', function (e) {
                    _this.menuToggle();
                })
                .appendTo(this.$container);

            this.$element.on('change.multiselect', function () {
                _this.updateButtonContents();
            });

            this.updateButtonContents();
        },

        updateButtonContents: function () {
            var _this = this;
            var options = [];
            var selected = [];

            this.$element.find('option').each(function () {
                var text = /** @type string */ ($(this).text());
                options.push(text);
                if ($(this).is(':selected')) {
                    selected.push($.trim(text));
                }
            });

            this.$button.empty();

            if (selected.length == 0) {
                this.$button.text(this.settings['noneText']);
            } else if ((selected.length === options.length) && this.settings['allText']) {
                this.$button.text(this.settings['allText']);
            } else {
                this.$button.text(selected.join(', '));
            }
        },

        constructMenu: function () {
            var _this = this;

            this.$menu = $(this.settings['menuHTML']);
            this.$menu.attr({
                'role': 'menu'
            }).on('keyup.multiselect', function (e) {
                var key = e.which;
                var escapeKey = 27;
                if (key === escapeKey) {
                    _this.menuHide();
                    _this.$button.focus();
                }
            })
                .appendTo(this.$container);

            this.constructMenuItems();

            if (this.settings['presets']) {
                this.constructPresets();
            }
        },

        constructMenuItems: function () {
            var _this = this;

            this.$menuItems = $(this.settings['menuItemsHTML']);
            this.$menu.append(this.$menuItems);

            this.$element.on('change.multiselect', function (e, internal) {
                // Don't need to update the menu items if this
                // change event was fired by our tickbox handler.
                if (internal !== true) {
                    _this.updateMenuItems();
                }
            });

            this.updateMenuItems();
        },

        updateMenuItems: function () {
            var _this = this;
            this.$menuItems.empty();

            this.$element.children('optgroup,option').each(function (index, element) {
                var $item;
                if (element.nodeName === 'OPTION') {
                    $item = _this.constructMenuItem($(element), index);
                    _this.$menuItems.append($item);
                } else {
                    _this.constructMenuItemsGroup($(element), index);
                }
            });
        },

        upDown: function (type, e) {
            var key = e.which;
            var upArrow = 38;
            var downArrow = 40;

            if (key === upArrow) {
                e.preventDefault();
                var prev = $(e.currentTarget).prev();
                if (prev.length) {
                    prev.focus();
                } else if (this.$presets && type === 'menuitem') {
                    this.$presets.children(':last').focus();
                } else {
                    this.$button.focus();
                }
            } else if (key === downArrow) {
                e.preventDefault();
                var next = $(e.currentTarget).next();
                if (next.length || type === 'menuitem') {
                    next.focus();
                } else {
                    this.$menuItems.children(':first').focus();
                }
            }
        },

        constructPresets: function () {
            var _this = this;
            this.$presets = $(this.settings['presetsHTML']);
            this.$menu.prepend(this.$presets);

            $.each(this.settings['presets'], function (i, preset) {
                var unique_id = _this.$element.attr('name') + '_preset_' + i;
                var $item = $(_this.settings['menuItemHTML'])
                    .attr({
                        'for': unique_id,
                        'role': 'menuitem'
                    })
                    .html(' <span class="label-span">' + preset.name + '</span>')
                    .on('keydown.multiselect', _this.upDown.bind(_this, 'preset'))
                    .appendTo(_this.$presets);

                var $input = $('<input>')
                    .attr({
                        'type': 'radio',
                        'name': _this.$element.attr('name') + '_presets',
                        'id': unique_id
                    })
                    .prependTo($item);

                $input.on('change.multiselect', function () {
                    _this.$element.val(preset.options);
                    _this.$element.trigger('change');
                });
            });

            this.$element.on('change.multiselect', function () {
                _this.updatePresets();
            });

            this.updatePresets();
        },

        updatePresets: function () {
            var _this = this;

            $.each(this.settings['presets'], function (i, preset) {
                var unique_id = _this.$element.attr('name') + '_preset_' + i;
                var $input = _this.$presets.find('#' + unique_id);

                if (arraysAreEqual(preset.options || [], _this.$element.val() || [])) {
                    $input.prop('checked', true);
                } else {
                    $input.prop('checked', false);
                }
            });
        },

        constructMenuItemsGroup: function ($optgroup, optgroup_index) {
            var _this = this;

            $optgroup.children('option').each(function (option_index, option) {
                var $item = _this.constructMenuItem($(option), optgroup_index + '_' + option_index);
                var cls = _this.settings['menuItemTitleClass'];
                if (option_index !== 0) {
                    cls += 'sr';
                }
                $item.addClass(cls).attr('data-group-title', $optgroup.attr('label'));
                _this.$menuItems.append($item);
            });
        },

        constructMenuItem: function ($option, option_index) {
            var unique_id = this.$element.attr('name') + '_' + option_index;
            var $item = $(this.settings['menuItemHTML'])
                .attr({
                    'for': unique_id,
                    'role': 'menuitem'
                })
                .on('keydown.multiselect', this.upDown.bind(this, 'menuitem'))
                .html(' <span class="label-span">' + $option.text() + '</span>');

            var $input = $('<input>')
                .attr({
                    'type': 'checkbox',
                    'id': unique_id,
                    'value': $option.val()
                })
                .prependTo($item);

            if ($option.is(':disabled')) {
                $input.attr('disabled', 'disabled');
            }
            if ($option.is(':selected')) {
                $input.prop('checked', 'checked');
            }

            $input.on('change.multiselect', function () {
                if ($(this).prop('checked')) {
                    $option.prop('selected', true);
                } else {
                    $option.prop('selected', false);
                }

                // .prop() on its own doesn't generate a change event.
                // Other plugins might want to do stuff onChange.
                $option.trigger('change', [true]);
            });

            return $item;
        },

        constructModal: function () {
            var _this = this;

            if (this.settings['modalHTML']) {
                this.$modal = $(this.settings['modalHTML']);
                this.$modal.on('click.multiselect', function () {
                    _this.menuHide();
                })
                this.$modal.insertBefore(this.$menu);
            }
        },

        setUpBodyClickListener: function () {
            var _this = this;

            // Hide the $menu when you click outside of it.
            $('html').on('click.multiselect', function () {
                _this.menuHide();
            });

            // Stop click events from inside the $button or $menu from
            // bubbling up to the body and closing the menu!
            this.$container.on('click.multiselect', function (e) {
                e.stopPropagation();
            });
        },

        setUpLabelsClickListener: function () {
            var _this = this;
            this.$labels.on('click.multiselect', function (e) {
                e.preventDefault();
                e.stopPropagation();
                _this.menuToggle();
            });
        },

        menuShow: function () {
            $('html').trigger('click.multiselect'); // Close any other open menus
            this.$container.addClass(this.settings['activeClass']);

            if (this.settings['positionMenuWithin'] && this.settings['positionMenuWithin'] instanceof $) {
                var menuLeftEdge = this.$menu.offset().left + this.$menu.outerWidth();
                var withinLeftEdge = this.settings['positionMenuWithin'].offset().left +
                    this.settings['positionMenuWithin'].outerWidth();

                if (menuLeftEdge > withinLeftEdge) {
                    this.$menu.css('width', (withinLeftEdge - this.$menu.offset().left));
                    this.$container.addClass(this.settings['positionedMenuClass']);
                }
            }

            var menuBottom = this.$menu.offset().top + this.$menu.outerHeight();
            var viewportBottom = $(window).scrollTop() + $(window).height();
            if (menuBottom > viewportBottom - this.settings['viewportBottomGutter']) {
                this.$menu.css({
                    'maxHeight': Math.max(
                        viewportBottom - this.settings['viewportBottomGutter'] - this.$menu.offset().top,
                        this.settings['menuMinHeight']
                    ),
                    'overflow': 'scroll'
                });
            } else {
                this.$menu.css({
                    'maxHeight': '',
                    'overflow': ''
                });
            }
        },

        menuHide: function () {
            this.$container.removeClass(this.settings['activeClass']);
            this.$container.removeClass(this.settings['positionedMenuClass']);
            this.$menu.css('width', 'auto');
        },

        menuToggle: function () {
            if (this.$container.hasClass(this.settings['activeClass'])) {
                this.menuHide();
            } else {
                this.menuShow();
            }
        }

    });

    $.fn[pluginName] = function (options) {
        return this.each(function () {
            if (!$.data(this, "plugin_" + pluginName)) {
                $.data(this, "plugin_" + pluginName,
                    new MultiSelect(this, options));
            }
        });
    };

})(jQuery);

(function (g) { g.Zebra_Tooltips = function (j, s) { var b = this, k, h, q; b.settings = {}; b.hide = function (c, a) { var b = c.data("Zebra_Tooltip"); b && (b.sticky = !1, a && (b.destroy = !0), c.data("Zebra_Tooltip", b), l(c)) }; b.show = function (b, a) { var d = b.data("Zebra_Tooltip"); d && (d.sticky = !0, d.muted = !1, a && (d.destroy = !0), b.data("Zebra_Tooltip", d), n(b)) }; var m = function (c) { var a = c.data("Zebra_Tooltip"); if (!a.tooltip) { var d = jQuery("<div>", { "class": "Zebra_Tooltip", css: { opacity: 0, display: "block" } }), f = jQuery("<div>", { "class": "Zebra_Tooltip_Message", css: { "max-width": b.settings.max_width, "background-color": b.settings.background_color, color: b.settings.color } }).html(b.settings.content ? b.settings.content : a.content).appendTo(d), a = jQuery("<div>", { "class": "Zebra_Tooltip_Arrow" }).appendTo(d), e = jQuery("<div>").appendTo(a); b.settings.keep_visible && (d.bind("mouseleave" + (b.settings.close_on_click ? " click" : ""), function () { l(c) }), d.bind("mouseenter", function () { n(c) })); d.appendTo("body"); var p = d.outerWidth(), j = d.outerHeight(), m = e.outerWidth(), r = e.outerHeight(), a = { tooltip: d, tooltip_width: p, tooltip_height: j + r / 2, message: f, arrow_container: a, arrow_width: m, arrow_height: r, arrow: e }, e = f.outerWidth(), p = f.outerHeight(); d.css({ width: a.tooltip_width, height: a.tooltip_height }); a.tooltip_width += f.outerWidth() - e; a.tooltip_height += f.outerHeight() - p; d.css({ width: a.tooltip_width, height: a.tooltip_height, display: "none" }); a = g.extend(c.data("Zebra_Tooltip"), a); c.data("Zebra_Tooltip", a) } a.sticky && !a.close && (jQuery("<a>", { "class": "Zebra_Tooltip_Close", href: "javascript:void(0)" }).html("x").bind("click", function (a) { a.preventDefault(); a = c.data("Zebra_Tooltip"); a.sticky = !1; c.data("Zebra_Tooltip", a); l(c) }).appendTo(a.message), a.close = !0, a = g.extend(c.data("Zebra_Tooltip"), a), c.data("Zebra_Tooltip", a)); if (a.window_resized || a.window_scrolled) d = g(window), a.window_resized && (k = d.width(), d.height(), f = c.offset(), g.extend(a, { element_left: f.left, element_top: f.top, element_width: c.outerWidth(), element_height: c.outerHeight() })), q = d.scrollTop(), h = d.scrollLeft(), d = "left" == b.settings.position ? a.element_left - a.tooltip_width + a.arrow_width : "right" == b.settings.position ? a.element_left + a.element_width - a.arrow_width : a.element_left + (a.element_width - a.tooltip_width) / 2, f = a.element_top - a.tooltip_height, e = "left" == b.settings.position ? a.tooltip_width - a.arrow_width - a.arrow_width / 2 : "right" == b.settings.position ? a.arrow_width / 2 : (a.tooltip_width - a.arrow_width) / 2, d + a.tooltip_width > k + h && (e -= k + h - (d + a.tooltip_width) - 6, d = k + h - a.tooltip_width - 6, e + a.arrow_width > a.tooltip_width - 6 && (e = a.tooltip_width - 6 - a.arrow_width), d + e + a.arrow_width / 2 < a.element_left && (e = -1E4)), d < h && (e -= h - d, d = h + 2, 0 > e && (e = a.arrow_width / 2), d + e + a.arrow_width / 2 > a.element_left + a.element_width && (e = -1E4)), a.arrow_container.removeClass("Zebra_Tooltip_Arrow_Top"), a.arrow_container.addClass("Zebra_Tooltip_Arrow_Bottom"), a.message.css("margin-top", ""), a.arrow.css("borderColor", b.settings.background_color + " transparent transparent"), f < q ? (f = a.element_top + a.element_height - b.settings.vertical_offset, a.animation_offset = Math.abs(a.animation_offset), a.message.css("margin-top", a.arrow_height / 2), a.arrow_container.removeClass("Zebra_Tooltip_Arrow_Bottom"), a.arrow_container.addClass("Zebra_Tooltip_Arrow_Top"), a.arrow.css("borderColor", "transparent transparent " + b.settings.background_color)) : (a.animation_offset = -Math.abs(a.animation_offset), f += b.settings.vertical_offset), a.arrow_container.css("left", e), a.tooltip.css({ left: d, top: f }), g.extend(a, { tooltip_left: d, tooltip_top: f, arrow_left: e }), a.window_resized = !1, a.window_scrolled = !1, a = g.extend(c.data("Zebra_Tooltip"), a), c.data("Zebra_Tooltip", a); return a }, l = function (c) { var a = c.data("Zebra_Tooltip"); clearTimeout(a.hide_timeout); a.sticky || (clearTimeout(a.show_timeout), a.hide_timeout = setTimeout(function () { if (a.tooltip) { if (b.settings.onBeforeHide && "function" == typeof b.settings.onBeforeHide) b.settings.onBeforeHide(c); a.close = !1; a.destroy && (a.muted = !0); c.data("Zebra_Tooltip", a); g("a.Zebra_Tooltip_Close", a.tooltip).remove(); a.tooltip.stop(); a.tooltip.animate({ opacity: 0, top: a.tooltip_top + a.animation_offset }, b.settings.animation_speed, function () { g(this).css("display", "none"); if (b.settings.onHide && "function" == typeof b.settings.onHide) b.settings.onHide(c) }) } }, b.settings.hide_delay)) }, n = function (c) { var a = c.data("Zebra_Tooltip"); clearTimeout(a.show_timeout); a.muted || (clearTimeout(a.hide_timeout), a.show_timeout = setTimeout(function () { a = m(c); if (b.settings.onBeforeShow && "function" == typeof b.settings.onBeforeShow) b.settings.onBeforeShow(c); "block" != a.tooltip.css("display") && a.tooltip.css({ top: a.tooltip_top + a.animation_offset }); a.tooltip.css("display", "block"); a.tooltip.stop(); a.tooltip.animate({ top: a.tooltip_top, opacity: b.settings.opacity }, b.settings.animation_speed, function () { if (b.settings.onShow && "function" == typeof b.settings.onShow) b.settings.onShow(c) }) }, b.settings.show_delay)) }; b.settings = g.extend({}, { animation_speed: 150, animation_offset: 0, background_color: "#fff", close_on_click: !0, color: "#FFF", content: !1, hide_delay: 100, keep_visible: !0, max_width: 295, opacity: 1, position: "center", prerender: !1, show_delay: 0, vertical_offset: 0, onBeforeHide: null, onHide: null, onBeforeShow: null, onShow: null }, s); j.each(function () { var c = g(this); c.bind({ mouseenter: function () { n(c) }, mouseleave: function () { l(c) } }); c.data("Zebra_Tooltip", { tooltip: null, content: c.attr("title") || "", window_resized: !0, window_scrolled: !0, show_timeout: null, hide_timeout: null, animation_offset: b.settings.animation_offset, sticky: !1, destroy: !1, muted: !1 }); c.attr("title", ""); b.settings.prerender && m(c) }); g(window).bind("scroll resize", function (b) { j.each(function () { var a = g(this).data("Zebra_Tooltip"); "scroll" == b.type ? a.window_scrolled = !0 : a.window_resized = !0; g(this).data("Zebra_Tooltip", a) }) }) } })(jQuery);


/**
 * @license jquery.panzoom.js v3.2.2
 * Updated: Wed May 08 2019
 * Add pan and zoom functionality to any element
 * Copyright (c) timmy willison
 * Released under the MIT license
 * https://github.com/timmywil/jquery.panzoom/blob/master/MIT-License.txt
 */

(function (global, factory) {
    // AMD
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], function (jQuery) {
            return factory(global, jQuery);
        });
        // CommonJS/Browserify
    } else if (typeof exports === 'object') {
        factory(global, require('jquery'));
        // Global
    } else {
        factory(global, global.jQuery);
    }
}(typeof window !== 'undefined' ? window : this, function (window, $) {
    'use strict';

    var document = window.document;
    var datakey = '__pz__';
    var slice = Array.prototype.slice;
    var rIE11 = /trident\/7./i;
    var supportsInputEvent = (function () {
        // IE11 returns a false positive
        if (rIE11.test(navigator.userAgent)) {
            return false;
        }
        var input = document.createElement('input');
        input.setAttribute('oninput', 'return');
        return typeof input.oninput === 'function';
    })();

    // Regex
    var rupper = /([A-Z])/g;
    var rsvg = /^http:[\w\.\/]+svg$/;

    var floating = '(\\-?\\d[\\d\\.e-]*)';
    var commaSpace = '\\,?\\s*';
    var rmatrix = new RegExp(
        '^matrix\\(' +
        floating + commaSpace +
        floating + commaSpace +
        floating + commaSpace +
        floating + commaSpace +
        floating + commaSpace +
        floating + '\\)$'
    );

    /**
     * Utility for determining transform matrix equality
     * Checks backwards to test translation first
     * @param {Array} first
     * @param {Array} second
     */
    function matrixEquals(first, second) {
        var i = first.length;
        while (--i) {
            if (Math.round(+first[i]) !== Math.round(+second[i])) {
                return false;
            }
        }
        return true;
    }

    /**
     * Creates the options object for reset functions
     * @param {Boolean|Object} opts See reset methods
     * @returns {Object} Returns the newly-created options object
     */
    function createResetOptions(opts) {
        var options = { range: true, animate: true };
        if (typeof opts === 'boolean') {
            options.animate = opts;
        } else {
            $.extend(options, opts);
        }
        return options;
    }

    /**
     * Represent a transformation matrix with a 3x3 matrix for calculations
     * Matrix functions adapted from Louis Remi's jQuery.transform (https://github.com/louisremi/jquery.transform.js)
     * @param {Array|Number} a An array of six values representing a 2d transformation matrix
     */
    function Matrix(a, b, c, d, e, f, g, h, i) {
        if ($.type(a) === 'array') {
            this.elements = [
                +a[0], +a[2], +a[4],
                +a[1], +a[3], +a[5],
                0, 0, 1
            ];
        } else {
            this.elements = [
                a, b, c,
                d, e, f,
                g || 0, h || 0, i || 1
            ];
        }
    }

    Matrix.prototype = {
        /**
         * Multiply a 3x3 matrix by a similar matrix or a vector
         * @param {Matrix|Vector} matrix
         * @return {Matrix|Vector} Returns a vector if multiplying by a vector
         */
        x: function (matrix) {
            var isVector = matrix instanceof Vector;

            var a = this.elements,
                b = matrix.elements;

            if (isVector && b.length === 3) {
                // b is actually a vector
                return new Vector(
                    a[0] * b[0] + a[1] * b[1] + a[2] * b[2],
                    a[3] * b[0] + a[4] * b[1] + a[5] * b[2],
                    a[6] * b[0] + a[7] * b[1] + a[8] * b[2]
                );
            } else if (b.length === a.length) {
                // b is a 3x3 matrix
                return new Matrix(
                    a[0] * b[0] + a[1] * b[3] + a[2] * b[6],
                    a[0] * b[1] + a[1] * b[4] + a[2] * b[7],
                    a[0] * b[2] + a[1] * b[5] + a[2] * b[8],

                    a[3] * b[0] + a[4] * b[3] + a[5] * b[6],
                    a[3] * b[1] + a[4] * b[4] + a[5] * b[7],
                    a[3] * b[2] + a[4] * b[5] + a[5] * b[8],

                    a[6] * b[0] + a[7] * b[3] + a[8] * b[6],
                    a[6] * b[1] + a[7] * b[4] + a[8] * b[7],
                    a[6] * b[2] + a[7] * b[5] + a[8] * b[8]
                );
            }
            return false; // fail
        },
        /**
         * Generates an inverse of the current matrix
         * @returns {Matrix}
         */
        inverse: function () {
            var d = 1 / this.determinant(),
                a = this.elements;
            return new Matrix(
                d * (a[8] * a[4] - a[7] * a[5]),
                d * (-(a[8] * a[1] - a[7] * a[2])),
                d * (a[5] * a[1] - a[4] * a[2]),

                d * (-(a[8] * a[3] - a[6] * a[5])),
                d * (a[8] * a[0] - a[6] * a[2]),
                d * (-(a[5] * a[0] - a[3] * a[2])),

                d * (a[7] * a[3] - a[6] * a[4]),
                d * (-(a[7] * a[0] - a[6] * a[1])),
                d * (a[4] * a[0] - a[3] * a[1])
            );
        },
        /**
         * Calculates the determinant of the current matrix
         * @returns {Number}
         */
        determinant: function () {
            var a = this.elements;
            return a[0] * (a[8] * a[4] - a[7] * a[5]) - a[3] * (a[8] * a[1] - a[7] * a[2]) + a[6] * (a[5] * a[1] - a[4] * a[2]);
        }
    };

    /**
     * Create a vector containing three values
     */
    function Vector(x, y, z) {
        this.elements = [x, y, z];
    }

    /**
     * Get the element at zero-indexed index i
     * @param {Number} i
     */
    Vector.prototype.e = Matrix.prototype.e = function (i) {
        return this.elements[i];
    };

    /**
     * Create a Panzoom object for a given element
     * @constructor
     * @param {Element} elem - Element to use pan and zoom
     * @param {Object} [options] - An object literal containing options to override default options
     *  (See Panzoom.defaults for ones not listed below)
     * @param {jQuery} [options.$zoomIn] - zoom in buttons/links collection (you can also bind these yourself
     *  e.g. $button.on('click', function(e) { e.preventDefault(); $elem.panzoom('zoomIn'); });)
     * @param {jQuery} [options.$zoomOut] - zoom out buttons/links collection on which to bind zoomOut
     * @param {jQuery} [options.$zoomRange] - zoom in/out with this range control
     * @param {jQuery} [options.$reset] - Reset buttons/links collection on which to bind the reset method
     * @param {Function} [options.on[Start|Change|Zoom|Pan|End|Reset] - Optional callbacks for panzoom events
     */
    function Panzoom(elem, options) {

        // Allow instantiation without `new` keyword
        if (!(this instanceof Panzoom)) {
            return new Panzoom(elem, options);
        }

        // Sanity checks
        if (elem.nodeType !== 1) {
            $.error('Panzoom called on non-Element node');
        }
        if (!$.contains(document, elem)) {
            $.error('Panzoom element must be attached to the document');
        }

        // Don't remake
        var d = $.data(elem, datakey);
        if (d) {
            return d;
        }

        // Extend default with given object literal
        // Each instance gets its own options
        this.options = options = $.extend({}, Panzoom.defaults, options);
        this.elem = elem;
        var $elem = this.$elem = $(elem);
        this.$set = options.$set && options.$set.length ? options.$set : $elem;
        this.$doc = $(elem.ownerDocument || document);
        this.$parent = $elem.parent();
        this.parent = this.$parent[0];

        // This is SVG if the namespace is SVG
        // However, while <svg> elements are SVG, we want to treat those like other elements
        this.isSVG = rsvg.test(elem.namespaceURI) && elem.nodeName.toLowerCase() !== 'svg';

        this.panning = false;

        // Save the original transform value
        // Save the prefixed transform style key
        // Set the starting transform
        this._buildTransform();

        // Build the appropriately-prefixed transform style property name
        // De-camelcase
        this._transform = $.cssProps.transform ? $.cssProps.transform.replace(rupper, '-$1').toLowerCase() : 'transform';

        // Build the transition value
        this._buildTransition();

        // Build containment dimensions
        this.resetDimensions();

        // Add zoom and reset buttons to `this`
        var $empty = $();
        var self = this;
        $.each(['$zoomIn', '$zoomOut', '$zoomRange', '$reset'], function (i, name) {
            self[name] = options[name] || $empty;
        });

        this.enable();

        this.scale = this.getMatrix()[0];
        this._checkPanWhenZoomed();

        // Save the instance
        $.data(elem, datakey, this);
    }

    // Attach regex for possible use (immutable)
    Panzoom.rmatrix = rmatrix;

    Panzoom.defaults = {
        // Should always be non-empty
        // Used to bind jQuery events without collisions
        // A guid is not added here as different instantiations/versions of panzoom
        // on the same element is not supported, so don't do it.
        eventNamespace: '.panzoom',

        // Whether or not to transition the scale
        transition: true,

        // Default cursor style for the element
        cursor: 'move',

        // There may be some use cases for zooming without panning or vice versa
        disablePan: false,
        disableZoom: false,

        // Pan only on the X or Y axes
        disableXAxis: false,
        disableYAxis: false,

        // Set whether you'd like to pan on left (1), middle (2), or right click (3)
        which: 1,

        // The increment at which to zoom
        // Should be a number greater than 0
        increment: 0.3,

        // When no scale is passed, this option tells
        // the `zoom` method to increment
        // the scale *linearly* based on the increment option.
        // This often ends up looking like very little happened at larger zoom levels.
        // The default is to multiply/divide the scale based on the increment.
        linearZoom: false,

        // Pan only when the scale is greater than minScale
        panOnlyWhenZoomed: false,

        // min and max zoom scales
        minScale: 0.3,
        maxScale: 6,

        // The default step for the range input
        // Precendence: default < HTML attribute < option setting
        rangeStep: 0.05,

        // Animation duration (ms)
        duration: 200,
        // CSS easing used for scale transition
        easing: 'ease-in-out',

        // Indicate that the element should be contained within it's parent when panning
        // Note: this does not affect zooming outside of the parent
        // Set this value to 'invert' to only allow panning outside of the parent element (basically the opposite of the normal use of contain)
        // 'invert' is useful for a large panzoom element where you don't want to show anything behind it
        contain: false
    };

    Panzoom.prototype = {
        constructor: Panzoom,

        /**
         * @returns {Panzoom} Returns the instance
         */
        instance: function () {
            return this;
        },

        /**
         * Enable or re-enable the panzoom instance
         */
        enable: function () {
            // Unbind first
            this._initStyle();
            this._bind();
            this.disabled = false;
        },

        /**
         * Disable panzoom
         */
        disable: function () {
            this.disabled = true;
            this._resetStyle();
            this._unbind();
        },

        /**
         * @returns {Boolean} Returns whether the current panzoom instance is disabled
         */
        isDisabled: function () {
            return this.disabled;
        },

        /**
         * Destroy the panzoom instance
         */
        destroy: function () {
            this.disable();
            $.removeData(this.elem, datakey);
        },

        /**
         * Builds the restricing dimensions from the containment element
         * Also used with focal points
         * Call this method whenever the dimensions of the element or parent are changed
         */
        resetDimensions: function () {
            // Reset container properties
            this.container = this.parent.getBoundingClientRect();

            // Set element properties
            var elem = this.elem;
            // getBoundingClientRect() works with SVG, offsetWidth does not
            var dims = elem.getBoundingClientRect();
            var absScale = Math.abs(this.scale);
            this.dimensions = {
                width: dims.width,
                height: dims.height,
                left: $.css(elem, 'left', true) || 0,
                top: $.css(elem, 'top', true) || 0,
                // Borders and margins are scaled
                border: {
                    top: $.css(elem, 'borderTopWidth', true) * absScale || 0,
                    bottom: $.css(elem, 'borderBottomWidth', true) * absScale || 0,
                    left: $.css(elem, 'borderLeftWidth', true) * absScale || 0,
                    right: $.css(elem, 'borderRightWidth', true) * absScale || 0
                },
                margin: {
                    top: $.css(elem, 'marginTop', true) * absScale || 0,
                    left: $.css(elem, 'marginLeft', true) * absScale || 0
                }
            };
        },

        /**
         * Return the element to it's original transform matrix
         * @param {Boolean} [options] If a boolean is passed, animate the reset (default: true). If an options object is passed, simply pass that along to setMatrix.
         * @param {Boolean} [options.silent] Silence the reset event
         */
        reset: function (options) {
            options = createResetOptions(options);
            // Reset the transform to its original value
            var matrix = this.setMatrix(this._origTransform, options);
            if (!options.silent) {
                this._trigger('reset', matrix);
            }
        },

        /**
         * Only resets zoom level
         * @param {Boolean|Object} [options] Whether to animate the reset (default: true) or an object of options to pass to zoom()
         */
        resetZoom: function (options) {
            options = createResetOptions(options);
            var origMatrix = this.getMatrix(this._origTransform);
            options.dValue = origMatrix[3];
            this.zoom(origMatrix[0], options);
        },

        /**
         * Only reset panning
         * @param {Boolean|Object} [options] Whether to animate the reset (default: true) or an object of options to pass to pan()
         */
        resetPan: function (options) {
            var origMatrix = this.getMatrix(this._origTransform);
            this.pan(origMatrix[4], origMatrix[5], createResetOptions(options));
        },

        /**
         * Sets a transform on the $set
         * For SVG, the style attribute takes precedence
         * and allows us to animate
         * @param {String} transform
         */
        setTransform: function (transform) {
            var $set = this.$set;
            var i = $set.length;
            while (i--) {
                $.style($set[i], 'transform', transform);

                // Support IE9-11, Edge 13-14+
                // Set attribute alongside style attribute
                // since IE and Edge do not respect style settings on SVG
                // See https://css-tricks.com/transforms-on-svg-elements/
                if (this.isSVG) {
                    $set[i].setAttribute('transform', transform);
                }
            }
        },

        /**
         * Retrieving the transform is different for SVG
         *  (unless a style transform is already present)
         * Uses the $set collection for retrieving the transform
         * @param {String} [transform] Pass in an transform value (like 'scale(1.1)')
         *  to have it formatted into matrix format for use by Panzoom
         * @returns {String} Returns the current transform value of the element
         */
        getTransform: function (transform) {
            var $set = this.$set;
            var transformElem = $set[0];
            if (transform) {
                this.setTransform(transform);
            } else {

                // IE and Edge still set the transform style properly
                // They just don't render it on SVG
                // So we get a correct value here
                transform = $.style(transformElem, 'transform');

                if (this.isSVG && (!transform || transform === 'none')) {
                    transform = $.attr(transformElem, 'transform') || 'none';
                }
            }

            // Convert any transforms set by the user to matrix format
            // by setting to computed
            if (transform !== 'none' && !rmatrix.test(transform)) {

                // Get computed and set for next time
                this.setTransform(transform = $.css(transformElem, 'transform'));
            }

            return transform || 'none';
        },

        /**
         * Retrieve the current transform matrix for $elem (or turn a transform into it's array values)
         * @param {String} [transform] matrix-formatted transform value
         * @returns {Array} Returns the current transform matrix split up into it's parts, or a default matrix
         */
        getMatrix: function (transform) {
            var matrix = rmatrix.exec(transform || this.getTransform());
            if (matrix) {
                matrix.shift();
            }
            return matrix || [1, 0, 0, 1, 0, 0];
        },

        /**
         * Get the current scale.
         * @param {String} [transform] matrix-formatted transform value
         * @returns {Number} Current scale relative to the initial scale (height / width = 1)
         */
        getScale: function (matrix) {
            return Math.sqrt(Math.pow(matrix[0], 2) + Math.pow(matrix[1], 2));
        },

        /**
         * Given a matrix object, quickly set the current matrix of the element
         * @param {Array|String} matrix
         * @param {Object} [options]
         * @param {Boolean|String} [options.animate] Whether to animate the transform change, or 'skip' indicating that it is unnecessary to set
         * @param {Boolean} [options.contain] Override the global contain option
         * @param {Boolean} [options.range] If true, $zoomRange's value will be updated.
         * @param {Boolean} [options.silent] If true, the change event will not be triggered
         * @returns {Array} Returns the newly-set matrix
         */
        setMatrix: function (matrix, options) {
            if (this.disabled) { return; }
            if (!options) { options = {}; }
            // Convert to array
            if (typeof matrix === 'string') {
                matrix = this.getMatrix(matrix);
            }
            var scale = this.getScale(matrix);
            var contain = typeof options.contain !== 'undefined' ? options.contain : this.options.contain;

            // Apply containment
            if (contain) {
                var dims = options.dims;
                if (!dims) {
                    this.resetDimensions();
                    dims = this.dimensions;
                }
                var spaceWLeft, spaceWRight, scaleDiff;
                var container = this.container;
                var width = dims.width;
                var height = dims.height;
                var conWidth = container.width;
                var conHeight = container.height;
                var zoomAspectW = conWidth / width;
                var zoomAspectH = conHeight / height;

                // If the element is not naturally centered,
                // assume full space right
                if (this.$parent.css('textAlign') !== 'center' || $.css(this.elem, 'display') !== 'inline') {
                    // offsetWidth gets us the width without the transform
                    scaleDiff = (width - this.elem.offsetWidth) / 2;
                    spaceWLeft = scaleDiff - dims.border.left;
                    spaceWRight = width - conWidth - scaleDiff + dims.border.right;
                } else {
                    spaceWLeft = spaceWRight = ((width - conWidth) / 2);
                }
                var spaceHTop = ((height - conHeight) / 2) + dims.border.top;
                var spaceHBottom = ((height - conHeight) / 2) - dims.border.top - dims.border.bottom;

                if (contain === 'invert' || contain === 'automatic' && zoomAspectW < 1.01) {
                    matrix[4] = Math.max(Math.min(matrix[4], spaceWLeft - dims.border.left), -spaceWRight);
                } else {
                    matrix[4] = Math.min(Math.max(matrix[4], spaceWLeft), -spaceWRight);
                }

                if (contain === 'invert' || (contain === 'automatic' && zoomAspectH < 1.01)) {
                    matrix[5] = Math.max(Math.min(matrix[5], spaceHTop - dims.border.top), -spaceHBottom);
                } else {
                    matrix[5] = Math.min(Math.max(matrix[5], spaceHTop), -spaceHBottom);
                }
            }

            // Animate
            if (options.animate !== 'skip') {
                // Set transition
                this.transition(!options.animate);
            }

            // Update range element
            if (options.range) {
                this.$zoomRange.val(scale);
            }

            // Set the matrix on this.$set
            if (this.options.disableXAxis || this.options.disableYAxis) {
                var originalMatrix = this.getMatrix();
                if (this.options.disableXAxis) {
                    matrix[4] = originalMatrix[4];
                }
                if (this.options.disableYAxis) {
                    matrix[5] = originalMatrix[5];
                }
            }
            this.setTransform('matrix(' + matrix.join(',') + ')');

            this.scale = scale;

            // Disable/enable panning if zooming is at minimum and panOnlyWhenZoomed is true
            this._checkPanWhenZoomed(scale);

            if (!options.silent) {
                this._trigger('change', matrix);
            }

            return matrix;
        },

        /**
         * @returns {Boolean} Returns whether the panzoom element is currently being dragged
         */
        isPanning: function () {
            return this.panning;
        },

        /**
         * Apply the current transition to the element, if allowed
         * @param {Boolean} [off] Indicates that the transition should be turned off
         */
        transition: function (off) {
            if (!this._transition) { return; }
            var transition = off || !this.options.transition ? 'none' : this._transition;
            var $set = this.$set;
            var i = $set.length;
            while (i--) {
                // Avoid reflows when zooming
                if ($.style($set[i], 'transition') !== transition) {
                    $.style($set[i], 'transition', transition);
                }
            }
        },

        /**
         * Pan the element to the specified translation X and Y
         * Note: this is not the same as setting jQuery#offset() or jQuery#position()
         * @param {Number} x
         * @param {Number} y
         * @param {Object} [options] These options are passed along to setMatrix
         * @param {Array} [options.matrix] The matrix being manipulated (if already known so it doesn't have to be retrieved again)
         * @param {Boolean} [options.silent] Silence the pan event. Note that this will also silence the setMatrix change event.
         * @param {Boolean} [options.relative] Make the x and y values relative to the existing matrix
         */
        pan: function (x, y, options) {
            if (this.options.disablePan) { return; }
            if (!options) { options = {}; }
            var matrix = options.matrix;
            if (!matrix) {
                matrix = this.getMatrix();
            }
            // Cast existing matrix values to numbers
            if (options.relative) {
                x += +matrix[4];
                y += +matrix[5];
            }
            matrix[4] = x;
            matrix[5] = y;
            this.setMatrix(matrix, options);
            if (!options.silent) {
                this._trigger('pan', matrix[4], matrix[5]);
            }
        },

        /**
         * Zoom in/out the element using the scale properties of a transform matrix
         * @param {Number|Boolean} [scale] The scale to which to zoom or a boolean indicating to transition a zoom out
         * @param {Object} [opts] All global options can be overwritten by this options object. For example, override the default increment.
         * @param {Boolean} [opts.noSetRange] Specify that the method should not set the $zoomRange value (as is the case when $zoomRange is calling zoom on change)
         * @param {jQuery.Event|Object} [opts.focal] A focal point on the panzoom element on which to zoom.
         *  If an object, set the clientX and clientY properties to the position relative to the parent
         * @param {Boolean} [opts.animate] Whether to animate the zoom (defaults to true if scale is not a number, false otherwise)
         * @param {Boolean} [opts.silent] Silence the zoom event
         * @param {Array} [opts.matrix] Optionally pass the current matrix so it doesn't need to be retrieved
         * @param {Number} [opts.dValue] Think of a transform matrix as four values a, b, c, d
         *  where a/d are the horizontal/vertical scale values and b/c are the skew values
         *  (5 and 6 of matrix array are the tx/ty transform values).
         *  Normally, the scale is set to both the a and d values of the matrix.
         *  This option allows you to specify a different d value for the zoom.
         *  For instance, to flip vertically, you could set -1 as the dValue.
         */
        zoom: function (scale, opts) {
            // Shuffle arguments
            if (typeof scale === 'object') {
                opts = scale;
                scale = null;
            } else if (!opts) {
                opts = {};
            }
            var options = $.extend({}, this.options, opts);
            // Check if disabled
            if (options.disableZoom) { return; }
            var animate = false;
            var matrix = options.matrix || this.getMatrix();
            var surfaceM = new Matrix(matrix);
            var startScale = this.getScale(matrix);

            // Calculate zoom based on increment
            if (typeof scale !== 'number') {
                if (options.linearZoom) {
                    scale = 1 + (options.increment * (scale ? -1 : 1)) / startScale;
                } else {
                    scale = scale ? (1 / (1 + options.increment)) : (1 + options.increment);
                }
                animate = true;
            } else {
                scale = 1 / startScale;
            }

            // Constrain scale
            scale = Math.max(Math.min(scale, options.maxScale / startScale), options.minScale / startScale);
            var m = surfaceM.x(new Matrix(scale, 0, 0, 0, (typeof options.dValue === 'number' ? options.dValue / startScale : scale), 0));

            // Calculate focal point based on scale
            var focal = options.focal;
            if (focal && !options.disablePan) {
                // Adapted from code by Florian Günther
                // https://github.com/florianguenther/zui53
                this.resetDimensions();
                var dims = options.dims = this.dimensions;
                var clientX = focal.clientX;
                var clientY = focal.clientY;

                // Adjust the focal point for transform-origin 50% 50%
                // SVG elements have a transform origin of 0 0
                if (!this.isSVG) {
                    clientX -= (dims.width / startScale) / 2;
                    clientY -= (dims.height / startScale) / 2;
                }

                var clientV = new Vector(clientX, clientY, 1);
                // Supply an offset manually if necessary
                var o = this.parentOffset || this.$parent.offset();
                var offsetM = new Matrix(1, 0, o.left - this.$doc.scrollLeft(), 0, 1, o.top - this.$doc.scrollTop());
                var surfaceV = surfaceM.inverse().x(offsetM.inverse().x(clientV));
                surfaceM = surfaceM.x(new Matrix([scale, 0, 0, scale, 0, 0]));
                clientV = offsetM.x(surfaceM.x(surfaceV));
                matrix[4] = +matrix[4] + (clientX - clientV.e(0));
                matrix[5] = +matrix[5] + (clientY - clientV.e(1));
            }

            // Set the scale
            matrix[0] = m.e(0);
            matrix[1] = m.e(3);
            matrix[2] = m.e(1);
            matrix[3] = m.e(4);

            // Calling zoom may still pan the element
            this.setMatrix(matrix, {
                animate: typeof options.animate !== 'undefined' ? options.animate : animate,
                // Set the zoomRange value
                range: !options.noSetRange
            });

            // Trigger zoom event
            if (!options.silent) {
                this._trigger('zoom', scale, options);
            }
        },

        /**
         * Get/set option on an existing instance
         * @returns {Array|undefined} If getting, returns an array of all values
         *   on each instance for a given key. If setting, continue chaining by returning undefined.
         */
        option: function (key, value) {
            var options;
            if (!key) {
                // Avoids returning direct reference
                return $.extend({}, this.options);
            }

            if (typeof key === 'string') {
                if (arguments.length === 1) {
                    return this.options[key] !== undefined ?
                        this.options[key] :
                        null;
                }
                options = {};
                options[key] = value;
            } else {
                options = key;
            }

            this._setOptions(options);
        },

        /**
         * Internally sets options
         * @param {Object} options - An object literal of options to set
         * @private
         */
        _setOptions: function (options) {
            $.each(options, $.proxy(function (key, value) {
                switch (key) {
                    case 'disablePan':
                        this._resetStyle();
                    /* falls through */
                    case '$zoomIn':
                    case '$zoomOut':
                    case '$zoomRange':
                    case '$reset':
                    case 'disableZoom':
                    case 'onStart':
                    case 'onChange':
                    case 'onZoom':
                    case 'onPan':
                    case 'onEnd':
                    case 'onReset':
                    case 'eventNamespace':
                        this._unbind();
                }
                this.options[key] = value;
                switch (key) {
                    case 'disablePan':
                        this._initStyle();
                    /* falls through */
                    case '$zoomIn':
                    case '$zoomOut':
                    case '$zoomRange':
                    case '$reset':
                        // Set these on the instance
                        this[key] = value;
                    /* falls through */
                    case 'disableZoom':
                    case 'onStart':
                    case 'onChange':
                    case 'onZoom':
                    case 'onPan':
                    case 'onEnd':
                    case 'onReset':
                    case 'eventNamespace':
                        this._bind();
                        break;
                    case 'cursor':
                        $.style(this.elem, 'cursor', value);
                        break;
                    case 'minScale':
                        this.$zoomRange.attr('min', value);
                        break;
                    case 'maxScale':
                        this.$zoomRange.attr('max', value);
                        break;
                    case 'rangeStep':
                        this.$zoomRange.attr('step', value);
                        break;
                    case 'startTransform':
                        this._buildTransform();
                        break;
                    case 'duration':
                    case 'easing':
                        this._buildTransition();
                    /* falls through */
                    case 'transition':
                        this.transition();
                        break;
                    case 'panOnlyWhenZoomed':
                        this._checkPanWhenZoomed();
                        break;
                    case '$set':
                        if (value instanceof $ && value.length) {
                            this.$set = value;
                            // Reset styles
                            this._initStyle();
                            this._buildTransform();
                        }
                }
            }, this));
        },

        /**
         * Disable/enable panning depending on whether the current scale
         * matches the minimum
         * @param {Number} [scale]
         * @private
         */
        _checkPanWhenZoomed: function (scale) {
            var options = this.options;
            if (options.panOnlyWhenZoomed) {
                if (!scale) {
                    scale = this.getMatrix()[0];
                }
                var toDisable = scale <= options.minScale;
                if (options.disablePan !== toDisable) {
                    this.option('disablePan', toDisable);
                }
            }
        },

        /**
         * Initialize base styles for the element and its parent
         * @private
         */
        _initStyle: function () {
            var styles = {
                // Set the same default whether SVG or HTML
                // transform-origin cannot be changed to 50% 50% in IE9-11 or Edge 13-14+
                'transform-origin': this.isSVG ? '0 0' : '50% 50%'
            };
            // Set elem styles
            if (!this.options.disablePan) {
                styles.cursor = this.options.cursor;
            }
            this.$set.css(styles);

            // Set parent to relative if set to static
            var $parent = this.$parent;
            // No need to add styles to the body
            if ($parent.length && !$.nodeName(this.parent, 'body')) {
                styles = {
                    overflow: 'hidden'
                };
                if ($parent.css('position') === 'static') {
                    styles.position = 'relative';
                }
                $parent.css(styles);
            }
        },

        /**
         * Undo any styles attached in this plugin
         * @private
         */
        _resetStyle: function () {
            this.$elem.css({
                'cursor': '',
                'transition': ''
            });
            this.$parent.css({
                'overflow': '',
                'position': ''
            });
        },

        /**
         * Binds all necessary events
         * @private
         */
        _bind: function () {
            var self = this;
            var options = this.options;
            var ns = options.eventNamespace;
            var str_down = 'mousedown' + ns + ' pointerdown' + ns + ' MSPointerDown' + ns;
            var str_start = 'touchstart' + ns + ' ' + str_down;
            var str_click = 'touchend' + ns + ' click' + ns + ' pointerup' + ns + ' MSPointerUp' + ns;
            var events = {};
            var $reset = this.$reset;
            var $zoomRange = this.$zoomRange;

            // Bind panzoom events from options
            $.each(['Start', 'Change', 'Zoom', 'Pan', 'End', 'Reset'], function () {
                var m = options['on' + this];
                if ($.isFunction(m)) {
                    events['panzoom' + this.toLowerCase() + ns] = m;
                }
            });

            // Bind $elem drag and click/touchdown events
            // Bind touchstart if either panning or zooming is enabled
            if (!options.disablePan || !options.disableZoom) {
                events[str_start] = function (e) {

                    //var thisTarget = e.closest('.drop-toggle');
                    var thisTarget = e;

                    var touches;
                    if (
                        (e.type === 'touchstart' ? (touches = e.touches || e.originalEvent.touches) && ((touches.length === 1 && !options.disablePan) || touches.length === 2) : !options.disablePan && (e.which || e.originalEvent.which) === options.which)
                        && !thisTarget.target.closest('.panzoom-exclude')
                    ) {
                        e.preventDefault();
                        e.stopPropagation();
                        self._startMove(e, touches);
                    }
                };
                // Prevent the contextmenu event
                // if we're binding to right-click
                if (options.which === 3) {
                    events.contextmenu = false;
                }
            }
            this.$elem.on(events);

            // Bind reset
            if ($reset.length) {
                $reset.on(str_click, function (e) {
                    e.preventDefault();
                    self.reset();
                });
            }

            // Set default attributes for the range input
            if ($zoomRange.length) {
                $zoomRange.attr({
                    // Only set the range step if explicit or
                    // set the default if there is no attribute present
                    step: options.rangeStep === Panzoom.defaults.rangeStep &&
                        $zoomRange.attr('step') ||
                        options.rangeStep,
                    min: options.minScale,
                    max: options.maxScale
                }).prop({
                    value: this.getMatrix()[0]
                });
            }

            // No bindings if zooming is disabled
            if (options.disableZoom) {
                return;
            }

            var $zoomIn = this.$zoomIn;
            var $zoomOut = this.$zoomOut;

            // Bind zoom in/out
            // Don't bind one without the other
            if ($zoomIn.length && $zoomOut.length) {
                // preventDefault cancels future mouse events on touch events
                $zoomIn.on(str_click, function (e) {
                    e.preventDefault();
                    self.zoom();
                });
                $zoomOut.on(str_click, function (e) {
                    e.preventDefault();
                    self.zoom(true);
                });
            }

            if ($zoomRange.length) {
                events = {};
                // Cannot prevent default action here
                events[str_down] = function () {
                    self.transition(true);
                };
                // Zoom on input events if available and change events
                // See https://github.com/timmywil/jquery.panzoom/issues/90
                events[(supportsInputEvent ? 'input' : 'change') + ns] = function () {
                    self.zoom(+this.value, { noSetRange: true });
                };
                $zoomRange.on(events);
            }
        },

        /**
         * Unbind all events
         * @private
         */
        _unbind: function () {
            this.$elem
                .add(this.$zoomIn)
                .add(this.$zoomOut)
                .add(this.$reset)
                .off(this.options.eventNamespace);
        },

        /**
         * Builds the original transform value
         * @private
         */
        _buildTransform: function () {
            // Save the original transform
            // Retrieving this also adds the correct prefixed style name
            // to jQuery's internal $.cssProps
            return this._origTransform = this.getTransform(this.options.startTransform);
        },

        /**
         * Set transition property for later use when zooming
         * @private
         */
        _buildTransition: function () {
            if (this._transform) {
                var options = this.options;
                this._transition = this._transform + ' ' + options.duration + 'ms ' + options.easing;
            }
        },

        /**
         * Calculates the distance between two touch points
         * Remember pythagorean?
         * @param {Array} touches
         * @returns {Number} Returns the distance
         * @private
         */
        _getDistance: function (touches) {
            var touch1 = touches[0];
            var touch2 = touches[1];
            return Math.sqrt(Math.pow(Math.abs(touch2.clientX - touch1.clientX), 2) + Math.pow(Math.abs(touch2.clientY - touch1.clientY), 2));
        },

        /**
         * Constructs an approximated point in the middle of two touch points
         * @returns {Object} Returns an object containing pageX and pageY
         * @private
         */
        _getMiddle: function (touches) {
            var touch1 = touches[0];
            var touch2 = touches[1];
            return {
                clientX: ((touch2.clientX - touch1.clientX) / 2) + touch1.clientX,
                clientY: ((touch2.clientY - touch1.clientY) / 2) + touch1.clientY
            };
        },

        /**
         * Trigger a panzoom event on our element
         * The event is passed the Panzoom instance
         * @param {String|jQuery.Event} event
         * @param {Mixed} arg1[, arg2, arg3, ...] Arguments to append to the trigger
         * @private
         */
        _trigger: function (event) {
            if (typeof event === 'string') {
                event = 'panzoom' + event;
            }
            this.$elem.triggerHandler(event, [this].concat(slice.call(arguments, 1)));
        },

        /**
         * Starts the pan
         * This is bound to mouse/touchmove on the element
         * @param {jQuery.Event} event An event with pageX, pageY, and possibly the touches list
         * @param {TouchList} [touches] The touches list if present
         * @private
         */
        _startMove: function (event, touches) {
            if (this.panning) {
                return;
            }
            var moveEvent, endEvent,
                startDistance, startScale, startMiddle,
                startPageX, startPageY, touch;
            var self = this;
            var options = this.options;
            var ns = options.eventNamespace;
            var matrix = this.getMatrix();
            var original = matrix.slice(0);
            var origPageX = +original[4];
            var origPageY = +original[5];
            var panOptions = { matrix: matrix, animate: 'skip' };
            var type = event.type;

            // Use proper events
            if (type === 'pointerdown') {
                moveEvent = 'pointermove';
                endEvent = 'pointerup';
            } else if (type === 'touchstart') {
                moveEvent = 'touchmove';
                endEvent = 'touchend';
            } else if (type === 'MSPointerDown') {
                moveEvent = 'MSPointerMove';
                endEvent = 'MSPointerUp';
            } else {
                moveEvent = 'mousemove';
                endEvent = 'mouseup';
            }

            // Add namespace
            moveEvent += ns;
            endEvent += ns;

            // Remove any transitions happening
            this.transition(true);

            // Indicate that we are currently panning
            this.panning = true;

            // Trigger start event
            this._trigger('start', event, touches);

            var setStart = function (event, touches) {
                if (touches) {
                    if (touches.length === 2) {
                        if (startDistance != null) {
                            return;
                        }
                        startDistance = self._getDistance(touches);
                        startScale = self.getScale(matrix);
                        startMiddle = self._getMiddle(touches);
                        return;
                    }
                    if (startPageX != null) {
                        return;
                    }
                    if ((touch = touches[0])) {
                        startPageX = touch.pageX;
                        startPageY = touch.pageY;
                    }
                }
                if (startPageX != null) {
                    return;
                }
                startPageX = event.pageX;
                startPageY = event.pageY;
            };

            setStart(event, touches);

            var move = function (e) {
                var coords;
                e.preventDefault();
                touches = e.touches || e.originalEvent.touches;
                setStart(e, touches);

                if (touches) {
                    if (touches.length === 2) {

                        // Calculate move on middle point
                        var middle = self._getMiddle(touches);
                        var diff = self._getDistance(touches) - startDistance;

                        // Set zoom
                        self.zoom(diff * (options.increment / 100) + startScale, {
                            focal: middle,
                            matrix: matrix,
                            animate: 'skip'
                        });

                        // Set pan
                        self.pan(
                            +matrix[4] + middle.clientX - startMiddle.clientX,
                            +matrix[5] + middle.clientY - startMiddle.clientY,
                            panOptions
                        );
                        startMiddle = middle;
                        return;
                    }
                    coords = touches[0] || { pageX: 0, pageY: 0 };
                }

                if (!coords) {
                    coords = e;
                }

                self.pan(
                    origPageX + coords.pageX - startPageX,
                    origPageY + coords.pageY - startPageY,
                    panOptions
                );
            };

            // Bind the handlers
            $(document)
                .off(ns)
                .on(moveEvent, move)
                .on(endEvent, function (e) {
                    e.preventDefault();
                    // Unbind all document events
                    $(this).off(ns);
                    self.panning = false;
                    // Trigger our end event
                    // Simply set the type to "panzoomend" to pass through all end properties
                    // jQuery's `not` is used here to compare Array equality
                    e.type = 'panzoomend';
                    self._trigger(e, matrix, !matrixEquals(matrix, original));
                });
        }
    };

    // Add Panzoom as a static property
    $.Panzoom = Panzoom;

    /**
     * Extend jQuery
     * @param {Object|String} options - The name of a method to call on the prototype
     *  or an object literal of options
     * @returns {jQuery|Mixed} jQuery instance for regular chaining or the return value(s) of a panzoom method call
     */
    $.fn.panzoom = function (options) {
        var instance, args, m, ret;

        // Call methods widget-style
        if (typeof options === 'string') {
            ret = [];
            args = slice.call(arguments, 1);
            this.each(function () {
                instance = $.data(this, datakey);

                if (!instance) {
                    ret.push(undefined);

                    // Ignore methods beginning with `_`
                } else if (options.charAt(0) !== '_' &&
                    typeof (m = instance[options]) === 'function' &&
                    // If nothing is returned, do not add to return values
                    (m = m.apply(instance, args)) !== undefined) {

                    ret.push(m);
                }
            });

            // Return an array of values for the jQuery instances
            // Or the value itself if there is only one
            // Or keep chaining
            return ret.length ?
                (ret.length === 1 ? ret[0] : ret) :
                this;
        }

        return this.each(function () { new Panzoom(this, options); });
    };

    return Panzoom;
}));

/**
* jquery.matchHeight.js master
* http://brm.io/jquery-match-height/
* License: MIT
*/
!function (r) { function s(t) { return parseFloat(t) || 0 } function h(t) { var t = r(t), o = null, i = []; return t.each(function () { var t = r(this), e = t.offset().top - s(t.css("margin-top")), a = 0 < i.length ? i[i.length - 1] : null; null !== a && Math.floor(Math.abs(o - e)) <= 1 ? i[i.length - 1] = a.add(t) : i.push(t), o = e }), i } function c(t) { var e = { byRow: !0, property: "height", target: null, remove: !1 }; return "object" == typeof t ? r.extend(e, t) : ("boolean" == typeof t ? e.byRow = t : "remove" === t && (e.remove = !0), e) } var o = -1, i = -1, l = r.fn.matchHeight = function (t) { t = c(t); if (t.remove) { var a = this; return this.css(t.property, ""), r.each(l._groups, function (t, e) { e.elements = e.elements.not(a) }), this } return this.length <= 1 && !t.target || (l._groups.push({ elements: this, options: t }), l._apply(this, t)), this }; function n(t) { l._beforeUpdate && l._beforeUpdate(t, l._groups), r.each(l._groups, function () { l._apply(this.elements, this.options) }), l._afterUpdate && l._afterUpdate(t, l._groups) } l.version = "master", l._groups = [], l._throttle = 80, l._maintainScroll = !1, l._beforeUpdate = null, l._afterUpdate = null, l._rows = h, l._parse = s, l._parseOptions = c, l._apply = function (t, e) { var o = c(e), a = r(t), i = [a], n = r(window).scrollTop(), e = r("html").outerHeight(!0), t = a.parents().filter(":hidden"); return t.each(function () { var t = r(this); t.data("style-cache", t.attr("style")) }), t.css("display", "block"), o.byRow && !o.target && (a.each(function () { var t = r(this), e = t.css("display"); "inline-block" !== e && "inline-flex" !== e && (e = "block"), t.data("style-cache", t.attr("style")), t.css({ display: e, "padding-top": "0", "padding-bottom": "0", "margin-top": "0", "margin-bottom": "0", "border-top-width": "0", "border-bottom-width": "0", height: "100px", overflow: "hidden" }) }), i = h(a), a.each(function () { var t = r(this); t.attr("style", t.data("style-cache") || "") })), r.each(i, function (t, e) { var e = r(e), a = 0; if (o.target) a = o.target.outerHeight(!1); else { if (o.byRow && e.length <= 1) return void e.css(o.property, ""); e.each(function () { var t = r(this), e = t.css("display"); "inline-block" !== e && "inline-flex" !== e && (e = "block"); e = { display: e }; e[o.property] = "", t.css(e), t.outerHeight(!1) > a && (a = t.outerHeight(!1)), t.css("display", "") }) } e.each(function () { var t = r(this), e = 0; o.target && t.is(o.target) || ("border-box" !== t.css("box-sizing") && (e += s(t.css("border-top-width")) + s(t.css("border-bottom-width")), e += s(t.css("padding-top")) + s(t.css("padding-bottom"))), t.css(o.property, a - e + "px")) }) }), t.each(function () { var t = r(this); t.attr("style", t.data("style-cache") || null) }), l._maintainScroll && r(window).scrollTop(n / e * r("html").outerHeight(!0)), this }, l._applyDataApi = function () { var a = {}; r("[data-match-height], [data-mh]").each(function () { var t = r(this), e = t.attr("data-mh") || t.attr("data-match-height"); e in a ? a[e] = a[e].add(t) : a[e] = t }), r.each(a, function () { this.matchHeight(!0) }) }, l._update = function (t, e) { if (e && "resize" === e.type) { var a = r(window).width(); if (a === o) return; o = a } t ? -1 === i && (i = setTimeout(function () { n(e), i = -1 }, l._throttle)) : n(e) }, r(l._applyDataApi), r(window).bind("load", function (t) { l._update(!1, t) }), r(window).bind("resize orientationchange", function (t) { l._update(!0, t) }) }(jQuery);

//https://xdsoft.net/jqplugins/autocomplete/
/**
 * @preserve jQuery Autocomplete plugin v1.2.6
 * @homepage http://xdsoft.net/jqplugins/autocomplete/
 * @license MIT - MIT-LICENSE.txt
 * (c) 2014, Chupurnov Valeriy <chupurnov@gmail.com>
 */
(function ($) {
    'use strict';
    var ARROWLEFT = 37,
        ARROWRIGHT = 39,
        ARROWUP = 38,
        ARROWDOWN = 40,
        TAB = 9,
        CTRLKEY = 17,
        SHIFTKEY = 16,
        DEL = 46,
        ENTER = 13,
        ESC = 27,
        BACKSPACE = 8,
        AKEY = 65,
        CKEY = 67,
        VKEY = 86,
        ZKEY = 90,
        YKEY = 89,
        defaultSetting = {},
        //currentInput = false,
        ctrlDown = false,
        shiftDown = false,
        publics = {},
        accent_map = {
            'ẚ': 'a', 'Á': 'a', 'á': 'a', 'À': 'a', 'à': 'a', 'Ă': 'a', 'ă': 'a', 'Ắ': 'a', 'ắ': 'a', 'Ằ': 'a', 'ằ': 'a', 'Ẵ': 'a', 'ẵ': 'a', 'Ẳ': 'a',
            'Ẫ': 'a', 'ẫ': 'a', 'Ẩ': 'a', 'ẩ': 'a', 'Ǎ': 'a', 'ǎ': 'a', 'Å': 'a', 'å': 'a', 'Ǻ': 'a', 'ǻ': 'a', 'Ä': 'a', 'ä': 'a', 'Ǟ': 'a', 'ǟ': 'a',
            'Ã': 'a', 'ã': 'a', 'Ȧ': 'a', 'ȧ': 'a', 'Ǡ': 'a', 'ǡ': 'a', 'Ą': 'a', 'ą': 'a', 'Ā': 'a', 'ā': 'a', 'Ả': 'a', 'ả': 'a', 'Ȁ': 'a', 'ȁ': 'a',
            'Ȃ': 'a', 'ȃ': 'a', 'Ạ': 'a', 'ạ': 'a', 'Ặ': 'a', 'ặ': 'a', 'Ậ': 'a', 'ậ': 'a', 'Ḁ': 'a', 'ḁ': 'a', 'Ⱥ': 'a', 'ⱥ': 'a', 'Ǽ': 'a', 'ǽ': 'a',
            'Ǣ': 'a', 'ǣ': 'a', 'Ḃ': 'b', 'ḃ': 'b', 'Ḅ': 'b', 'ḅ': 'b', 'Ḇ': 'b', 'ḇ': 'b', 'Ƀ': 'b', 'ƀ': 'b', 'ᵬ': 'b', 'Ɓ': 'b', 'ɓ': 'b', 'Ƃ': 'b',
            'ƃ': 'b', 'Ć': 'c', 'ć': 'c', 'Ĉ': 'c', 'ĉ': 'c', 'Č': 'c', 'č': 'c', 'Ċ': 'c', 'ċ': 'c', 'Ç': 'c', 'ç': 'c', 'Ḉ': 'c', 'ḉ': 'c', 'Ȼ': 'c',
            'ȼ': 'c', 'Ƈ': 'c', 'ƈ': 'c', 'ɕ': 'c', 'Ď': 'd', 'ď': 'd', 'Ḋ': 'd', 'ḋ': 'd', 'Ḑ': 'd', 'ḑ': 'd', 'Ḍ': 'd', 'ḍ': 'd', 'Ḓ': 'd', 'ḓ': 'd',
            'Ḏ': 'd', 'ḏ': 'd', 'Đ': 'd', 'đ': 'd', 'ᵭ': 'd', 'Ɖ': 'd', 'ɖ': 'd', 'Ɗ': 'd', 'ɗ': 'd', 'Ƌ': 'd', 'ƌ': 'd', 'ȡ': 'd', 'ð': 'd', 'É': 'e',
            'Ə': 'e', 'Ǝ': 'e', 'ǝ': 'e', 'é': 'e', 'È': 'e', 'è': 'e', 'Ĕ': 'e', 'ĕ': 'e', 'Ê': 'e', 'ê': 'e', 'Ế': 'e', 'ế': 'e', 'Ề': 'e', 'ề': 'e',
            'Ễ': 'e', 'ễ': 'e', 'Ể': 'e', 'ể': 'e', 'Ě': 'e', 'ě': 'e', 'Ë': 'e', 'ë': 'e', 'Ẽ': 'e', 'ẽ': 'e', 'Ė': 'e', 'ė': 'e', 'Ȩ': 'e', 'ȩ': 'e',
            'Ḝ': 'e', 'ḝ': 'e', 'Ę': 'e', 'ę': 'e', 'Ē': 'e', 'ē': 'e', 'Ḗ': 'e', 'ḗ': 'e', 'Ḕ': 'e', 'ḕ': 'e', 'Ẻ': 'e', 'ẻ': 'e', 'Ȅ': 'e', 'ȅ': 'e',
            'Ȇ': 'e', 'ȇ': 'e', 'Ẹ': 'e', 'ẹ': 'e', 'Ệ': 'e', 'ệ': 'e', 'Ḙ': 'e', 'ḙ': 'e', 'Ḛ': 'e', 'ḛ': 'e', 'Ɇ': 'e', 'ɇ': 'e', 'ɚ': 'e', 'ɝ': 'e',
            'Ḟ': 'f', 'ḟ': 'f', 'ᵮ': 'f', 'Ƒ': 'f', 'ƒ': 'f', 'Ǵ': 'g', 'ǵ': 'g', 'Ğ': 'g', 'ğ': 'g', 'Ĝ': 'g', 'ĝ': 'g', 'Ǧ': 'g', 'ǧ': 'g', 'Ġ': 'g',
            'ġ': 'g', 'Ģ': 'g', 'ģ': 'g', 'Ḡ': 'g', 'ḡ': 'g', 'Ǥ': 'g', 'ǥ': 'g', 'Ɠ': 'g', 'ɠ': 'g', 'Ĥ': 'h', 'ĥ': 'h', 'Ȟ': 'h', 'ȟ': 'h', 'Ḧ': 'h',
            'ḧ': 'h', 'Ḣ': 'h', 'ḣ': 'h', 'Ḩ': 'h', 'ḩ': 'h', 'Ḥ': 'h', 'ḥ': 'h', 'Ḫ': 'h', 'ḫ': 'h', 'H': 'h', '̱': 'h', 'ẖ': 'h', 'Ħ': 'h', 'ħ': 'h',
            'Ⱨ': 'h', 'ⱨ': 'h', 'Í': 'i', 'í': 'i', 'Ì': 'i', 'ì': 'i', 'Ĭ': 'i', 'ĭ': 'i', 'Î': 'i', 'î': 'i', 'Ǐ': 'i', 'ǐ': 'i', 'Ï': 'i', 'ï': 'i',
            'Ḯ': 'i', 'ḯ': 'i', 'Ĩ': 'i', 'ĩ': 'i', 'İ': 'i', 'i': 'i', 'Į': 'i', 'į': 'i', 'Ī': 'i', 'ī': 'i', 'Ỉ': 'i', 'ỉ': 'i', 'Ȉ': 'i', 'ȉ': 'i',
            'Ȋ': 'i', 'ȋ': 'i', 'Ị': 'i', 'ị': 'i', 'Ḭ': 'i', 'ḭ': 'i', 'I': 'i', 'ı': 'i', 'Ɨ': 'i', 'ɨ': 'i', 'Ĵ': 'j', 'ĵ': 'j', 'J': 'j', '̌': 'j',
            'ǰ': 'j', 'ȷ': 'j', 'Ɉ': 'j', 'ɉ': 'j', 'ʝ': 'j', 'ɟ': 'j', 'ʄ': 'j', 'Ḱ': 'k', 'ḱ': 'k', 'Ǩ': 'k', 'ǩ': 'k', 'Ķ': 'k', 'ķ': 'k', 'Ḳ': 'k',
            'ḳ': 'k', 'Ḵ': 'k', 'ḵ': 'k', 'Ƙ': 'k', 'ƙ': 'k', 'Ⱪ': 'k', 'ⱪ': 'k', 'Ĺ': 'a', 'ĺ': 'l', 'Ľ': 'l', 'ľ': 'l', 'Ļ': 'l', 'ļ': 'l', 'Ḷ': 'l',
            'ḷ': 'l', 'Ḹ': 'l', 'ḹ': 'l', 'Ḽ': 'l', 'ḽ': 'l', 'Ḻ': 'l', 'ḻ': 'l', 'Ł': 'l', 'ł': 'l', '̣': 'l', 'Ŀ': 'l',
            'ŀ': 'l', 'Ƚ': 'l', 'ƚ': 'l', 'Ⱡ': 'l', 'ⱡ': 'l', 'Ɫ': 'l', 'ɫ': 'l', 'ɬ': 'l', 'ɭ': 'l', 'ȴ': 'l', 'Ḿ': 'm', 'ḿ': 'm', 'Ṁ': 'm', 'ṁ': 'm',
            'Ṃ': 'm', 'ṃ': 'm', 'ɱ': 'm', 'Ń': 'n', 'ń': 'n', 'Ǹ': 'n', 'ǹ': 'n', 'Ň': 'n', 'ň': 'n', 'Ñ': 'n', 'ñ': 'n', 'Ṅ': 'n', 'ṅ': 'n', 'Ņ': 'n',
            'ņ': 'n', 'Ṇ': 'n', 'ṇ': 'n', 'Ṋ': 'n', 'ṋ': 'n', 'Ṉ': 'n', 'ṉ': 'n', 'Ɲ': 'n', 'ɲ': 'n', 'Ƞ': 'n', 'ƞ': 'n', 'ɳ': 'n', 'ȵ': 'n', 'N': 'n',
            '̈': 'n', 'n': 'n', 'Ó': 'o', 'ó': 'o', 'Ò': 'o', 'ò': 'o', 'Ŏ': 'o', 'ŏ': 'o', 'Ô': 'o', 'ô': 'o', 'Ố': 'o', 'ố': 'o', 'Ồ': 'o',
            'ồ': 'o', 'Ỗ': 'o', 'ỗ': 'o', 'Ổ': 'o', 'ổ': 'o', 'Ǒ': 'o', 'ǒ': 'o', 'Ö': 'o', 'ö': 'o', 'Ȫ': 'o', 'ȫ': 'o', 'Ő': 'o', 'ő': 'o', 'Õ': 'o',
            'õ': 'o', 'Ṍ': 'o', 'ṍ': 'o', 'Ṏ': 'o', 'ṏ': 'o', 'Ȭ': 'o', 'ȭ': 'o', 'Ȯ': 'o', 'ȯ': 'o', 'Ȱ': 'o', 'ȱ': 'o', 'Ø': 'o', 'ø': 'o', 'Ǿ': 'o',
            'ǿ': 'o', 'Ǫ': 'o', 'ǫ': 'o', 'Ǭ': 'o', 'ǭ': 'o', 'Ō': 'o', 'ō': 'o', 'Ṓ': 'o', 'ṓ': 'o', 'Ṑ': 'o', 'ṑ': 'o', 'Ỏ': 'o', 'ỏ': 'o', 'Ȍ': 'o',
            'ȍ': 'o', 'Ȏ': 'o', 'ȏ': 'o', 'Ơ': 'o', 'ơ': 'o', 'Ớ': 'o', 'ớ': 'o', 'Ờ': 'o', 'ờ': 'o', 'Ỡ': 'o', 'ỡ': 'o', 'Ở': 'o', 'ở': 'o', 'Ợ': 'o',
            'ợ': 'o', 'Ọ': 'o', 'ọ': 'o', 'Ộ': 'o', 'ộ': 'o', 'Ɵ': 'o', 'ɵ': 'o', 'Ṕ': 'p', 'ṕ': 'p', 'Ṗ': 'p', 'ṗ': 'p', 'Ᵽ': 'p', 'Ƥ': 'p', 'ƥ': 'p',
            'P': 'p', '̃': 'p', 'p': 'p', 'ʠ': 'q', 'Ɋ': 'q', 'ɋ': 'q', 'Ŕ': 'r', 'ŕ': 'r', 'Ř': 'r', 'ř': 'r', 'Ṙ': 'r', 'ṙ': 'r', 'Ŗ': 'r',
            'ŗ': 'r', 'Ȑ': 'r', 'ȑ': 'r', 'Ȓ': 'r', 'ȓ': 'r', 'Ṛ': 'r', 'ṛ': 'r', 'Ṝ': 'r', 'ṝ': 'r', 'Ṟ': 'r', 'ṟ': 'r', 'Ɍ': 'r', 'ɍ': 'r', 'ᵲ': 'r',
            'ɼ': 'r', 'Ɽ': 'r', 'ɽ': 'r', 'ɾ': 'r', 'ᵳ': 'r', 'ß': 's', 'Ś': 's', 'ś': 's', 'Ṥ': 's', 'ṥ': 's', 'Ŝ': 's', 'ŝ': 's', 'Š': 's', 'š': 's',
            'Ṧ': 's', 'ṧ': 's', 'Ṡ': 's', 'ṡ': 's', 'ẛ': 's', 'Ş': 's', 'ş': 's', 'Ṣ': 's', 'ṣ': 's', 'Ṩ': 's', 'ṩ': 's', 'Ș': 's', 'ș': 's', 'ʂ': 's',
            'S': 's', '̩': 's', 's': 's', 'Þ': 't', 'þ': 't', 'Ť': 't', 'ť': 't', 'T': 't', 'ẗ': 't', 'Ṫ': 't', 'ṫ': 't', 'Ţ': 't', 'ţ': 't', 'Ṭ': 't',
            'ṭ': 't', 'Ț': 't', 'ț': 't', 'Ṱ': 't', 'ṱ': 't', 'Ṯ': 't', 'ṯ': 't', 'Ŧ': 't', 'ŧ': 't', 'Ⱦ': 't', 'ⱦ': 't', 'ᵵ': 't',
            'ƫ': 't', 'Ƭ': 't', 'ƭ': 't', 'Ʈ': 't', 'ʈ': 't', 'ȶ': 't', 'Ú': 'u', 'ú': 'u', 'Ù': 'u', 'ù': 'u', 'Ŭ': 'u', 'ŭ': 'u', 'Û': 'u', 'û': 'u',
            'Ǔ': 'u', 'ǔ': 'u', 'Ů': 'u', 'ů': 'u', 'Ü': 'u', 'ü': 'u', 'Ǘ': 'u', 'ǘ': 'u', 'Ǜ': 'u', 'ǜ': 'u', 'Ǚ': 'u', 'ǚ': 'u', 'Ǖ': 'u', 'ǖ': 'u',
            'Ű': 'u', 'ű': 'u', 'Ũ': 'u', 'ũ': 'u', 'Ṹ': 'u', 'ṹ': 'u', 'Ų': 'u', 'ų': 'u', 'Ū': 'u', 'ū': 'u', 'Ṻ': 'u', 'ṻ': 'u', 'Ủ': 'u', 'ủ': 'u',
            'Ȕ': 'u', 'ȕ': 'u', 'Ȗ': 'u', 'ȗ': 'u', 'Ư': 'u', 'ư': 'u', 'Ứ': 'u', 'ứ': 'u', 'Ừ': 'u', 'ừ': 'u', 'Ữ': 'u', 'ữ': 'u', 'Ử': 'u', 'ử': 'u',
            'Ự': 'u', 'ự': 'u', 'Ụ': 'u', 'ụ': 'u', 'Ṳ': 'u', 'ṳ': 'u', 'Ṷ': 'u', 'ṷ': 'u', 'Ṵ': 'u', 'ṵ': 'u', 'Ʉ': 'u', 'ʉ': 'u', 'Ṽ': 'v', 'ṽ': 'v',
            'Ṿ': 'v', 'ṿ': 'v', 'Ʋ': 'v', 'ʋ': 'v', 'Ẃ': 'w', 'ẃ': 'w', 'Ẁ': 'w', 'ẁ': 'w', 'Ŵ': 'w', 'ŵ': 'w', 'W': 'w', '̊': 'w', 'ẘ': 'w', 'Ẅ': 'w',
            'ẅ': 'w', 'Ẇ': 'w', 'ẇ': 'w', 'Ẉ': 'w', 'ẉ': 'w', 'Ẍ': 'x', 'ẍ': 'x', 'Ẋ': 'x', 'ẋ': 'x', 'Ý': 'y', 'ý': 'y', 'Ỳ': 'y', 'ỳ': 'y', 'Ŷ': 'y',
            'ŷ': 'y', 'Y': 'y', 'ẙ': 'y', 'Ÿ': 'y', 'ÿ': 'y', 'Ỹ': 'y', 'ỹ': 'y', 'Ẏ': 'y', 'ẏ': 'y', 'Ȳ': 'y', 'ȳ': 'y', 'Ỷ': 'y', 'ỷ': 'y',
            'Ỵ': 'y', 'ỵ': 'y', 'ʏ': 'y', 'Ɏ': 'y', 'ɏ': 'y', 'Ƴ': 'y', 'ƴ': 'y', 'Ź': 'z', 'ź': 'z', 'Ẑ': 'z', 'ẑ': 'z', 'Ž': 'z', 'ž': 'z', 'Ż': 'z',
            'ż': 'z', 'Ẓ': 'z', 'ẓ': 'z', 'Ẕ': 'z', 'ẕ': 'z', 'Ƶ': 'z', 'ƶ': 'z', 'Ȥ': 'z', 'ȥ': 'z', 'ʐ': 'z', 'ʑ': 'z', 'Ⱬ': 'z', 'ⱬ': 'z', 'Ǯ': 'z',
            'ǯ': 'z', 'ƺ': 'z', '２': '2', '６': '6', 'Ｂ': 'B', 'Ｆ': 'F', 'Ｊ': 'J', 'Ｎ': 'N', 'Ｒ': 'R', 'Ｖ': 'V', 'Ｚ': 'Z', 'ｂ': 'b', 'ｆ': 'f', 'ｊ': 'j',
            'ｎ': 'n', 'ｒ': 'r', 'ｖ': 'v', 'ｚ': 'z', '１': '1', '５': '5', '９': '9', 'Ａ': 'A', 'Ｅ': 'E', 'Ｉ': 'I', 'Ｍ': 'M', 'Ｑ': 'Q', 'Ｕ': 'U', 'Ｙ': 'Y',
            'ａ': 'a', 'ｅ': 'e', 'ｉ': 'i', 'ｍ': 'm', 'ｑ': 'q', 'ｕ': 'u', 'ｙ': 'y', '０': '0', '４': '4', '８': '8', 'Ｄ': 'D', 'Ｈ': 'H', 'Ｌ': 'L', 'Ｐ': 'P',
            'Ｔ': 'T', 'Ｘ': 'X', 'ｄ': 'd', 'ｈ': 'h', 'ｌ': 'l', 'ｐ': 'p', 'ｔ': 't', 'ｘ': 'x', '３': '3', '７': '7', 'Ｃ': 'C', 'Ｇ': 'G', 'Ｋ': 'K', 'Ｏ': 'O',
            'Ｓ': 'S', 'Ｗ': 'W', 'ｃ': 'c', 'ｇ': 'g', 'ｋ': 'k', 'ｏ': 'o', 'ｓ': 's', 'ｗ': 'w', 'ẳ': 'a', 'Â': 'a', 'â': 'a', 'Ấ': 'a', 'ấ': 'a', 'Ầ': 'a', 'ầ': 'a'
        };

    if (window.getComputedStyle === undefined) {
        window.getComputedStyle = (function () {
            function getPixelSize(element, style, property, fontSize) {
                var sizeWithSuffix = style[property],
                    size = parseFloat(sizeWithSuffix),
                    suffix = sizeWithSuffix.split(/\d/)[0],
                    rootSize;

                fontSize = fontSize !== null ? fontSize : /%|em/.test(suffix) && element.parentElement ? getPixelSize(element.parentElement, element.parentElement.currentStyle, 'fontSize', null) : 16;
                rootSize = property === 'fontSize' ? fontSize : /width/i.test(property) ? element.clientWidth : element.clientHeight;

                return (suffix === 'em') ? size * fontSize : (suffix === 'in') ? size * 96 : (suffix === 'pt') ? size * 96 / 72 : (suffix === '%') ? size / 100 * rootSize : size;
            }

            function setShortStyleProperty(style, property) {
                var borderSuffix = property === 'border' ? 'Width' : '',
                    t = property + 'Top' + borderSuffix,
                    r = property + 'Right' + borderSuffix,
                    b = property + 'Bottom' + borderSuffix,
                    l = property + 'Left' + borderSuffix;

                style[property] = (style[t] === style[r] === style[b] === style[l] ? [style[t]]
                    : style[t] === style[b] && style[l] === style[r] ? [style[t], style[r]]
                        : style[l] === style[r] ? [style[t], style[r], style[b]]
                            : [style[t], style[r], style[b], style[l]]).join(' ');
            }

            function CSSStyleDeclaration(element) {
                var currentStyle = element.currentStyle,
                    style = this,
                    property,
                    fontSize = getPixelSize(element, currentStyle, 'fontSize', null);

                for (property in currentStyle) {
                    if (Object.prototype.hasOwnProperty.call(currentStyle, property)) {
                        if (/width|height|margin.|padding.|border.+W/.test(property) && style[property] !== 'auto') {
                            style[property] = getPixelSize(element, currentStyle, property, fontSize) + 'px';
                        } else if (property === 'styleFloat') {
                            style.float = currentStyle[property];
                        } else {
                            style[property] = currentStyle[property];
                        }
                    }
                }

                setShortStyleProperty(style, 'margin');
                setShortStyleProperty(style, 'padding');
                setShortStyleProperty(style, 'border');

                style.fontSize = fontSize + 'px';

                return style;
            }

            CSSStyleDeclaration.prototype = {
                constructor: CSSStyleDeclaration,
                getPropertyPriority: function () { },
                getPropertyValue: function (prop) {
                    return this[prop] || '';
                },
                item: function () { },
                removeProperty: function () { },
                setProperty: function () { },
                getPropertyCSSValue: function () { }
            };

            function getComputedStyle(element) {
                return new CSSStyleDeclaration(element);
            }

            return getComputedStyle;
        }(this));
    }


    $(document)
        .on('keydown.xdsoftctrl', function (e) {
            if (e.keyCode === CTRLKEY) {
                ctrlDown = true;
            }
            if (e.keyCode === SHIFTKEY) {
                ctrlDown = true;
            }
        })
        .on('keyup.xdsoftctrl', function (e) {
            if (e.keyCode === CTRLKEY) {
                ctrlDown = false;
            }
            if (e.keyCode === SHIFTKEY) {
                ctrlDown = false;
            }
        });

    function accentReplace(s) {
        if (!s) { return ''; }
        var ret = '', i;
        for (i = 0; i < s.length; i += 1) {
            ret += accent_map[s.charAt(i)] || s.charAt(i);
        }
        return ret;
    }

    function escapeRegExp(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }

    function getCaretPosition(input) {
        if (!input) {
            return;
        }
        if (input.selectionStart) {
            return input.selectionStart;
        }
        if (document.selection) {
            input.focus();
            var sel = document.selection.createRange(),
                selLen = document.selection.createRange().text.length;
            sel.moveStart('character', -input.value.length);
            return sel.text.length - selLen;
        }
    }

    function setCaretPosition(input, pos) {
        if (input.setSelectionRange) {
            input.focus();
            input.setSelectionRange(pos, pos);
        } else if (input.createTextRange) {
            var range = input.createTextRange();
            range.collapse(true);
            range.moveEnd('character', pos);
            range.moveStart('character', pos);
            range.select();
        }
    }

    function isset(value) {
        return value !== undefined;
    }

    function safe_call(callback, args, callback2, defaultValue) {
        if (isset(callback) && !$.isArray(callback)) {
            return $.isFunction(callback) ? callback.apply(this, args) : defaultValue;
        }
        if (isset(callback2)) {
            return safe_call.call(this, callback2, args);
        }
        return defaultValue;
    };

    function __safe(callbackName, source, args, defaultValue) {
        var undefinedVar;
        return safe_call.call(this, (isset(this.source[source]) &&
            Object.prototype.hasOwnProperty.call(this.source[source], callbackName)) ? this.source[source][callbackName] : undefinedVar, args, function () {
                return safe_call.call(this,
                    isset(this[callbackName][source]) ?
                        this[callbackName][source] : (
                            isset(this[callbackName][0]) ?
                                this[callbackName][0] : (
                                    Object.prototype.hasOwnProperty.call(this, callbackName) ?
                                        this[callbackName] :
                                        undefinedVar
                                )
                        ),
                    args,
                    defaultSetting[callbackName][source] || defaultSetting[callbackName][0] || defaultSetting[callbackName],
                    defaultValue
                );
            }, defaultValue);
    };

    function __get(property, source) {
        if (!isset(source))
            source = 0;

        if ($.isArray(this.source) && isset(this.source[source]) && isset(this.source[source][property]))
            return this.source[source][property];

        if (isset(this[property])) {
            if ($.isArray(this[property])) {
                if (isset(this[property][source]))
                    return this[property][source];
                if (isset(this[property][0]))
                    return this[property][0];
                return null;
            }
            return this[property];
        }

        return null;
    };

    function loadRemote(url, sourceObject, done, debug) {
        if (sourceObject.xhr) {
            sourceObject.xhr.abort();
        }
        sourceObject.xhr = $.ajax($.extend(true, {
            url: url,
            type: 'GET',
            async: true,
            cache: false,
            dataType: 'json'
        }, sourceObject.ajax))

            .done(function (data) {
                done && done.apply(this, $.makeArray(arguments));
            })

            .fail(function (jqXHR, textStatus) {
                if (debug)
                    console.log("Request failed: " + textStatus);
            });
    }


    function findRight(data, query) {
        var right = false, source;

        for (source = 0; source < data.length; source += 1) {
            if (right = __safe.call(this, "findRight", source, [data[source], query, source])) {
                return { right: right, source: source };
            }
        }

        return false;
    }

    function processData(data, query) {
        var source;
        preparseData
            .call(this, data, query);

        for (source = 0; source < data.length; source += 1) {
            data[source] = __safe.call(this,
                'filter',
                source,
                [data[source], query, source],
                data[source]
            );
        }
    };


    function collectData(query, datasource, callback) {
        var options = this, source;

        if ($.isFunction(options.source)) {
            options.source.apply(options, [query, function (items) {
                datasource = [items];
                safe_call.call(options, callback, [query]);
            }, datasource, 0]);
        } else {
            for (source = 0; source < options.source.length; source += 1) {
                if ($.isArray(options.source[source])) {
                    datasource[source] = options.source[source];
                } else if ($.isFunction(options.source[source])) {
                    (function (source) {
                        options.source[source].apply(options, [query, function (items) {
                            if (!datasource[source]) {
                                datasource[source] = [];
                            }

                            if (items && $.isArray(items)) {
                                switch (options.appendMethod) {
                                    case 'replace':
                                        datasource[source] = items;
                                        break;
                                    default:
                                        datasource[source] = datasource[source].concat(items);
                                }
                            }

                            safe_call.call(options, callback, [query]);
                        }, datasource, source]);
                    }(source));
                } else {
                    switch (options.source[source].type) {
                        case 'remote':
                            if (isset(options.source[source].url)) {
                                if (!isset(options.source[source].minLength) || query.length >= options.source[source].minLength) {
                                    var url = __safe.call(options, 'replace', source, [options.source[source].url, query], '');
                                    if (!datasource[source]) {
                                        datasource[source] = [];
                                    }
                                    (function (source) {
                                        loadRemote(url, options.source[source], function (resp) {
                                            datasource[source] = resp;
                                            safe_call.call(options, callback, [query]);
                                        }, options.debug);
                                    }(source));
                                }
                            }
                            break;
                        default:
                            if (isset(options.source[source]['data'])) {
                                datasource[source] = options.source[source]['data'];
                            } else {
                                datasource[source] = options.source[source];
                            }
                    }
                }
            }
        }
        safe_call.call(options, callback, [query]);
    };

    function preparseData(data, query) {
        for (var source = 0; source < data.length; source++) {
            data[source] = __safe.call(this,
                'preparse',
                source,
                [data[source], query],
                data[source]
            );
        }
    };

    function renderData(data, query) {
        var source, i, $div, $divs = [];

        for (source = 0; source < data.length; source += 1) {
            for (i = 0; i < data[source].length; i += 1) {
                if ($divs.length >= this.limit)
                    break;

                $div = $(__safe.call(this,
                    'render', source,
                    [data[source][i], source, i, query],
                    ''
                ));

                $div.data('source', source);
                $div.data('pid', i);
                $div.data('item', data[source][i]);

                $divs.push($div);
            }
        }

        return $divs;
    };

    function getItem($div, dataset) {
        if (isset($div.data('source')) &&
            isset($div.data('pid')) &&
            isset(dataset[$div.data('source')]) &&
            isset(dataset[$div.data('source')][$div.data('pid')])
        ) {
            return dataset[$div.data('source')][$div.data('pid')];
        }
        return false;
    };

    function getValue($div, dataset) {
        var item = getItem($div, dataset);

        if (item) {
            return __safe.call(this,
                'getValue', $div.data('source'),
                [item, $div.data('source')]
            );
        } else {
            if (isset($div.data('value'))) {
                return decodeURIComponent($div.data('value'));
            } else {
                return $div.html();
            }
        }
    };

    defaultSetting = {
        minLength: 0,
        valueKey: 'value',
        titleKey: 'title',
        highlight: true,

        showHint: true,

        dropdownWidth: '100%',
        dropdownStyle: {},
        itemStyle: {},
        hintStyle: false,
        style: false,

        debug: true,
        openOnFocus: false,
        closeOnBlur: true,

        autoselect: false,

        accents: true,
        replaceAccentsForRemote: true,

        limit: 20,
        visibleLimit: 20,
        visibleHeight: 0,
        defaultHeightItem: 30,

        timeoutUpdate: 10,

        get: function (property, source) {
            return __get.call(this, property, source);
        },

        replace: [
            function (url, query) {
                if (this.replaceAccentsForRemote) {
                    query = accentReplace(query);
                }
                return url.replace('%QUERY%', encodeURIComponent(query));
            }
        ],

        equal: function (value, query) {
            return query.toLowerCase() == value.substr(0, query.length).toLowerCase();
        },

        findRight: [
            function (items, query, source) {
                var results = [], value = '', i;
                if (items) {
                    for (i = 0; i < items.length; i += 1) {
                        value = __safe.call(this, 'getValue', source, [items[i], source]);
                        if (__safe.call(this, 'equal', source, [value, query, source], false)) {
                            return items[i];
                        }
                    }
                }
                return false;
            }
        ],

        valid: [
            function (value, query) {
                if (this.accents) {
                    value = accentReplace(value);
                    query = accentReplace(query);
                }
                return value.toLowerCase().indexOf(query.toLowerCase()) != -1;

            }
        ],

        filter: [
            function (items, query, source) {
                var results = [], value = '', i;
                if (items) {
                    for (i = 0; i < items.length; i += 1) {
                        value = isset(items[i][this.get('valueKey', source)]) ? items[i][this.get('valueKey', source)] : items[i].toString();
                        if (__safe.call(this, 'valid', source, [value, query])) {
                            results.push(items[i]);
                        }
                    }
                }
                return results;
            }
        ],

        preparse: function (items) {
            return items;
        },

        getValue: [
            function (item, source) {
                return isset(item[this.get('valueKey', source)]) ? item[this.get('valueKey', source)] : item.toString();
            }
        ],

        getTitle: [
            function (item, source) {
                return isset(item[this.get('titleKey', source)]) ? item[this.get('titleKey', source)] : item.toString();
            }
        ],

        render: [
            function (item, source, pid, query) {
                var value = __safe.call(this, "getValue", source, [item, source], defaultSetting.getValue[0].call(this, item, source)),
                    title = __safe.call(this, "getTitle", source, [item, source], defaultSetting.getTitle[0].call(this, item, source)),
                    _value = '',
                    _query = '',
                    _title = '',
                    hilite_hints = '',
                    highlighted = '',
                    c, h, i,
                    spos = 0;

                if (this.highlight) {
                    if (!this.accents) {
                        title = title.replace(new RegExp('(' + escapeRegExp(query) + ')', 'i'), '<b>$1</b>');
                    } else {
                        _title = accentReplace(title).toLowerCase().replace(/[<>]+/g, ''),
                            _query = accentReplace(query).toLowerCase().replace(/[<>]+/g, '');

                        hilite_hints = _title.replace(new RegExp(escapeRegExp(_query), 'g'), '<' + _query + '>');
                        for (i = 0; i < hilite_hints.length; i += 1) {
                            c = title.charAt(spos);
                            h = hilite_hints.charAt(i);
                            if (h === '<') {
                                highlighted += '<b>';
                            } else if (h === '>') {
                                highlighted += '</b>';
                            } else {
                                spos += 1;
                                highlighted += c;
                            }
                        }
                        title = highlighted;
                    }
                }

                return '<div ' + (value == query ? 'class="active"' : '') + ' data-value="' + encodeURIComponent(value) + '">'
                    + title +
                    '</div>';
            }
        ],
        appendMethod: 'concat', // supported merge and replace
        source: [],
        afterSelected: function () {
        }
    };
    function init(that, options) {
        if ($(that).hasClass('xdsoft_input'))
            return;

        var $box = $('<div class="xdsoft_autocomplete"></div>'),
            $dropdown = $('<div class="xdsoft_autocomplete_dropdown"></div>'),
            $hint = $('<input readonly class="xdsoft_autocomplete_hint"/>'),
            $input = $(that),
            timer1 = 0,
            intervalForVisibility,
            dataset = [],
            iOpen = false,
            value = '',
            currentValue = '',
            currentSelect = '',
            active = null,
            pos = 0;

        //it can be used to access settings
        $input.data('autocomplete_options', options);

        $dropdown
            .on('mousedown', function (e) {
                e.preventDefault();
                e.stopPropagation();
            })
            .on('updatescroll.xdsoft', function () {
                var _act = $dropdown.find('.active');
                if (!_act.length) {
                    return;
                }

                var top = _act.position().top,
                    actHght = _act.outerHeight(true),
                    scrlTop = $dropdown.scrollTop(),
                    hght = $dropdown.height();

                if (top < 0) {
                    $dropdown.scrollTop(scrlTop - Math.abs(top));
                } else if (top + actHght > hght) {
                    $dropdown.scrollTop(scrlTop + top + actHght - hght);
                }
            });

        $box
            .css({
                'display': $input.css('display'),
                'width': $input.css('width')
            });

        if (options.style)
            $box.css(options.style);

        $input
            .addClass('xdsoft_input')
            .attr('autocomplete', 'off');

        var xDown = null;
        var yDown = null;
        var isSwipe = false;
        $dropdown
            .on('mousemove', 'div', function () {
                if ($(this).hasClass('active'))
                    return true;
                $dropdown.find('div').removeClass('active');
                $(this).addClass('active');
            })
            .on('mousedown', 'div', function (e) {
                $dropdown.find('div').removeClass('active');
                $(this).addClass('active');
                $input.trigger('pick.xdsoft');
            })
            .on('touchstart', 'div', function (e) {
                xDown = e.originalEvent.touches[0].clientX;
                yDown = e.originalEvent.touches[0].clientY;
            })
            .on('touchend', 'div', function (e) {
                if (isSwipe === false) {
                    $dropdown.find('div').removeClass('active');
                    $(this).addClass('active');
                    $input.trigger('pick.xdsoft');
                }

                isSwipe = false;
            })
            .on('touchmove', 'div', function (e) {
                if (!xDown || !yDown) {
                    return;
                }

                var xUp = e.originalEvent.touches[0].clientX;
                var yUp = e.originalEvent.touches[0].clientY;

                var xDiff = xDown - xUp;
                var yDiff = yDown - yUp;

                if (Math.abs(xDiff) > Math.abs(yDiff)) {
                    if (xDiff > 0) {
                        isSwipe = 'left';
                    } else {
                        isSwipe = 'right';
                    }
                } else {
                    if (yDiff > 0) {
                        isSwipe = 'top';
                    } else {
                        isSwipe = 'bottm';
                    }
                }

                xDown = null;
                yDown = null;
            });

        function manageData() {
            if ($input.val() != currentValue) {
                currentValue = $input.val();
            } else {
                return;
            }
            if (currentValue.length < options.minLength) {
                $input.trigger('close.xdsoft');
                return;
            }
            collectData.call(options, currentValue, dataset, function (query) {
                if (query != currentValue) {
                    return;
                }
                var right;
                processData.call(options, dataset, query);

                $input.trigger('updateContent.xdsoft');

                if (options.showHint && currentValue.length && currentValue.length <= $input.prop('size') && (right = findRight.call(options, dataset, currentValue))) {
                    var title = __safe.call(options, 'getTitle', right.source, [right.right, right.source]);
                    title = query + title.substr(query.length);
                    $hint.val(title);
                } else {
                    $hint.val('');
                }
            });

            return;
        }

        function manageKey(event) {
            var key = event.keyCode, right;

            switch (key) {
                case AKEY: case CKEY: case VKEY: case ZKEY: case YKEY:
                    if (event.shiftKey || event.ctrlKey) {
                        return true;
                    }
                    break;
                case SHIFTKEY:
                case CTRLKEY:
                    return true;
                    break;
                case ARROWRIGHT:
                case ARROWLEFT:
                    if (ctrlDown || shiftDown || event.shiftKey || event.ctrlKey) {
                        return true;
                    }
                    value = $input.val();
                    pos = getCaretPosition($input[0]);
                    if (key === ARROWRIGHT && pos === value.length) {
                        if (right = findRight.call(options, dataset, value)) {
                            $input.trigger('pick.xdsoft', [
                                __safe.call(options,
                                    'getValue', right.source,
                                    [right.right, right.source]
                                )
                            ]);
                        } else {
                            $input.trigger('pick.xdsoft');
                        }
                        event.preventDefault();
                        return false;
                    }
                    return true;
                case TAB:
                    return true;
                case ENTER:
                    if (iOpen) {
                        if (options.autoselect) {
                            $input.trigger('pick.xdsoft');
                        } else if (!options.autoselect && active) {
                            $input.trigger('pick.xdsoft');
                        } else {
                            $input.trigger('close.xdsoft');
                            return true;
                        }
                        event.preventDefault();
                        return false;
                    } else {
                        return true;
                    }
                    break;
                case ESC:
                    $input
                        .val(currentValue)
                        .trigger('close.xdsoft');
                    event.preventDefault();
                    return false;
                case ARROWDOWN:
                case ARROWUP:
                    if (!iOpen) {
                        $input.trigger('open.xdsoft');
                        $input.trigger('updateContent.xdsoft');
                        event.preventDefault();
                        return false;
                    }

                    active = $dropdown.find('div.active');

                    var next = key == ARROWDOWN ? 'next' : 'prev', timepick = true;

                    if (active.length) {
                        active.removeClass('active');
                        if (active[next]().length) {
                            active[next]().addClass('active');
                        } else {
                            $input.val(currentValue);
                            timepick = false;
                        }
                    } else {
                        $dropdown.children().eq(key == ARROWDOWN ? 0 : -1).addClass('active');
                    }

                    if (timepick) {
                        $input.trigger('timepick.xdsoft');
                    }

                    $dropdown
                        .trigger('updatescroll.xdsoft');

                    event.preventDefault();
                    return false;
            }
            return;
        }

        $input
            .data('xdsoft_autocomplete', dataset)
            .after($box)
            .on('pick.xdsoft', function (event, _value) {

                $input.trigger('timepick.xdsoft', _value);

                currentSelect = currentValue = $input.val();

                $input.trigger('close.xdsoft');

                //currentInput = false;

                active = $dropdown.find('div.active').eq(0);

                if (!active.length)
                    active = $dropdown.children().first();

                $input.trigger('selected.xdsoft', [getItem(active, dataset)]);

                if (options.afterSelected)
                    options.afterSelected();
            })
            .on('timepick.xdsoft', function (event, _value) {
                active = $dropdown.find('div.active');

                if (!active.length)
                    active = $dropdown.children().first();

                if (active.length) {
                    if (!isset(_value)) {
                        $input.val(getValue.call(options, active, dataset));
                    } else {
                        $input.val(_value);
                    }
                    $input.trigger('autocompleted.xdsoft', [getItem(active, dataset)]);
                    $hint.val('');
                    setCaretPosition($input[0], $input.val().length);
                }
            })
            .on('keydown.xdsoft input.xdsoft cut.xdsoft paste.xdsoft', function (event) {
                var ret = manageKey(event);

                if (ret === false || ret === true) {
                    return ret;
                }

                setTimeout(function () {
                    manageData();
                }, 1);

                manageData();
            })
            .on('change.xdsoft', function (event) {
                currentValue = $input.val();
            });

        currentValue = $input.val();

        collectData.call(options, $input.val(), dataset, function (query) {
            processData.call(options, dataset, query);
        });

        if (options.openOnFocus) {
            $input.on('focusin.xdsoft', function () {
                $input.trigger('open.xdsoft');
                $input.trigger('updateContent.xdsoft');
            });
        }

        if (options.closeOnBlur)
            $input.on('focusout.xdsoft', function () {
                $input.trigger('close.xdsoft');
            });

        $box
            .append($input)
            .append($dropdown);


        var olderBackground = false,
            timerUpdate = 0;

        $input
            .on('updateHelperPosition.xdsoft', function () {
                clearTimeout(timerUpdate);
                timerUpdate = setTimeout(function () {
                    $box.css({
                        'display': $input.css('display'),
                        'width': $input.css('width')
                    });
                    $dropdown.css($.extend(true, {
                        left: $input.position().left,
                        top: $input.position().top + parseInt($input.css('marginTop')) + parseInt($input[0].offsetHeight),
                        marginLeft: $input.css('marginLeft'),
                        marginRight: $input.css('marginRight'),
                        width: options.dropdownWidth == '100%' ? $input[0].offsetWidth : options.dropdownWidth
                    }, options.dropdownStyle));

                    if (options.showHint) {
                        var style = getComputedStyle($input[0], "");

                        $hint[0].style.cssText = style.cssText;

                        $hint.css({
                            'box-sizing': style.boxSizing,
                            borderStyle: 'solid',
                            borderCollapse: style.borderCollapse,
                            borderLeftWidth: style.borderLeftWidth,
                            borderRightWidth: style.borderRightWidth,
                            borderTopWidth: style.borderTopWidth,
                            borderBottomWidth: style.borderBottomWidth,
                            paddingBottom: style.paddingBottom,
                            marginBottom: style.marginBottom,
                            paddingTop: style.paddingTop,
                            marginTop: style.marginTop,
                            paddingLeft: style.paddingLeft,
                            marginLeft: style.marginLeft,
                            paddingRight: style.paddingRight,
                            marginRight: style.marginRight,
                            maxHeight: style.maxHeight,
                            minHeight: style.minHeight,
                            maxWidth: style.maxWidth,
                            minWidth: style.minWidth,
                            width: style.width,
                            letterSpacing: style.letterSpacing,
                            lineHeight: style.lineHeight,
                            outlineWidth: style.outlineWidth,
                            fontFamily: style.fontFamily,
                            fontVariant: style.fontVariant,
                            fontStyle: $input.css('fontStyle'),
                            fontSize: $input.css('fontSize'),
                            fontWeight: $input.css('fontWeight'),
                            flex: style.flex,
                            justifyContent: style.justifyContent,
                            borderRadius: style.borderRadius,
                            '-webkit-box-shadow': 'none',
                            'box-shadow': 'none'
                        });

                        $input.css('font-size', $input.css('fontSize'))// fix bug with em font size

                        $hint.innerHeight($input.innerHeight());

                        $hint.css($.extend(true, {
                            position: 'absolute',
                            zIndex: '1',
                            borderColor: 'transparent',
                            outlineColor: 'transparent',
                            left: $input.position().left,
                            top: $input.position().top,
                            background: $input.css('background')
                        }, options.hintStyle));

                        // This code is not needed because we are already setting $hint in upper line
                        // 						if( olderBackground !== false ){
                        // 							$hint.css('background',olderBackground);
                        // 						} else {
                        // 							olderBackground = $input.css('background');
                        // 						}

                        try {
                            $input[0].style.setProperty('background', 'transparent', 'important');
                        } catch (e) {
                            $input.css('background', 'transparent')
                        }

                        $box
                            .append($hint);
                    }
                }, options.timeoutUpdate || 1);
            });

        if ($input.is(':visible')) {
            $input
                .trigger('updateHelperPosition.xdsoft');
        } else {
            intervalForVisibility = setInterval(function () {
                if ($input.is(':visible')) {
                    $input
                        .trigger('updateHelperPosition.xdsoft');
                    clearInterval(intervalForVisibility);
                }
            }, 100);
        }

        $(window).on('resize', function () {
            $box.css({
                'width': 'auto'
            });
            $input
                .trigger('updateHelperPosition.xdsoft');
        })

        $input
            .on('close.xdsoft', function () {
                if (!iOpen) {
                    return;
                }

                $dropdown
                    .hide();

                $hint
                    .val('');

                if (!options.autoselect) {
                    $input.val(currentValue);
                }

                iOpen = false;

                //currentInput = false;
            })

            .on('updateContent.xdsoft', function () {
                var out = renderData.call(options, dataset, $input.val()),
                    hght = 10;

                if (out.length) {
                    $input.trigger('open.xdsoft');
                } else {
                    $input.trigger('close.xdsoft');
                    return;
                }

                $(out).each(function () {
                    this.css($.extend(true, {
                        paddingLeft: $input.css('paddingLeft'),
                        paddingRight: $input.css('paddingRight')
                    }, options.itemStyle));
                });

                $dropdown
                    .html(out);

                if (options.visibleHeight) {
                    hght = options.visibleHeight;
                } else {
                    hght = options.visibleLimit * ((out[0] ? out[0].outerHeight(true) : 0) || options.defaultHeightItem) + 5;
                }

                $dropdown
                    .css('maxHeight', hght + 'px')
            })

            .on('open.xdsoft', function () {
                if (iOpen)
                    return;

                $dropdown
                    .show();

                iOpen = true;

                //currentInput = $input;
            })
            .on('destroy.xdsoft', function () {
                $input.removeClass('xdsoft');
                $box.after($input);
                $box.remove();
                clearTimeout(timer1);
                clearTimeout(intervalForVisibility);
                //currentInput = false;
                $input.data('xdsoft_autocomplete', null);
                $input
                    .off('.xdsoft')
            });
    };

    publics = {
        destroy: function () {
            return this.trigger('destroy.xdsoft');
        },
        update: function () {
            return this.trigger('updateHelperPosition.xdsoft');
        },
        options: function (_options) {
            if (this.data('autocomplete_options') && $.isPlainObject(_options)) {
                this.data('autocomplete_options', $.extend(true, this.data('autocomplete_options'), _options));
            }
            return this;
        },
        setSource: function (_newsource, id) {
            if (this.data('autocomplete_options') && ($.isPlainObject(_newsource) || $.isFunction(_newsource) || $.isArray(_newsource))) {
                var options = this.data('autocomplete_options'),
                    dataset = this.data('xdsoft_autocomplete'),
                    source = options.source;
                if (id !== undefined && !isNaN(id)) {
                    if ($.isPlainObject(_newsource) || $.isArray(_newsource)) {
                        source[id] = $.extend(true, $.isArray(_newsource) ? [] : {}, _newsource);
                    } else {
                        source[id] = _newsource;
                    }
                } else {
                    if ($.isFunction(_newsource)) {
                        this.data('autocomplete_options').source = _newsource;
                    } else {
                        $.extend(true, source, _newsource);
                    }
                }

                collectData.call(options, this.val(), dataset, function (query) {
                    processData.call(options, dataset, query);
                });
            }
            return this;
        },
        getSource: function (id) {
            if (this.data('autocomplete_options')) {
                var source = this.data('autocomplete_options').source;
                if (id !== undefined && !isNaN(id) && source[id]) {
                    return source[id];
                } else {
                    return source;
                }
            }
            return null;
        }
    };

    $.fn.autocomplete = function (_options, _second, _third) {
        if ($.type(_options) === 'string' && publics[_options]) {
            return publics[_options].call(this, _second, _third);
        }
        return this.each(function () {
            var options = $.extend(true, {}, defaultSetting, _options);
            init(this, options);
        });
    };
}(jQuery));

var SelectPure = function () { "use strict"; function e(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function t(e, t) { for (var n = 0; n < t.length; n++) { var i = t[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i) } } function n(e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } function i(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function s(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(e); t && (i = i.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, i) } return n } function o(e) { for (var t = 1; t < arguments.length; t++) { var n = null != arguments[t] ? arguments[t] : {}; t % 2 ? s(Object(n), !0).forEach((function (t) { i(e, t, n[t]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s(Object(n)).forEach((function (t) { Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t)) })) } return e } function a(e) { return function (e) { if (Array.isArray(e)) return l(e) }(e) || function (e) { if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e) }(e) || function (e, t) { if (!e) return; if ("string" == typeof e) return l(e, t); var n = Object.prototype.toString.call(e).slice(8, -1); "Object" === n && e.constructor && (n = e.constructor.name); if ("Map" === n || "Set" === n) return Array.from(e); if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return l(e, t) }(e) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function l(e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, i = new Array(t); n < t; n++)i[n] = e[n]; return i } var c = { value: "data-value", disabled: "data-disabled", class: "class", type: "type" }, r = function () { function t(n) { var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; return e(this, t), this._node = n instanceof HTMLElement ? n : document.createElement(n), this._config = { i18n: s }, this._setAttributes(i), i.textContent && this._setTextContent(i.textContent), this } return n(t, [{ key: "get", value: function () { return this._node } }, { key: "append", value: function (e) { return this._node.appendChild(e), this } }, { key: "addClass", value: function (e) { return this._node.classList.add(e), this } }, { key: "removeClass", value: function (e) { return this._node.classList.remove(e), this } }, { key: "toggleClass", value: function (e) { return this._node.classList.toggle(e), this } }, { key: "addEventListener", value: function (e, t) { return this._node.addEventListener(e, t), this } }, { key: "removeEventListener", value: function (e, t) { return this._node.removeEventListener(e, t), this } }, { key: "setText", value: function (e) { return this._setTextContent(e), this } }, { key: "getHeight", value: function () { return window.getComputedStyle(this._node).height } }, { key: "setTop", value: function (e) { return this._node.style.top = "".concat(e, "px"), this } }, { key: "focus", value: function () { return this._node.focus(), this } }, { key: "_setTextContent", value: function (e) { this._node.textContent = e } }, { key: "_setAttributes", value: function (e) { for (var t in e) c[t] && e[t] && this._setAttribute(c[t], e[t]) } }, { key: "_setAttribute", value: function (e, t) { this._node.setAttribute(e, t) } }]), t }(), u = { select: "select-pure__select", dropdownShown: "select-pure__select--opened", multiselect: "select-pure__select--multiple", label: "select-pure__label", placeholder: "select-pure__placeholder", dropdown: "select-pure__options", option: "select-pure__option", optionDisabled: "select-pure__option--disabled", autocompleteInput: "select-pure__autocomplete", selectedLabel: "select-pure__selected-label", selectedOption: "select-pure__option--selected", placeholderHidden: "select-pure__placeholder--hidden", optionHidden: "select-pure__option--hidden" }; return function () { function t(n, i) { e(this, t), this._config = o(o({}, i), {}, { classNames: o(o({}, u), i.classNames), disabledOptions: [] }), this._state = { opened: !1 }, this._icons = [], this._boundHandleClick = this._handleClick.bind(this), this._boundUnselectOption = this._unselectOption.bind(this), this._boundSortOptions = this._sortOptions.bind(this), this._body = new r(document.body), this._create(n), this._config.value && this._setValue() } return n(t, [{ key: "value", value: function () { return this._config.value } }, { key: "reset", value: function () { this._config.value = this._config.multiple ? [] : null, this._setValue() } }, { key: "_create", value: function (e) { var t = "string" == typeof e ? document.querySelector(e) : e; this._parent = new r(t), this._select = new r("div", { class: this._config.classNames.select }), this._label = new r("span", { class: this._config.classNames.label }), this._optionsWrapper = new r("div", { class: this._config.classNames.dropdown }), this._config.multiple && this._select.addClass(this._config.classNames.multiselect), this._options = this._generateOptions(), this._select.addEventListener("click", this._boundHandleClick), this._select.append(this._label.get()), this._select.append(this._optionsWrapper.get()), this._parent.append(this._select.get()), this._placeholder = new r("span", { class: this._config.classNames.placeholder, textContent: this._config.placeholder }), this._select.append(this._placeholder.get()) } }, { key: "_generateOptions", value: function () { var e = this; return this._config.autocomplete && (this._autocomplete = new r("input", { class: this._config.classNames.autocompleteInput, type: "text" }), this._autocomplete.addEventListener("input", this._boundSortOptions), this._optionsWrapper.append(this._autocomplete.get())), this._config.options.map((function (t) { var n = new r("div", { class: "".concat(e._config.classNames.option).concat(t.disabled ? " " + e._config.classNames.optionDisabled : ""), value: t.value, textContent: t.label, disabled: t.disabled }); return t.disabled && e._config.disabledOptions.push(String(t.value)), e._optionsWrapper.append(n.get()), n })) } }, { key: "_handleClick", value: function (e) { if (e.stopPropagation(), e.target.className !== this._config.classNames.autocompleteInput) { if (this._state.opened) { var t = this._options.find((function (t) { return t.get() === e.target })); return t && this._setValue(t.get().getAttribute("data-value"), !0), this._select.removeClass(this._config.classNames.dropdownShown), this._body.removeEventListener("click", this._boundHandleClick), this._select.addEventListener("click", this._boundHandleClick), void (this._state.opened = !1) } e.target.className !== this._config.icon && (this._select.addClass(this._config.classNames.dropdownShown), this._body.addEventListener("click", this._boundHandleClick), this._select.removeEventListener("click", this._boundHandleClick), this._state.opened = !0, this._autocomplete && this._autocomplete.focus()) } } }, { key: "_setValue", value: function (e, t, n) { var i = this; if (!(this._config.disabledOptions.indexOf(e) > -1)) { if (e && !n && (this._config.value = this._config.multiple ? [].concat(a(this._config.value || []), [e]) : e), e && n && (this._config.value = e), this._options.forEach((function (e) { e.removeClass(i._config.classNames.selectedOption) })), this._placeholder.removeClass(this._config.classNames.placeholderHidden), this._config.multiple) { var s = this._config.value.map((function (e) { var t = i._config.options.find((function (t) { return t.value === e })); return i._options.find((function (e) { return e.get().getAttribute("data-value") === t.value.toString() })).addClass(i._config.classNames.selectedOption), t })); return s.length && this._placeholder.addClass(this._config.classNames.placeholderHidden), void this._selectOptions(s, t) } var o = this._config.value ? this._config.options.find((function (e) { return e.value.toString() === i._config.value })) : this._config.options[0], l = this._options.find((function (e) { return e.get().getAttribute("data-value") === o.value.toString() })); this._config.value ? (l.addClass(this._config.classNames.selectedOption), this._placeholder.addClass(this._config.classNames.placeholderHidden), this._selectOption(o, t)) : this._label.setText("") } } }, { key: "_selectOption", value: function (e, t) { this._selectedOption = e, this._label.setText(e.label), this._config.onChange && t && this._config.onChange(e.value) } }, { key: "_selectOptions", value: function (e, t) { var n = this; this._label.setText(""), this._icons = e.map((function (e) { var t = new r("span", { class: n._config.classNames.selectedLabel, textContent: e.label }), i = new r(n._config.inlineIcon ? n._config.inlineIcon.cloneNode(!0) : "i", { class: n._config.icon, value: e.value }); return i.addEventListener("click", n._boundUnselectOption), t.append(i.get()), n._label.append(t.get()), i.get() })), t && this._optionsWrapper.setTop(Number(this._select.getHeight().split("px")[0]) + 5), this._config.onChange && t && this._config.onChange(this._config.value) } }, { key: "_unselectOption", value: function (e) { var t = a(this._config.value), n = t.indexOf(e.target.getAttribute("data-value")); -1 !== n && t.splice(n, 1), this._setValue(t, !0, !0) } }, { key: "_sortOptions", value: function (e) { var t = this; this._options.forEach((function (n) { n.get().textContent.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "").startsWith(e.target.value.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "")) ? n.removeClass(t._config.classNames.optionHidden) : n.addClass(t._config.classNames.optionHidden) })) } }]), t }() }();


/*!
FullCalendar v5.10.1
Docs & License: https://fullcalendar.io/
(c) 2021 Adam Shaw
*/
var FullCalendar = function (e) { "use strict"; var t = function (e, n) { return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (e, t) { e.__proto__ = t } || function (e, t) { for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]) })(e, n) }; function n(e, n) { if ("function" != typeof n && null !== n) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null"); function r() { this.constructor = e } t(e, n), e.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r) } var r = function () { return (r = Object.assign || function (e) { for (var t, n = 1, r = arguments.length; n < r; n++)for (var o in t = arguments[n]) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]); return e }).apply(this, arguments) }; function o(e, t, n) { if (n || 2 === arguments.length) for (var r, o = 0, i = t.length; o < i; o++)!r && o in t || (r || (r = Array.prototype.slice.call(t, 0, o)), r[o] = t[o]); return e.concat(r || t) } var i, a, s, l, u, c = {}, d = [], p = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i; function f(e, t) { for (var n in t) e[n] = t[n]; return e } function h(e) { var t = e.parentNode; t && t.removeChild(e) } function v(e, t, n) { var r, o, i, a = arguments, s = {}; for (i in t) "key" == i ? r = t[i] : "ref" == i ? o = t[i] : s[i] = t[i]; if (arguments.length > 3) for (n = [n], i = 3; i < arguments.length; i++)n.push(a[i]); if (null != n && (s.children = n), "function" == typeof e && null != e.defaultProps) for (i in e.defaultProps) void 0 === s[i] && (s[i] = e.defaultProps[i]); return g(e, s, r, o, null) } function g(e, t, n, r, o) { var a = { type: e, props: t, key: n, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o ? ++i.__v : o }; return null != i.vnode && i.vnode(a), a } function m(e) { return e.children } function y(e, t) { this.props = e, this.context = t } function E(e, t) { if (null == t) return e.__ ? E(e.__, e.__.__k.indexOf(e) + 1) : null; for (var n; t < e.__k.length; t++)if (null != (n = e.__k[t]) && null != n.__e) return n.__e; return "function" == typeof e.type ? E(e) : null } function S(e) { var t, n; if (null != (e = e.__) && null != e.__c) { for (e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++)if (null != (n = e.__k[t]) && null != n.__e) { e.__e = e.__c.base = n.__e; break } return S(e) } } function b(e) { (!e.__d && (e.__d = !0) && a.push(e) && !D.__r++ || l !== i.debounceRendering) && ((l = i.debounceRendering) || s)(D) } function D() { for (var e; D.__r = a.length;)e = a.sort((function (e, t) { return e.__v.__b - t.__v.__b })), a = [], e.some((function (e) { var t, n, r, o, i, a; e.__d && (i = (o = (t = e).__v).__e, (a = t.__P) && (n = [], (r = f({}, o)).__v = o.__v + 1, I(a, o, r, t.__n, void 0 !== a.ownerSVGElement, null != o.__h ? [i] : null, n, null == i ? E(o) : i, o.__h), P(n, o), o.__e != i && S(o))) })) } function C(e, t, n, r, o, i, a, s, l, u) { var p, f, h, v, y, S, b, D = r && r.__k || d, C = D.length; for (n.__k = [], p = 0; p < t.length; p++)if (null != (v = n.__k[p] = null == (v = t[p]) || "boolean" == typeof v ? null : "string" == typeof v || "number" == typeof v || "bigint" == typeof v ? g(null, v, null, null, v) : Array.isArray(v) ? g(m, { children: v }, null, null, null) : v.__b > 0 ? g(v.type, v.props, v.key, null, v.__v) : v)) { if (v.__ = n, v.__b = n.__b + 1, null === (h = D[p]) || h && v.key == h.key && v.type === h.type) D[p] = void 0; else for (f = 0; f < C; f++) { if ((h = D[f]) && v.key == h.key && v.type === h.type) { D[f] = void 0; break } h = null } I(e, v, h = h || c, o, i, a, s, l, u), y = v.__e, (f = v.ref) && h.ref != f && (b || (b = []), h.ref && b.push(h.ref, null, v), b.push(f, v.__c || y, v)), null != y ? (null == S && (S = y), "function" == typeof v.type && null != v.__k && v.__k === h.__k ? v.__d = l = w(v, l, e) : l = _(e, v, h, D, y, l), u || "option" !== n.type ? "function" == typeof n.type && (n.__d = l) : e.value = "") : l && h.__e == l && l.parentNode != e && (l = E(h)) } for (n.__e = S, p = C; p--;)null != D[p] && ("function" == typeof n.type && null != D[p].__e && D[p].__e == n.__d && (n.__d = E(r, p + 1)), O(D[p], D[p])); if (b) for (p = 0; p < b.length; p++)H(b[p], b[++p], b[++p]) } function w(e, t, n) { var r, o; for (r = 0; r < e.__k.length; r++)(o = e.__k[r]) && (o.__ = e, t = "function" == typeof o.type ? w(o, t, n) : _(n, o, o, e.__k, o.__e, t)); return t } function R(e, t) { return t = t || [], null == e || "boolean" == typeof e || (Array.isArray(e) ? e.some((function (e) { R(e, t) })) : t.push(e)), t } function _(e, t, n, r, o, i) { var a, s, l; if (void 0 !== t.__d) a = t.__d, t.__d = void 0; else if (null == n || o != i || null == o.parentNode) e: if (null == i || i.parentNode !== e) e.appendChild(o), a = null; else { for (s = i, l = 0; (s = s.nextSibling) && l < r.length; l += 2)if (s == o) break e; e.insertBefore(o, i), a = i } return void 0 !== a ? a : o.nextSibling } function T(e, t, n) { "-" === t[0] ? e.setProperty(t, n) : e[t] = null == n ? "" : "number" != typeof n || p.test(t) ? n : n + "px" } function k(e, t, n, r, o) { var i; e: if ("style" === t) if ("string" == typeof n) e.style.cssText = n; else { if ("string" == typeof r && (e.style.cssText = r = ""), r) for (t in r) n && t in n || T(e.style, t, ""); if (n) for (t in n) r && n[t] === r[t] || T(e.style, t, n[t]) } else if ("o" === t[0] && "n" === t[1]) i = t !== (t = t.replace(/Capture$/, "")), t = t.toLowerCase() in e ? t.toLowerCase().slice(2) : t.slice(2), e.l || (e.l = {}), e.l[t + i] = n, n ? r || e.addEventListener(t, i ? M : x, i) : e.removeEventListener(t, i ? M : x, i); else if ("dangerouslySetInnerHTML" !== t) { if (o) t = t.replace(/xlink[H:h]/, "h").replace(/sName$/, "s"); else if ("href" !== t && "list" !== t && "form" !== t && "tabIndex" !== t && "download" !== t && t in e) try { e[t] = null == n ? "" : n; break e } catch (e) { } "function" == typeof n || (null != n && (!1 !== n || "a" === t[0] && "r" === t[1]) ? e.setAttribute(t, n) : e.removeAttribute(t)) } } function x(e) { this.l[e.type + !1](i.event ? i.event(e) : e) } function M(e) { this.l[e.type + !0](i.event ? i.event(e) : e) } function I(e, t, n, r, o, a, s, l, u) { var c, d, p, h, v, g, E, S, b, D, w, R = t.type; if (void 0 !== t.constructor) return null; null != n.__h && (u = n.__h, l = t.__e = n.__e, t.__h = null, a = [l]), (c = i.__b) && c(t); try { e: if ("function" == typeof R) { if (S = t.props, b = (c = R.contextType) && r[c.__c], D = c ? b ? b.props.value : c.__ : r, n.__c ? E = (d = t.__c = n.__c).__ = d.__E : ("prototype" in R && R.prototype.render ? t.__c = d = new R(S, D) : (t.__c = d = new y(S, D), d.constructor = R, d.render = A), b && b.sub(d), d.props = S, d.state || (d.state = {}), d.context = D, d.__n = r, p = d.__d = !0, d.__h = []), null == d.__s && (d.__s = d.state), null != R.getDerivedStateFromProps && (d.__s == d.state && (d.__s = f({}, d.__s)), f(d.__s, R.getDerivedStateFromProps(S, d.__s))), h = d.props, v = d.state, p) null == R.getDerivedStateFromProps && null != d.componentWillMount && d.componentWillMount(), null != d.componentDidMount && d.__h.push(d.componentDidMount); else { if (null == R.getDerivedStateFromProps && S !== h && null != d.componentWillReceiveProps && d.componentWillReceiveProps(S, D), !d.__e && null != d.shouldComponentUpdate && !1 === d.shouldComponentUpdate(S, d.__s, D) || t.__v === n.__v) { d.props = S, d.state = d.__s, t.__v !== n.__v && (d.__d = !1), d.__v = t, t.__e = n.__e, t.__k = n.__k, t.__k.forEach((function (e) { e && (e.__ = t) })), d.__h.length && s.push(d); break e } null != d.componentWillUpdate && d.componentWillUpdate(S, d.__s, D), null != d.componentDidUpdate && d.__h.push((function () { d.componentDidUpdate(h, v, g) })) } d.context = D, d.props = S, d.state = d.__s, (c = i.__r) && c(t), d.__d = !1, d.__v = t, d.__P = e, c = d.render(d.props, d.state, d.context), d.state = d.__s, null != d.getChildContext && (r = f(f({}, r), d.getChildContext())), p || null == d.getSnapshotBeforeUpdate || (g = d.getSnapshotBeforeUpdate(h, v)), w = null != c && c.type === m && null == c.key ? c.props.children : c, C(e, Array.isArray(w) ? w : [w], t, n, r, o, a, s, l, u), d.base = t.__e, t.__h = null, d.__h.length && s.push(d), E && (d.__E = d.__ = null), d.__e = !1 } else null == a && t.__v === n.__v ? (t.__k = n.__k, t.__e = n.__e) : t.__e = N(n.__e, t, n, r, o, a, s, u); (c = i.diffed) && c(t) } catch (e) { t.__v = null, (u || null != a) && (t.__e = l, t.__h = !!u, a[a.indexOf(l)] = null), i.__e(e, t, n) } } function P(e, t) { i.__c && i.__c(t, e), e.some((function (t) { try { e = t.__h, t.__h = [], e.some((function (e) { e.call(t) })) } catch (e) { i.__e(e, t.__v) } })) } function N(e, t, n, r, o, i, a, s) { var l, u, p, f, v = n.props, g = t.props, m = t.type, y = 0; if ("svg" === m && (o = !0), null != i) for (; y < i.length; y++)if ((l = i[y]) && (l === e || (m ? l.localName == m : 3 == l.nodeType))) { e = l, i[y] = null; break } if (null == e) { if (null === m) return document.createTextNode(g); e = o ? document.createElementNS("http://www.w3.org/2000/svg", m) : document.createElement(m, g.is && g), i = null, s = !1 } if (null === m) v === g || s && e.data === g || (e.data = g); else { if (i = i && d.slice.call(e.childNodes), u = (v = n.props || c).dangerouslySetInnerHTML, p = g.dangerouslySetInnerHTML, !s) { if (null != i) for (v = {}, f = 0; f < e.attributes.length; f++)v[e.attributes[f].name] = e.attributes[f].value; (p || u) && (p && (u && p.__html == u.__html || p.__html === e.innerHTML) || (e.innerHTML = p && p.__html || "")) } if (function (e, t, n, r, o) { var i; for (i in n) "children" === i || "key" === i || i in t || k(e, i, null, n[i], r); for (i in t) o && "function" != typeof t[i] || "children" === i || "key" === i || "value" === i || "checked" === i || n[i] === t[i] || k(e, i, t[i], n[i], r) }(e, g, v, o, s), p) t.__k = []; else if (y = t.props.children, C(e, Array.isArray(y) ? y : [y], t, n, r, o && "foreignObject" !== m, i, a, e.firstChild, s), null != i) for (y = i.length; y--;)null != i[y] && h(i[y]); s || ("value" in g && void 0 !== (y = g.value) && (y !== e.value || "progress" === m && !y) && k(e, "value", y, v.value, !1), "checked" in g && void 0 !== (y = g.checked) && y !== e.checked && k(e, "checked", y, v.checked, !1)) } return e } function H(e, t, n) { try { "function" == typeof e ? e(t) : e.current = t } catch (e) { i.__e(e, n) } } function O(e, t, n) { var r, o, a; if (i.unmount && i.unmount(e), (r = e.ref) && (r.current && r.current !== e.__e || H(r, null, t)), n || "function" == typeof e.type || (n = null != (o = e.__e)), e.__e = e.__d = void 0, null != (r = e.__c)) { if (r.componentWillUnmount) try { r.componentWillUnmount() } catch (e) { i.__e(e, t) } r.base = r.__P = null } if (r = e.__k) for (a = 0; a < r.length; a++)r[a] && O(r[a], t, n); null != o && h(o) } function A(e, t, n) { return this.constructor(e, n) } function L(e, t, n) { var r, o, a; i.__ && i.__(e, t), o = (r = "function" == typeof n) ? null : n && n.__k || t.__k, a = [], I(t, e = (!r && n || t).__k = v(m, null, [e]), o || c, c, void 0 !== t.ownerSVGElement, !r && n ? [n] : o ? null : t.firstChild ? d.slice.call(t.childNodes) : null, a, !r && n ? n : o ? o.__e : t.firstChild, r), P(a, e) } i = { __e: function (e, t) { for (var n, r, o; t = t.__;)if ((n = t.__c) && !n.__) try { if ((r = n.constructor) && null != r.getDerivedStateFromError && (n.setState(r.getDerivedStateFromError(e)), o = n.__d), null != n.componentDidCatch && (n.componentDidCatch(e), o = n.__d), o) return n.__E = n } catch (t) { e = t } throw e }, __v: 0 }, y.prototype.setState = function (e, t) { var n; n = null != this.__s && this.__s !== this.state ? this.__s : this.__s = f({}, this.state), "function" == typeof e && (e = e(f({}, n), this.props)), e && f(n, e), null != e && this.__v && (t && this.__h.push(t), b(this)) }, y.prototype.forceUpdate = function (e) { this.__v && (this.__e = !0, e && this.__h.push(e), b(this)) }, y.prototype.render = m, a = [], s = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, D.__r = 0, u = 0; var U, W = [], V = i.__b, F = i.__r, B = i.diffed, z = i.__c, j = i.unmount; function G() { W.forEach((function (e) { if (e.__P) try { e.__H.__h.forEach(Y), e.__H.__h.forEach(Z), e.__H.__h = [] } catch (t) { e.__H.__h = [], i.__e(t, e.__v) } })), W = [] } i.__b = function (e) { V && V(e) }, i.__r = function (e) { F && F(e); var t = e.__c.__H; t && (t.__h.forEach(Y), t.__h.forEach(Z), t.__h = []) }, i.diffed = function (e) { B && B(e); var t = e.__c; t && t.__H && t.__H.__h.length && (1 !== W.push(t) && U === i.requestAnimationFrame || ((U = i.requestAnimationFrame) || function (e) { var t, n = function () { clearTimeout(r), q && cancelAnimationFrame(t), setTimeout(e) }, r = setTimeout(n, 100); q && (t = requestAnimationFrame(n)) })(G)) }, i.__c = function (e, t) { t.some((function (e) { try { e.__h.forEach(Y), e.__h = e.__h.filter((function (e) { return !e.__ || Z(e) })) } catch (n) { t.some((function (e) { e.__h && (e.__h = []) })), t = [], i.__e(n, e.__v) } })), z && z(e, t) }, i.unmount = function (e) { j && j(e); var t = e.__c; if (t && t.__H) try { t.__H.__.forEach(Y) } catch (e) { i.__e(e, t.__v) } }; var q = "function" == typeof requestAnimationFrame; function Y(e) { "function" == typeof e.__c && e.__c() } function Z(e) { e.__c = e.__() } function X(e, t) { for (var n in e) if ("__source" !== n && !(n in t)) return !0; for (var r in t) if ("__source" !== r && e[r] !== t[r]) return !0; return !1 } function K(e) { this.props = e } (K.prototype = new y).isPureReactComponent = !0, K.prototype.shouldComponentUpdate = function (e, t) { return X(this.props, e) || X(this.state, t) }; var $ = i.__b; i.__b = function (e) { e.type && e.type.__f && e.ref && (e.props.ref = e.ref, e.ref = null), $ && $(e) }; var J = i.__e; i.__e = function (e, t, n) { if (e.then) for (var r, o = t; o = o.__;)if ((r = o.__c) && r.__c) return null == t.__e && (t.__e = n.__e, t.__k = n.__k), r.__c(e, t); J(e, t, n) }; var Q = i.unmount; function ee() { this.__u = 0, this.t = null, this.__b = null } function te(e) { var t = e.__.__c; return t && t.__e && t.__e(e) } function ne() { this.u = null, this.o = null } i.unmount = function (e) { var t = e.__c; t && t.__R && t.__R(), t && !0 === e.__h && (e.type = null), Q && Q(e) }, (ee.prototype = new y).__c = function (e, t) { var n = t.__c, r = this; null == r.t && (r.t = []), r.t.push(n); var o = te(r.__v), i = !1, a = function () { i || (i = !0, n.__R = null, o ? o(s) : s()) }; n.__R = a; var s = function () { if (!--r.__u) { if (r.state.__e) { var e = r.state.__e; r.__v.__k[0] = function e(t, n, r) { return t && (t.__v = null, t.__k = t.__k && t.__k.map((function (t) { return e(t, n, r) })), t.__c && t.__c.__P === n && (t.__e && r.insertBefore(t.__e, t.__d), t.__c.__e = !0, t.__c.__P = r)), t }(e, e.__c.__P, e.__c.__O) } var t; for (r.setState({ __e: r.__b = null }); t = r.t.pop();)t.forceUpdate() } }, l = !0 === t.__h; r.__u++ || l || r.setState({ __e: r.__b = r.__v.__k[0] }), e.then(a, a) }, ee.prototype.componentWillUnmount = function () { this.t = [] }, ee.prototype.render = function (e, t) { if (this.__b) { if (this.__v.__k) { var n = document.createElement("div"), r = this.__v.__k[0].__c; this.__v.__k[0] = function e(t, n, r) { return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach((function (e) { "function" == typeof e.__c && e.__c() })), t.__c.__H = null), null != (t = function (e, t) { for (var n in t) e[n] = t[n]; return e }({}, t)).__c && (t.__c.__P === r && (t.__c.__P = n), t.__c = null), t.__k = t.__k && t.__k.map((function (t) { return e(t, n, r) }))), t }(this.__b, n, r.__O = r.__P) } this.__b = null } var o = t.__e && v(m, null, e.fallback); return o && (o.__h = null), [v(m, null, t.__e ? null : e.children), o] }; var re = function (e, t, n) { if (++n[1] === n[0] && e.o.delete(t), e.props.revealOrder && ("t" !== e.props.revealOrder[0] || !e.o.size)) for (n = e.u; n;) { for (; n.length > 3;)n.pop()(); if (n[1] < n[0]) break; e.u = n = n[2] } }; function oe(e) { return this.getChildContext = function () { return e.context }, e.children } function ie(e) { var t = this, n = e.i; t.componentWillUnmount = function () { L(null, t.l), t.l = null, t.i = null }, t.i && t.i !== n && t.componentWillUnmount(), e.__v ? (t.l || (t.i = n, t.l = { nodeType: 1, parentNode: n, childNodes: [], appendChild: function (e) { this.childNodes.push(e), t.i.appendChild(e) }, insertBefore: function (e, n) { this.childNodes.push(e), t.i.appendChild(e) }, removeChild: function (e) { this.childNodes.splice(this.childNodes.indexOf(e) >>> 1, 1), t.i.removeChild(e) } }), L(v(oe, { context: t.context }, e.__v), t.l)) : t.l && t.componentWillUnmount() } (ne.prototype = new y).__e = function (e) { var t = this, n = te(t.__v), r = t.o.get(e); return r[0]++, function (o) { var i = function () { t.props.revealOrder ? (r.push(o), re(t, e, r)) : o() }; n ? n(i) : i() } }, ne.prototype.render = function (e) { this.u = null, this.o = new Map; var t = R(e.children); e.revealOrder && "b" === e.revealOrder[0] && t.reverse(); for (var n = t.length; n--;)this.o.set(t[n], this.u = [1, 0, this.u]); return e.children }, ne.prototype.componentDidUpdate = ne.prototype.componentDidMount = function () { var e = this; this.o.forEach((function (t, n) { re(e, n, t) })) }; var ae = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103, se = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, le = function (e) { return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(e) }; y.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach((function (e) { Object.defineProperty(y.prototype, e, { configurable: !0, get: function () { return this["UNSAFE_" + e] }, set: function (t) { Object.defineProperty(this, e, { configurable: !0, writable: !0, value: t }) } }) })); var ue = i.event; function ce() { } function de() { return this.cancelBubble } function pe() { return this.defaultPrevented } i.event = function (e) { return ue && (e = ue(e)), e.persist = ce, e.isPropagationStopped = de, e.isDefaultPrevented = pe, e.nativeEvent = e }; var fe = { configurable: !0, get: function () { return this.class } }, he = i.vnode; i.vnode = function (e) { var t = e.type, n = e.props, r = n; if ("string" == typeof t) { for (var o in r = {}, n) { var i = n[o]; "value" === o && "defaultValue" in n && null == i || ("defaultValue" === o && "value" in n && null == n.value ? o = "value" : "download" === o && !0 === i ? i = "" : /ondoubleclick/i.test(o) ? o = "ondblclick" : /^onchange(textarea|input)/i.test(o + t) && !le(n.type) ? o = "oninput" : /^on(Ani|Tra|Tou|BeforeInp)/.test(o) ? o = o.toLowerCase() : se.test(o) ? o = o.replace(/[A-Z0-9]/, "-$&").toLowerCase() : null === i && (i = void 0), r[o] = i) } "select" == t && r.multiple && Array.isArray(r.value) && (r.value = R(n.children).forEach((function (e) { e.props.selected = -1 != r.value.indexOf(e.props.value) }))), "select" == t && null != r.defaultValue && (r.value = R(n.children).forEach((function (e) { e.props.selected = r.multiple ? -1 != r.defaultValue.indexOf(e.props.value) : r.defaultValue == e.props.value }))), e.props = r } t && n.class != n.className && (fe.enumerable = "className" in n, null != n.className && (r.class = n.className), Object.defineProperty(r, "className", fe)), e.$$typeof = ae, he && he(e) }; var ve = i.__r; i.__r = function (e) { ve && ve(e) }, "object" == typeof performance && "function" == typeof performance.now && performance.now.bind(performance); var ge = "undefined" != typeof globalThis ? globalThis : window; ge.FullCalendarVDom ? console.warn("FullCalendar VDOM already loaded") : ge.FullCalendarVDom = { Component: y, createElement: v, render: L, createRef: function () { return { current: null } }, Fragment: m, createContext: function (e) { var t = function (e, t) { var n = { __c: t = "__cC" + u++, __: e, Consumer: function (e, t) { return e.children(t) }, Provider: function (e) { var n, r; return this.getChildContext || (n = [], (r = {})[t] = this, this.getChildContext = function () { return r }, this.shouldComponentUpdate = function (e) { this.props.value !== e.value && n.some(b) }, this.sub = function (e) { n.push(e); var t = e.componentWillUnmount; e.componentWillUnmount = function () { n.splice(n.indexOf(e), 1), t && t.call(e) } }), e.children } }; return n.Provider.__ = n.Consumer.contextType = n }(e), n = t.Provider; return t.Provider = function () { var e = this, t = !this.getChildContext, r = n.apply(this, arguments); if (t) { var o = []; this.shouldComponentUpdate = function (t) { e.props.value !== t.value && o.forEach((function (e) { e.context = t.value, e.forceUpdate() })) }, this.sub = function (e) { o.push(e); var t = e.componentWillUnmount; e.componentWillUnmount = function () { o.splice(o.indexOf(e), 1), t && t.call(e) } } } return r }, t }, createPortal: function (e, t) { return v(ie, { __v: e, i: t }) }, flushToDom: function () { var e = i.debounceRendering, t = []; function n(e) { t.push(e) } i.debounceRendering = n, L(v(me, {}), document.createElement("div")); for (; t.length;)t.shift()(); i.debounceRendering = e }, unmountComponentAtNode: function (e) { L(null, e) } }; var me = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { return v("div", {}) }, t.prototype.componentDidMount = function () { this.setState({}) }, t }(y); var ye = function () { function e(e, t) { this.context = e, this.internalEventSource = t } return e.prototype.remove = function () { this.context.dispatch({ type: "REMOVE_EVENT_SOURCE", sourceId: this.internalEventSource.sourceId }) }, e.prototype.refetch = function () { this.context.dispatch({ type: "FETCH_EVENT_SOURCES", sourceIds: [this.internalEventSource.sourceId], isRefetch: !0 }) }, Object.defineProperty(e.prototype, "id", { get: function () { return this.internalEventSource.publicId }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "url", { get: function () { return this.internalEventSource.meta.url }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "format", { get: function () { return this.internalEventSource.meta.format }, enumerable: !1, configurable: !0 }), e }(); function Ee(e) { e.parentNode && e.parentNode.removeChild(e) } function Se(e, t) { if (e.closest) return e.closest(t); if (!document.documentElement.contains(e)) return null; do { if (be(e, t)) return e; e = e.parentElement || e.parentNode } while (null !== e && 1 === e.nodeType); return null } function be(e, t) { return (e.matches || e.matchesSelector || e.msMatchesSelector).call(e, t) } function De(e, t) { for (var n = e instanceof HTMLElement ? [e] : e, r = [], o = 0; o < n.length; o += 1)for (var i = n[o].querySelectorAll(t), a = 0; a < i.length; a += 1)r.push(i[a]); return r } var Ce = /(top|left|right|bottom|width|height)$/i; function we(e, t) { for (var n in t) Re(e, n, t[n]) } function Re(e, t, n) { null == n ? e.style[t] = "" : "number" == typeof n && Ce.test(t) ? e.style[t] = n + "px" : e.style[t] = n } function _e(e) { var t, n; return null !== (n = null === (t = e.composedPath) || void 0 === t ? void 0 : t.call(e)[0]) && void 0 !== n ? n : e.target } function Te(e) { return e.getRootNode ? e.getRootNode() : document } var ke = 0; function xe() { return "fc-dom-" + (ke += 1) } function Me(e) { e.preventDefault() } function Ie(e, t, n, r) { var o = function (e, t) { return function (n) { var r = Se(n.target, e); r && t.call(r, n, r) } }(n, r); return e.addEventListener(t, o), function () { e.removeEventListener(t, o) } } var Pe = ["webkitTransitionEnd", "otransitionend", "oTransitionEnd", "msTransitionEnd", "transitionend"]; function Ne(e, t) { var n = function (r) { t(r), Pe.forEach((function (t) { e.removeEventListener(t, n) })) }; Pe.forEach((function (t) { e.addEventListener(t, n) })) } function He(e) { return r({ onClick: e }, Oe(e)) } function Oe(e) { return { tabIndex: 0, onKeyDown: function (t) { "Enter" !== t.key && " " !== t.key || (e(t), t.preventDefault()) } } } var Ae = 0; function Le() { return String(Ae += 1) } function Ue() { document.body.classList.add("fc-not-allowed") } function We() { document.body.classList.remove("fc-not-allowed") } function Ve(e) { e.classList.add("fc-unselectable"), e.addEventListener("selectstart", Me) } function Fe(e) { e.classList.remove("fc-unselectable"), e.removeEventListener("selectstart", Me) } function Be(e) { e.addEventListener("contextmenu", Me) } function ze(e) { e.removeEventListener("contextmenu", Me) } function je(e) { var t, n, r = [], o = []; for ("string" == typeof e ? o = e.split(/\s*,\s*/) : "function" == typeof e ? o = [e] : Array.isArray(e) && (o = e), t = 0; t < o.length; t += 1)"string" == typeof (n = o[t]) ? r.push("-" === n.charAt(0) ? { field: n.substring(1), order: -1 } : { field: n, order: 1 }) : "function" == typeof n && r.push({ func: n }); return r } function Ge(e, t, n) { var r, o; for (r = 0; r < n.length; r += 1)if (o = qe(e, t, n[r])) return o; return 0 } function qe(e, t, n) { return n.func ? n.func(e, t) : Ye(e[n.field], t[n.field]) * (n.order || 1) } function Ye(e, t) { return e || t ? null == t ? -1 : null == e ? 1 : "string" == typeof e || "string" == typeof t ? String(e).localeCompare(String(t)) : e - t : 0 } function Ze(e, t) { var n = String(e); return "000".substr(0, t - n.length) + n } function Xe(e, t, n) { return "function" == typeof e ? e.apply(void 0, t) : "string" == typeof e ? t.reduce((function (e, t, n) { return e.replace("$" + n, t || "") }), e) : n } function Ke(e, t) { return e - t } function $e(e) { return e % 1 == 0 } function Je(e) { var t = e.querySelector(".fc-scrollgrid-shrink-frame"), n = e.querySelector(".fc-scrollgrid-shrink-cushion"); if (!t) throw new Error("needs fc-scrollgrid-shrink-frame className"); if (!n) throw new Error("needs fc-scrollgrid-shrink-cushion className"); return e.getBoundingClientRect().width - t.getBoundingClientRect().width + n.getBoundingClientRect().width } var Qe = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"]; function et(e, t) { var n = ft(e); return n[2] += 7 * t, ht(n) } function tt(e, t) { var n = ft(e); return n[2] += t, ht(n) } function nt(e, t) { var n = ft(e); return n[6] += t, ht(n) } function rt(e, t) { return ot(e, t) / 7 } function ot(e, t) { return (t.valueOf() - e.valueOf()) / 864e5 } function it(e, t) { var n = lt(e), r = lt(t); return { years: 0, months: 0, days: Math.round(ot(n, r)), milliseconds: t.valueOf() - r.valueOf() - (e.valueOf() - n.valueOf()) } } function at(e, t) { var n = st(e, t); return null !== n && n % 7 == 0 ? n / 7 : null } function st(e, t) { return gt(e) === gt(t) ? Math.round(ot(e, t)) : null } function lt(e) { return ht([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()]) } function ut(e, t, n, r) { var o = ht([t, 0, 1 + ct(t, n, r)]), i = lt(e), a = Math.round(ot(o, i)); return Math.floor(a / 7) + 1 } function ct(e, t, n) { var r = 7 + t - n; return -((7 + ht([e, 0, r]).getUTCDay() - t) % 7) + r - 1 } function dt(e) { return [e.getFullYear(), e.getMonth(), e.getDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()] } function pt(e) { return new Date(e[0], e[1] || 0, null == e[2] ? 1 : e[2], e[3] || 0, e[4] || 0, e[5] || 0) } function ft(e) { return [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds(), e.getUTCMilliseconds()] } function ht(e) { return 1 === e.length && (e = e.concat([0])), new Date(Date.UTC.apply(Date, e)) } function vt(e) { return !isNaN(e.valueOf()) } function gt(e) { return 1e3 * e.getUTCHours() * 60 * 60 + 1e3 * e.getUTCMinutes() * 60 + 1e3 * e.getUTCSeconds() + e.getUTCMilliseconds() } function mt(e, t, n, r) { return { instanceId: Le(), defId: e, range: t, forcedStartTzo: null == n ? null : n, forcedEndTzo: null == r ? null : r } } var yt = Object.prototype.hasOwnProperty; function Et(e, t) { var n = {}; if (t) for (var r in t) { for (var o = [], i = e.length - 1; i >= 0; i -= 1) { var a = e[i][r]; if ("object" == typeof a && a) o.unshift(a); else if (void 0 !== a) { n[r] = a; break } } o.length && (n[r] = Et(o)) } for (i = e.length - 1; i >= 0; i -= 1) { var s = e[i]; for (var l in s) l in n || (n[l] = s[l]) } return n } function St(e, t) { var n = {}; for (var r in e) t(e[r], r) && (n[r] = e[r]); return n } function bt(e, t) { var n = {}; for (var r in e) n[r] = t(e[r], r); return n } function Dt(e) { for (var t = {}, n = 0, r = e; n < r.length; n++) { t[r[n]] = !0 } return t } function Ct(e) { var t = []; for (var n in e) t.push(e[n]); return t } function wt(e, t) { if (e === t) return !0; for (var n in e) if (yt.call(e, n) && !(n in t)) return !1; for (var n in t) if (yt.call(t, n) && e[n] !== t[n]) return !1; return !0 } function Rt(e, t) { var n = []; for (var r in e) yt.call(e, r) && (r in t || n.push(r)); for (var r in t) yt.call(t, r) && e[r] !== t[r] && n.push(r); return n } function _t(e, t, n) { if (void 0 === n && (n = {}), e === t) return !0; for (var r in t) if (!(r in e) || !Tt(e[r], t[r], n[r])) return !1; for (var r in e) if (!(r in t)) return !1; return !0 } function Tt(e, t, n) { return e === t || !0 === n || !!n && n(e, t) } function kt(e, t, n, r) { void 0 === t && (t = 0), void 0 === r && (r = 1); var o = []; null == n && (n = Object.keys(e).length); for (var i = t; i < n; i += r) { var a = e[i]; void 0 !== a && o.push(a) } return o } function xt(e, t, n) { var r = n.dateEnv, o = n.pluginHooks, i = n.options, a = e.defs, s = e.instances; for (var l in s = St(s, (function (e) { return !a[e.defId].recurringDef })), a) { var u = a[l]; if (u.recurringDef) { var c = u.recurringDef.duration; c || (c = u.allDay ? i.defaultAllDayEventDuration : i.defaultTimedEventDuration); for (var d = 0, p = Mt(u, c, t, r, o.recurringTypes); d < p.length; d++) { var f = p[d], h = mt(l, { start: f, end: r.add(f, c) }); s[h.instanceId] = h } } } return { defs: a, instances: s } } function Mt(e, t, n, r, o) { var i = o[e.recurringDef.typeId].expand(e.recurringDef.typeData, { start: r.subtract(n.start, t), end: n.end }, r); return e.allDay && (i = i.map(lt)), i } var It = ["years", "months", "days", "milliseconds"], Pt = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/; function Nt(e, t) { var n; return "string" == typeof e ? function (e) { var t = Pt.exec(e); if (t) { var n = t[1] ? -1 : 1; return { years: 0, months: 0, days: n * (t[2] ? parseInt(t[2], 10) : 0), milliseconds: n * (60 * (t[3] ? parseInt(t[3], 10) : 0) * 60 * 1e3 + 60 * (t[4] ? parseInt(t[4], 10) : 0) * 1e3 + 1e3 * (t[5] ? parseInt(t[5], 10) : 0) + (t[6] ? parseInt(t[6], 10) : 0)) } } return null }(e) : "object" == typeof e && e ? Ht(e) : "number" == typeof e ? Ht(((n = {})[t || "milliseconds"] = e, n)) : null } function Ht(e) { var t = { years: e.years || e.year || 0, months: e.months || e.month || 0, days: e.days || e.day || 0, milliseconds: 60 * (e.hours || e.hour || 0) * 60 * 1e3 + 60 * (e.minutes || e.minute || 0) * 1e3 + 1e3 * (e.seconds || e.second || 0) + (e.milliseconds || e.millisecond || e.ms || 0) }, n = e.weeks || e.week; return n && (t.days += 7 * n, t.specifiedWeeks = !0), t } function Ot(e, t) { return { years: e.years + t.years, months: e.months + t.months, days: e.days + t.days, milliseconds: e.milliseconds + t.milliseconds } } function At(e, t) { return { years: e.years * t, months: e.months * t, days: e.days * t, milliseconds: e.milliseconds * t } } function Lt(e) { return Ut(e) / 864e5 } function Ut(e) { return 31536e6 * e.years + 2592e6 * e.months + 864e5 * e.days + e.milliseconds } function Wt(e, t) { for (var n = null, r = 0; r < It.length; r += 1) { var o = It[r]; if (t[o]) { var i = e[o] / t[o]; if (!$e(i) || null !== n && n !== i) return null; n = i } else if (e[o]) return null } return n } function Vt(e) { var t = e.milliseconds; if (t) { if (t % 1e3 != 0) return { unit: "millisecond", value: t }; if (t % 6e4 != 0) return { unit: "second", value: t / 1e3 }; if (t % 36e5 != 0) return { unit: "minute", value: t / 6e4 }; if (t) return { unit: "hour", value: t / 36e5 } } return e.days ? e.specifiedWeeks && e.days % 7 == 0 ? { unit: "week", value: e.days / 7 } : { unit: "day", value: e.days } : e.months ? { unit: "month", value: e.months } : e.years ? { unit: "year", value: e.years } : { unit: "millisecond", value: 0 } } function Ft(e, t, n) { void 0 === n && (n = !1); var r = e.toISOString(); return r = r.replace(".000", ""), n && (r = r.replace("T00:00:00Z", "")), r.length > 10 && (null == t ? r = r.replace("Z", "") : 0 !== t && (r = r.replace("Z", jt(t, !0)))), r } function Bt(e) { return e.toISOString().replace(/T.*$/, "") } function zt(e) { return Ze(e.getUTCHours(), 2) + ":" + Ze(e.getUTCMinutes(), 2) + ":" + Ze(e.getUTCSeconds(), 2) } function jt(e, t) { void 0 === t && (t = !1); var n = e < 0 ? "-" : "+", r = Math.abs(e), o = Math.floor(r / 60), i = Math.round(r % 60); return t ? n + Ze(o, 2) + ":" + Ze(i, 2) : "GMT" + n + o + (i ? ":" + Ze(i, 2) : "") } function Gt(e, t, n) { if (e === t) return !0; var r, o = e.length; if (o !== t.length) return !1; for (r = 0; r < o; r += 1)if (!(n ? n(e[r], t[r]) : e[r] === t[r])) return !1; return !0 } function qt(e, t, n) { var r, o; return function () { for (var i = [], a = 0; a < arguments.length; a++)i[a] = arguments[a]; if (r) { if (!Gt(r, i)) { n && n(o); var s = e.apply(this, i); t && t(s, o) || (o = s) } } else o = e.apply(this, i); return r = i, o } } function Yt(e, t, n) { var r, o, i = this; return function (a) { if (r) { if (!wt(r, a)) { n && n(o); var s = e.call(i, a); t && t(s, o) || (o = s) } } else o = e.call(i, a); return r = a, o } } var Zt = { week: 3, separator: 0, omitZeroMinute: 0, meridiem: 0, omitCommas: 0 }, Xt = { timeZoneName: 7, era: 6, year: 5, month: 4, day: 2, weekday: 2, hour: 1, minute: 1, second: 1 }, Kt = /\s*([ap])\.?m\.?/i, $t = /,/g, Jt = /\s+/g, Qt = /\u200e/g, en = /UTC|GMT/, tn = function () { function e(e) { var t = {}, n = {}, r = 0; for (var o in e) o in Zt ? (n[o] = e[o], r = Math.max(Zt[o], r)) : (t[o] = e[o], o in Xt && (r = Math.max(Xt[o], r))); this.standardDateProps = t, this.extendedSettings = n, this.severity = r, this.buildFormattingFunc = qt(nn) } return e.prototype.format = function (e, t) { return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, t)(e) }, e.prototype.formatRange = function (e, t, n, r) { var o = this.standardDateProps, i = this.extendedSettings, a = function (e, t, n) { if (n.getMarkerYear(e) !== n.getMarkerYear(t)) return 5; if (n.getMarkerMonth(e) !== n.getMarkerMonth(t)) return 4; if (n.getMarkerDay(e) !== n.getMarkerDay(t)) return 2; if (gt(e) !== gt(t)) return 1; return 0 }(e.marker, t.marker, n.calendarSystem); if (!a) return this.format(e, n); var s = a; !(s > 1) || "numeric" !== o.year && "2-digit" !== o.year || "numeric" !== o.month && "2-digit" !== o.month || "numeric" !== o.day && "2-digit" !== o.day || (s = 1); var l = this.format(e, n), u = this.format(t, n); if (l === u) return l; var c = nn(function (e, t) { var n = {}; for (var r in e) (!(r in Xt) || Xt[r] <= t) && (n[r] = e[r]); return n }(o, s), i, n), d = c(e), p = c(t), f = function (e, t, n, r) { var o = 0; for (; o < e.length;) { var i = e.indexOf(t, o); if (-1 === i) break; var a = e.substr(0, i); o = i + t.length; for (var s = e.substr(o), l = 0; l < n.length;) { var u = n.indexOf(r, l); if (-1 === u) break; var c = n.substr(0, u); l = u + r.length; var d = n.substr(l); if (a === c && s === d) return { before: a, after: s } } } return null }(l, d, u, p), h = i.separator || r || n.defaultSeparator || ""; return f ? f.before + d + h + p + f.after : l + h + u }, e.prototype.getLargestUnit = function () { switch (this.severity) { case 7: case 6: case 5: return "year"; case 4: return "month"; case 3: return "week"; case 2: return "day"; default: return "time" } }, e }(); function nn(e, t, n) { var o = Object.keys(e).length; return 1 === o && "short" === e.timeZoneName ? function (e) { return jt(e.timeZoneOffset) } : 0 === o && t.week ? function (e) { return function (e, t, n, r, o) { var i = []; "long" === o ? i.push(n) : "short" !== o && "narrow" !== o || i.push(t); "long" !== o && "short" !== o || i.push(" "); i.push(r.simpleNumberFormat.format(e)), "rtl" === r.options.direction && i.reverse(); return i.join("") }(n.computeWeekNumber(e.marker), n.weekText, n.weekTextLong, n.locale, t.week) } : function (e, t, n) { e = r({}, e), t = r({}, t), function (e, t) { e.timeZoneName && (e.hour || (e.hour = "2-digit"), e.minute || (e.minute = "2-digit")); "long" === e.timeZoneName && (e.timeZoneName = "short"); t.omitZeroMinute && (e.second || e.millisecond) && delete t.omitZeroMinute }(e, t), e.timeZone = "UTC"; var o, i = new Intl.DateTimeFormat(n.locale.codes, e); if (t.omitZeroMinute) { var a = r({}, e); delete a.minute, o = new Intl.DateTimeFormat(n.locale.codes, a) } return function (r) { var a = r.marker; return function (e, t, n, r, o) { e = e.replace(Qt, ""), "short" === n.timeZoneName && (e = function (e, t) { var n = !1; e = e.replace(en, (function () { return n = !0, t })), n || (e += " " + t); return e }(e, "UTC" === o.timeZone || null == t.timeZoneOffset ? "UTC" : jt(t.timeZoneOffset))); r.omitCommas && (e = e.replace($t, "").trim()); r.omitZeroMinute && (e = e.replace(":00", "")); !1 === r.meridiem ? e = e.replace(Kt, "").trim() : "narrow" === r.meridiem ? e = e.replace(Kt, (function (e, t) { return t.toLocaleLowerCase() })) : "short" === r.meridiem ? e = e.replace(Kt, (function (e, t) { return t.toLocaleLowerCase() + "m" })) : "lowercase" === r.meridiem && (e = e.replace(Kt, (function (e) { return e.toLocaleLowerCase() }))); return e = (e = e.replace(Jt, " ")).trim() }((o && !a.getUTCMinutes() ? o : i).format(a), r, e, t, n) } }(e, t, n) } function rn(e, t) { var n = t.markerToArray(e.marker); return { marker: e.marker, timeZoneOffset: e.timeZoneOffset, array: n, year: n[0], month: n[1], day: n[2], hour: n[3], minute: n[4], second: n[5], millisecond: n[6] } } function on(e, t, n, r) { var o = rn(e, n.calendarSystem); return { date: o, start: o, end: t ? rn(t, n.calendarSystem) : null, timeZone: n.timeZone, localeCodes: n.locale.codes, defaultSeparator: r || n.defaultSeparator } } var an = function () { function e(e) { this.cmdStr = e } return e.prototype.format = function (e, t, n) { return t.cmdFormatter(this.cmdStr, on(e, null, t, n)) }, e.prototype.formatRange = function (e, t, n, r) { return n.cmdFormatter(this.cmdStr, on(e, t, n, r)) }, e }(), sn = function () { function e(e) { this.func = e } return e.prototype.format = function (e, t, n) { return this.func(on(e, null, t, n)) }, e.prototype.formatRange = function (e, t, n, r) { return this.func(on(e, t, n, r)) }, e }(); function ln(e) { return "object" == typeof e && e ? new tn(e) : "string" == typeof e ? new an(e) : "function" == typeof e ? new sn(e) : null } var un = { navLinkDayClick: yn, navLinkWeekClick: yn, duration: Nt, bootstrapFontAwesome: yn, buttonIcons: yn, customButtons: yn, defaultAllDayEventDuration: Nt, defaultTimedEventDuration: Nt, nextDayThreshold: Nt, scrollTime: Nt, scrollTimeReset: Boolean, slotMinTime: Nt, slotMaxTime: Nt, dayPopoverFormat: ln, slotDuration: Nt, snapDuration: Nt, headerToolbar: yn, footerToolbar: yn, defaultRangeSeparator: String, titleRangeSeparator: String, forceEventDuration: Boolean, dayHeaders: Boolean, dayHeaderFormat: ln, dayHeaderClassNames: yn, dayHeaderContent: yn, dayHeaderDidMount: yn, dayHeaderWillUnmount: yn, dayCellClassNames: yn, dayCellContent: yn, dayCellDidMount: yn, dayCellWillUnmount: yn, initialView: String, aspectRatio: Number, weekends: Boolean, weekNumberCalculation: yn, weekNumbers: Boolean, weekNumberClassNames: yn, weekNumberContent: yn, weekNumberDidMount: yn, weekNumberWillUnmount: yn, editable: Boolean, viewClassNames: yn, viewDidMount: yn, viewWillUnmount: yn, nowIndicator: Boolean, nowIndicatorClassNames: yn, nowIndicatorContent: yn, nowIndicatorDidMount: yn, nowIndicatorWillUnmount: yn, showNonCurrentDates: Boolean, lazyFetching: Boolean, startParam: String, endParam: String, timeZoneParam: String, timeZone: String, locales: yn, locale: yn, themeSystem: String, dragRevertDuration: Number, dragScroll: Boolean, allDayMaintainDuration: Boolean, unselectAuto: Boolean, dropAccept: yn, eventOrder: je, eventOrderStrict: Boolean, handleWindowResize: Boolean, windowResizeDelay: Number, longPressDelay: Number, eventDragMinDistance: Number, expandRows: Boolean, height: yn, contentHeight: yn, direction: String, weekNumberFormat: ln, eventResizableFromStart: Boolean, displayEventTime: Boolean, displayEventEnd: Boolean, weekText: String, weekTextLong: String, progressiveEventRendering: Boolean, businessHours: yn, initialDate: yn, now: yn, eventDataTransform: yn, stickyHeaderDates: yn, stickyFooterScrollbar: yn, viewHeight: yn, defaultAllDay: Boolean, eventSourceFailure: yn, eventSourceSuccess: yn, eventDisplay: String, eventStartEditable: Boolean, eventDurationEditable: Boolean, eventOverlap: yn, eventConstraint: yn, eventAllow: yn, eventBackgroundColor: String, eventBorderColor: String, eventTextColor: String, eventColor: String, eventClassNames: yn, eventContent: yn, eventDidMount: yn, eventWillUnmount: yn, selectConstraint: yn, selectOverlap: yn, selectAllow: yn, droppable: Boolean, unselectCancel: String, slotLabelFormat: yn, slotLaneClassNames: yn, slotLaneContent: yn, slotLaneDidMount: yn, slotLaneWillUnmount: yn, slotLabelClassNames: yn, slotLabelContent: yn, slotLabelDidMount: yn, slotLabelWillUnmount: yn, dayMaxEvents: yn, dayMaxEventRows: yn, dayMinWidth: Number, slotLabelInterval: Nt, allDayText: String, allDayClassNames: yn, allDayContent: yn, allDayDidMount: yn, allDayWillUnmount: yn, slotMinWidth: Number, navLinks: Boolean, eventTimeFormat: ln, rerenderDelay: Number, moreLinkText: yn, moreLinkHint: yn, selectMinDistance: Number, selectable: Boolean, selectLongPressDelay: Number, eventLongPressDelay: Number, selectMirror: Boolean, eventMaxStack: Number, eventMinHeight: Number, eventMinWidth: Number, eventShortHeight: Number, slotEventOverlap: Boolean, plugins: yn, firstDay: Number, dayCount: Number, dateAlignment: String, dateIncrement: Nt, hiddenDays: yn, monthMode: Boolean, fixedWeekCount: Boolean, validRange: yn, visibleRange: yn, titleFormat: yn, eventInteractive: Boolean, noEventsText: String, viewHint: yn, navLinkHint: yn, closeHint: String, timeHint: String, eventHint: String, moreLinkClick: yn, moreLinkClassNames: yn, moreLinkContent: yn, moreLinkDidMount: yn, moreLinkWillUnmount: yn }, cn = { eventDisplay: "auto", defaultRangeSeparator: " - ", titleRangeSeparator: " – ", defaultTimedEventDuration: "01:00:00", defaultAllDayEventDuration: { day: 1 }, forceEventDuration: !1, nextDayThreshold: "00:00:00", dayHeaders: !0, initialView: "", aspectRatio: 1.35, headerToolbar: { start: "title", center: "", end: "today prev,next" }, weekends: !0, weekNumbers: !1, weekNumberCalculation: "local", editable: !1, nowIndicator: !1, scrollTime: "06:00:00", scrollTimeReset: !0, slotMinTime: "00:00:00", slotMaxTime: "24:00:00", showNonCurrentDates: !0, lazyFetching: !0, startParam: "start", endParam: "end", timeZoneParam: "timeZone", timeZone: "local", locales: [], locale: "", themeSystem: "standard", dragRevertDuration: 500, dragScroll: !0, allDayMaintainDuration: !1, unselectAuto: !0, dropAccept: "*", eventOrder: "start,-duration,allDay,title", dayPopoverFormat: { month: "long", day: "numeric", year: "numeric" }, handleWindowResize: !0, windowResizeDelay: 100, longPressDelay: 1e3, eventDragMinDistance: 5, expandRows: !1, navLinks: !1, selectable: !1, eventMinHeight: 15, eventMinWidth: 30, eventShortHeight: 30 }, dn = { datesSet: yn, eventsSet: yn, eventAdd: yn, eventChange: yn, eventRemove: yn, windowResize: yn, eventClick: yn, eventMouseEnter: yn, eventMouseLeave: yn, select: yn, unselect: yn, loading: yn, _unmount: yn, _beforeprint: yn, _afterprint: yn, _noEventDrop: yn, _noEventResize: yn, _resize: yn, _scrollRequest: yn }, pn = { buttonText: yn, buttonHints: yn, views: yn, plugins: yn, initialEvents: yn, events: yn, eventSources: yn }, fn = { headerToolbar: hn, footerToolbar: hn, buttonText: hn, buttonHints: hn, buttonIcons: hn }; function hn(e, t) { return "object" == typeof e && "object" == typeof t && e && t ? wt(e, t) : e === t } var vn = { type: String, component: yn, buttonText: String, buttonTextKey: String, dateProfileGeneratorClass: yn, usesMinMaxTime: Boolean, classNames: yn, content: yn, didMount: yn, willUnmount: yn }; function gn(e) { return Et(e, fn) } function mn(e, t) { var n = {}, r = {}; for (var o in t) o in e && (n[o] = t[o](e[o])); for (var o in e) o in t || (r[o] = e[o]); return { refined: n, extra: r } } function yn(e) { return e } function En(e, t, n, r) { for (var o = { defs: {}, instances: {} }, i = An(n), a = 0, s = e; a < s.length; a++) { var l = Hn(s[a], t, n, r, i); l && Sn(l, o) } return o } function Sn(e, t) { return void 0 === t && (t = { defs: {}, instances: {} }), t.defs[e.def.defId] = e.def, e.instance && (t.instances[e.instance.instanceId] = e.instance), t } function bn(e, t) { var n = e.instances[t]; if (n) { var r = e.defs[n.defId], o = wn(e, (function (e) { return t = r, n = e, Boolean(t.groupId && t.groupId === n.groupId); var t, n })); return o.defs[r.defId] = r, o.instances[n.instanceId] = n, o } return { defs: {}, instances: {} } } function Dn() { return { defs: {}, instances: {} } } function Cn(e, t) { return { defs: r(r({}, e.defs), t.defs), instances: r(r({}, e.instances), t.instances) } } function wn(e, t) { var n = St(e.defs, t), r = St(e.instances, (function (e) { return n[e.defId] })); return { defs: n, instances: r } } function Rn(e) { return Array.isArray(e) ? e : "string" == typeof e ? e.split(/\s+/) : [] } var _n = { display: String, editable: Boolean, startEditable: Boolean, durationEditable: Boolean, constraint: yn, overlap: yn, allow: yn, className: Rn, classNames: Rn, color: String, backgroundColor: String, borderColor: String, textColor: String }, Tn = { display: null, startEditable: null, durationEditable: null, constraints: [], overlap: null, allows: [], backgroundColor: "", borderColor: "", textColor: "", classNames: [] }; function kn(e, t) { var n = function (e, t) { return Array.isArray(e) ? En(e, null, t, !0) : "object" == typeof e && e ? En([e], null, t, !0) : null != e ? String(e) : null }(e.constraint, t); return { display: e.display || null, startEditable: null != e.startEditable ? e.startEditable : e.editable, durationEditable: null != e.durationEditable ? e.durationEditable : e.editable, constraints: null != n ? [n] : [], overlap: null != e.overlap ? e.overlap : null, allows: null != e.allow ? [e.allow] : [], backgroundColor: e.backgroundColor || e.color || "", borderColor: e.borderColor || e.color || "", textColor: e.textColor || "", classNames: (e.className || []).concat(e.classNames || []) } } function xn(e) { return e.reduce(Mn, Tn) } function Mn(e, t) { return { display: null != t.display ? t.display : e.display, startEditable: null != t.startEditable ? t.startEditable : e.startEditable, durationEditable: null != t.durationEditable ? t.durationEditable : e.durationEditable, constraints: e.constraints.concat(t.constraints), overlap: "boolean" == typeof t.overlap ? t.overlap : e.overlap, allows: e.allows.concat(t.allows), backgroundColor: t.backgroundColor || e.backgroundColor, borderColor: t.borderColor || e.borderColor, textColor: t.textColor || e.textColor, classNames: e.classNames.concat(t.classNames) } } var In = { id: String, groupId: String, title: String, url: String, interactive: Boolean }, Pn = { start: yn, end: yn, date: yn, allDay: Boolean }, Nn = r(r(r({}, In), Pn), { extendedProps: yn }); function Hn(e, t, n, r, o) { void 0 === o && (o = An(n)); var i = On(e, n, o), a = i.refined, s = i.extra, l = function (e, t) { var n = null; e && (n = e.defaultAllDay); null == n && (n = t.options.defaultAllDay); return n }(t, n), u = function (e, t, n, r) { for (var o = 0; o < r.length; o += 1) { var i = r[o].parse(e, n); if (i) { var a = e.allDay; return null == a && null == (a = t) && null == (a = i.allDayGuess) && (a = !1), { allDay: a, duration: i.duration, typeData: i.typeData, typeId: o } } } return null }(a, l, n.dateEnv, n.pluginHooks.recurringTypes); if (u) return (c = Ln(a, s, t ? t.sourceId : "", u.allDay, Boolean(u.duration), n)).recurringDef = { typeId: u.typeId, typeData: u.typeData, duration: u.duration }, { def: c, instance: null }; var c, d = function (e, t, n, r) { var o, i, a = e.allDay, s = null, l = !1, u = null, c = null != e.start ? e.start : e.date; if (o = n.dateEnv.createMarkerMeta(c)) s = o.marker; else if (!r) return null; null != e.end && (i = n.dateEnv.createMarkerMeta(e.end)); null == a && (a = null != t ? t : (!o || o.isTimeUnspecified) && (!i || i.isTimeUnspecified)); a && s && (s = lt(s)); i && (u = i.marker, a && (u = lt(u)), s && u <= s && (u = null)); u ? l = !0 : r || (l = n.options.forceEventDuration || !1, u = n.dateEnv.add(s, a ? n.options.defaultAllDayEventDuration : n.options.defaultTimedEventDuration)); return { allDay: a, hasEnd: l, range: { start: s, end: u }, forcedStartTzo: o ? o.forcedTzo : null, forcedEndTzo: i ? i.forcedTzo : null } }(a, l, n, r); return d ? { def: c = Ln(a, s, t ? t.sourceId : "", d.allDay, d.hasEnd, n), instance: mt(c.defId, d.range, d.forcedStartTzo, d.forcedEndTzo) } : null } function On(e, t, n) { return void 0 === n && (n = An(t)), mn(e, n) } function An(e) { return r(r(r({}, _n), Nn), e.pluginHooks.eventRefiners) } function Ln(e, t, n, o, i, a) { for (var s = { title: e.title || "", groupId: e.groupId || "", publicId: e.id || "", url: e.url || "", recurringDef: null, defId: Le(), sourceId: n, allDay: o, hasEnd: i, interactive: e.interactive, ui: kn(e, a), extendedProps: r(r({}, e.extendedProps || {}), t) }, l = 0, u = a.pluginHooks.eventDefMemberAdders; l < u.length; l++) { var c = u[l]; r(s, c(e)) } return Object.freeze(s.ui.classNames), Object.freeze(s.extendedProps), s } function Un(e) { var t = Math.floor(ot(e.start, e.end)) || 1, n = lt(e.start); return { start: n, end: tt(n, t) } } function Wn(e, t) { void 0 === t && (t = Nt(0)); var n = null, r = null; if (e.end) { r = lt(e.end); var o = e.end.valueOf() - r.valueOf(); o && o >= Ut(t) && (r = tt(r, 1)) } return e.start && (n = lt(e.start), r && r <= n && (r = tt(n, 1))), { start: n, end: r } } function Vn(e) { var t = Wn(e); return ot(t.start, t.end) > 1 } function Fn(e, t, n, r) { return "year" === r ? Nt(n.diffWholeYears(e, t), "year") : "month" === r ? Nt(n.diffWholeMonths(e, t), "month") : it(e, t) } function Bn(e, t) { var n, r, o = [], i = t.start; for (e.sort(zn), n = 0; n < e.length; n += 1)(r = e[n]).start > i && o.push({ start: i, end: r.start }), r.end > i && (i = r.end); return i < t.end && o.push({ start: i, end: t.end }), o } function zn(e, t) { return e.start.valueOf() - t.start.valueOf() } function jn(e, t) { var n = e.start, r = e.end, o = null; return null !== t.start && (n = null === n ? t.start : new Date(Math.max(n.valueOf(), t.start.valueOf()))), null != t.end && (r = null === r ? t.end : new Date(Math.min(r.valueOf(), t.end.valueOf()))), (null === n || null === r || n < r) && (o = { start: n, end: r }), o } function Gn(e, t) { return (null === e.start ? null : e.start.valueOf()) === (null === t.start ? null : t.start.valueOf()) && (null === e.end ? null : e.end.valueOf()) === (null === t.end ? null : t.end.valueOf()) } function qn(e, t) { return (null === e.end || null === t.start || e.end > t.start) && (null === e.start || null === t.end || e.start < t.end) } function Yn(e, t) { return (null === e.start || null !== t.start && t.start >= e.start) && (null === e.end || null !== t.end && t.end <= e.end) } function Zn(e, t) { return (null === e.start || t >= e.start) && (null === e.end || t < e.end) } function Xn(e, t, n, r) { var o = {}, i = {}, a = {}, s = [], l = [], u = Qn(e.defs, t); for (var c in e.defs) { "inverse-background" === (f = u[(S = e.defs[c]).defId]).display && (S.groupId ? (o[S.groupId] = [], a[S.groupId] || (a[S.groupId] = S)) : i[c] = []) } for (var d in e.instances) { var p = e.instances[d], f = u[(S = e.defs[p.defId]).defId], h = p.range, v = !S.allDay && r ? Wn(h, r) : h, g = jn(v, n); g && ("inverse-background" === f.display ? S.groupId ? o[S.groupId].push(g) : i[p.defId].push(g) : "none" !== f.display && ("background" === f.display ? s : l).push({ def: S, ui: f, instance: p, range: g, isStart: v.start && v.start.valueOf() === g.start.valueOf(), isEnd: v.end && v.end.valueOf() === g.end.valueOf() })) } for (var m in o) for (var y = 0, E = Bn(o[m], n); y < E.length; y++) { var S, b = E[y]; f = u[(S = a[m]).defId]; s.push({ def: S, ui: f, instance: null, range: b, isStart: !1, isEnd: !1 }) } for (var c in i) for (var D = 0, C = Bn(i[c], n); D < C.length; D++) { b = C[D]; s.push({ def: e.defs[c], ui: u[c], instance: null, range: b, isStart: !1, isEnd: !1 }) } return { bg: s, fg: l } } function Kn(e) { return "background" === e.ui.display || "inverse-background" === e.ui.display } function $n(e, t) { e.fcSeg = t } function Jn(e) { return e.fcSeg || e.parentNode.fcSeg || null } function Qn(e, t) { return bt(e, (function (e) { return er(e, t) })) } function er(e, t) { var n = []; return t[""] && n.push(t[""]), t[e.defId] && n.push(t[e.defId]), n.push(e.ui), xn(n) } function tr(e, t) { var n = e.map(nr); return n.sort((function (e, n) { return Ge(e, n, t) })), n.map((function (e) { return e._seg })) } function nr(e) { var t = e.eventRange, n = t.def, o = t.instance ? t.instance.range : t.range, i = o.start ? o.start.valueOf() : 0, a = o.end ? o.end.valueOf() : 0; return r(r(r({}, n.extendedProps), n), { id: n.publicId, start: i, end: a, duration: a - i, allDay: Number(n.allDay), _seg: e }) } function rr(e, t) { for (var n = t.pluginHooks.isDraggableTransformers, r = e.eventRange, o = r.def, i = r.ui, a = i.startEditable, s = 0, l = n; s < l.length; s++) { a = (0, l[s])(a, o, i, t) } return a } function or(e, t) { return e.isStart && e.eventRange.ui.durationEditable && t.options.eventResizableFromStart } function ir(e, t) { return e.isEnd && e.eventRange.ui.durationEditable } function ar(e, t, n, r, o, i, a) { var s = n.dateEnv, l = n.options, u = l.displayEventTime, c = l.displayEventEnd, d = e.eventRange.def, p = e.eventRange.instance; null == u && (u = !1 !== r), null == c && (c = !1 !== o); var f = p.range.start, h = p.range.end, v = i || e.start || e.eventRange.range.start, g = a || e.end || e.eventRange.range.end, m = lt(f).valueOf() === lt(v).valueOf(), y = lt(nt(h, -1)).valueOf() === lt(nt(g, -1)).valueOf(); return u && !d.allDay && (m || y) ? (v = m ? f : v, g = y ? h : g, c && d.hasEnd ? s.formatRange(v, g, t, { forcedStartTzo: i ? null : p.forcedStartTzo, forcedEndTzo: a ? null : p.forcedEndTzo }) : s.format(v, t, { forcedTzo: i ? null : p.forcedStartTzo })) : "" } function sr(e, t, n) { var r = e.eventRange.range; return { isPast: r.end < (n || t.start), isFuture: r.start >= (n || t.end), isToday: t && Zn(t, r.start) } } function lr(e) { var t = ["fc-event"]; return e.isMirror && t.push("fc-event-mirror"), e.isDraggable && t.push("fc-event-draggable"), (e.isStartResizable || e.isEndResizable) && t.push("fc-event-resizable"), e.isDragging && t.push("fc-event-dragging"), e.isResizing && t.push("fc-event-resizing"), e.isSelected && t.push("fc-event-selected"), e.isStart && t.push("fc-event-start"), e.isEnd && t.push("fc-event-end"), e.isPast && t.push("fc-event-past"), e.isToday && t.push("fc-event-today"), e.isFuture && t.push("fc-event-future"), t } function ur(e) { return e.instance ? e.instance.instanceId : e.def.defId + ":" + e.range.start.toISOString() } function cr(e, t) { var n = e.eventRange, r = n.def, o = n.instance, i = r.url; if (i) return { href: i }; var a = t.emitter, s = t.options.eventInteractive; return null == s && null == (s = r.interactive) && (s = Boolean(a.hasHandlers("eventClick"))), s ? Oe((function (e) { a.trigger("eventClick", { el: e.target, event: new xr(t, r, o), jsEvent: e, view: t.viewApi }) })) : {} } var dr = { start: yn, end: yn, allDay: Boolean }; function pr(e, t, n) { var o = function (e, t) { var n = mn(e, dr), o = n.refined, i = n.extra, a = o.start ? t.createMarkerMeta(o.start) : null, s = o.end ? t.createMarkerMeta(o.end) : null, l = o.allDay; null == l && (l = a && a.isTimeUnspecified && (!s || s.isTimeUnspecified)); return r({ range: { start: a ? a.marker : null, end: s ? s.marker : null }, allDay: l }, i) }(e, t), i = o.range; if (!i.start) return null; if (!i.end) { if (null == n) return null; i.end = t.add(i.start, n) } return o } function fr(e, t) { return Gn(e.range, t.range) && e.allDay === t.allDay && function (e, t) { for (var n in t) if ("range" !== n && "allDay" !== n && e[n] !== t[n]) return !1; for (var n in e) if (!(n in t)) return !1; return !0 }(e, t) } function hr(e, t, n) { return r(r({}, vr(e, t, n)), { timeZone: t.timeZone }) } function vr(e, t, n) { return { start: t.toDate(e.start), end: t.toDate(e.end), startStr: t.formatIso(e.start, { omitTime: n }), endStr: t.formatIso(e.end, { omitTime: n }) } } function gr(e, t, n) { var r = On({ editable: !1 }, n), o = Ln(r.refined, r.extra, "", e.allDay, !0, n); return { def: o, ui: er(o, t), instance: mt(o.defId, e.range), range: e.range, isStart: !0, isEnd: !0 } } function mr(e, t, n) { n.emitter.trigger("select", r(r({}, yr(e, n)), { jsEvent: t ? t.origEvent : null, view: n.viewApi || n.calendarApi.view })) } function yr(e, t) { for (var n, o, i = {}, a = 0, s = t.pluginHooks.dateSpanTransforms; a < s.length; a++) { var l = s[a]; r(i, l(e, t)) } return r(i, (n = e, o = t.dateEnv, r(r({}, vr(n.range, o, n.allDay)), { allDay: n.allDay }))), i } function Er(e, t, n) { var r = n.dateEnv, o = n.options, i = t; return e ? (i = lt(i), i = r.add(i, o.defaultAllDayEventDuration)) : i = r.add(i, o.defaultTimedEventDuration), i } function Sr(e, t, n, r) { var o = Qn(e.defs, t), i = { defs: {}, instances: {} }; for (var a in e.defs) { var s = e.defs[a]; i.defs[a] = br(s, o[a], n, r) } for (var l in e.instances) { var u = e.instances[l]; s = i.defs[u.defId]; i.instances[l] = Dr(u, s, o[u.defId], n, r) } return i } function br(e, t, n, o) { var i = n.standardProps || {}; null == i.hasEnd && t.durationEditable && (n.startDelta || n.endDelta) && (i.hasEnd = !0); var a = r(r(r({}, e), i), { ui: r(r({}, e.ui), i.ui) }); n.extendedProps && (a.extendedProps = r(r({}, a.extendedProps), n.extendedProps)); for (var s = 0, l = o.pluginHooks.eventDefMutationAppliers; s < l.length; s++) { (0, l[s])(a, n, o) } return !a.hasEnd && o.options.forceEventDuration && (a.hasEnd = !0), a } function Dr(e, t, n, o, i) { var a = i.dateEnv, s = o.standardProps && !0 === o.standardProps.allDay, l = o.standardProps && !1 === o.standardProps.hasEnd, u = r({}, e); return s && (u.range = Un(u.range)), o.datesDelta && n.startEditable && (u.range = { start: a.add(u.range.start, o.datesDelta), end: a.add(u.range.end, o.datesDelta) }), o.startDelta && n.durationEditable && (u.range = { start: a.add(u.range.start, o.startDelta), end: u.range.end }), o.endDelta && n.durationEditable && (u.range = { start: u.range.start, end: a.add(u.range.end, o.endDelta) }), l && (u.range = { start: u.range.start, end: Er(t.allDay, u.range.start, i) }), t.allDay && (u.range = { start: lt(u.range.start), end: lt(u.range.end) }), u.range.end < u.range.start && (u.range.end = Er(t.allDay, u.range.start, i)), u } var Cr = function () { function e(e, t, n) { this.type = e, this.getCurrentData = t, this.dateEnv = n } return Object.defineProperty(e.prototype, "calendar", { get: function () { return this.getCurrentData().calendarApi }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "title", { get: function () { return this.getCurrentData().viewTitle }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "activeStart", { get: function () { return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "activeEnd", { get: function () { return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "currentStart", { get: function () { return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start) }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "currentEnd", { get: function () { return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end) }, enumerable: !1, configurable: !0 }), e.prototype.getOption = function (e) { return this.getCurrentData().options[e] }, e }(), wr = { id: String, defaultAllDay: Boolean, url: String, format: String, events: yn, eventDataTransform: yn, success: yn, failure: yn }; function Rr(e, t, n) { var r; if (void 0 === n && (n = _r(t)), "string" == typeof e ? r = { url: e } : "function" == typeof e || Array.isArray(e) ? r = { events: e } : "object" == typeof e && e && (r = e), r) { var o = mn(r, n), i = o.refined, a = o.extra, s = function (e, t) { for (var n = t.pluginHooks.eventSourceDefs, r = n.length - 1; r >= 0; r -= 1) { var o = n[r].parseMeta(e); if (o) return { sourceDefId: r, meta: o } } return null }(i, t); if (s) return { _raw: e, isFetching: !1, latestFetchId: "", fetchRange: null, defaultAllDay: i.defaultAllDay, eventDataTransform: i.eventDataTransform, success: i.success, failure: i.failure, publicId: i.id || "", sourceId: Le(), sourceDefId: s.sourceDefId, meta: s.meta, ui: kn(i, t), extendedProps: a } } return null } function _r(e) { return r(r(r({}, _n), wr), e.pluginHooks.eventSourceRefiners) } function Tr(e, t) { return "function" == typeof e && (e = e()), null == e ? t.createNowMarker() : t.createMarker(e) } var kr = function () { function e() { } return e.prototype.getCurrentData = function () { return this.currentDataManager.getCurrentData() }, e.prototype.dispatch = function (e) { return this.currentDataManager.dispatch(e) }, Object.defineProperty(e.prototype, "view", { get: function () { return this.getCurrentData().viewApi }, enumerable: !1, configurable: !0 }), e.prototype.batchRendering = function (e) { e() }, e.prototype.updateSize = function () { this.trigger("_resize", !0) }, e.prototype.setOption = function (e, t) { this.dispatch({ type: "SET_OPTION", optionName: e, rawOptionValue: t }) }, e.prototype.getOption = function (e) { return this.currentDataManager.currentCalendarOptionsInput[e] }, e.prototype.getAvailableLocaleCodes = function () { return Object.keys(this.getCurrentData().availableRawLocales) }, e.prototype.on = function (e, t) { var n = this.currentDataManager; n.currentCalendarOptionsRefiners[e] ? n.emitter.on(e, t) : console.warn("Unknown listener name '" + e + "'") }, e.prototype.off = function (e, t) { this.currentDataManager.emitter.off(e, t) }, e.prototype.trigger = function (e) { for (var t, n = [], r = 1; r < arguments.length; r++)n[r - 1] = arguments[r]; (t = this.currentDataManager.emitter).trigger.apply(t, o([e], n)) }, e.prototype.changeView = function (e, t) { var n = this; this.batchRendering((function () { if (n.unselect(), t) if (t.start && t.end) n.dispatch({ type: "CHANGE_VIEW_TYPE", viewType: e }), n.dispatch({ type: "SET_OPTION", optionName: "visibleRange", rawOptionValue: t }); else { var r = n.getCurrentData().dateEnv; n.dispatch({ type: "CHANGE_VIEW_TYPE", viewType: e, dateMarker: r.createMarker(t) }) } else n.dispatch({ type: "CHANGE_VIEW_TYPE", viewType: e }) })) }, e.prototype.zoomTo = function (e, t) { var n; t = t || "day", n = this.getCurrentData().viewSpecs[t] || this.getUnitViewSpec(t), this.unselect(), n ? this.dispatch({ type: "CHANGE_VIEW_TYPE", viewType: n.type, dateMarker: e }) : this.dispatch({ type: "CHANGE_DATE", dateMarker: e }) }, e.prototype.getUnitViewSpec = function (e) { var t, n, r = this.getCurrentData(), o = r.viewSpecs, i = r.toolbarConfig, a = [].concat(i.header ? i.header.viewsWithButtons : [], i.footer ? i.footer.viewsWithButtons : []); for (var s in o) a.push(s); for (t = 0; t < a.length; t += 1)if ((n = o[a[t]]) && n.singleUnit === e) return n; return null }, e.prototype.prev = function () { this.unselect(), this.dispatch({ type: "PREV" }) }, e.prototype.next = function () { this.unselect(), this.dispatch({ type: "NEXT" }) }, e.prototype.prevYear = function () { var e = this.getCurrentData(); this.unselect(), this.dispatch({ type: "CHANGE_DATE", dateMarker: e.dateEnv.addYears(e.currentDate, -1) }) }, e.prototype.nextYear = function () { var e = this.getCurrentData(); this.unselect(), this.dispatch({ type: "CHANGE_DATE", dateMarker: e.dateEnv.addYears(e.currentDate, 1) }) }, e.prototype.today = function () { var e = this.getCurrentData(); this.unselect(), this.dispatch({ type: "CHANGE_DATE", dateMarker: Tr(e.calendarOptions.now, e.dateEnv) }) }, e.prototype.gotoDate = function (e) { var t = this.getCurrentData(); this.unselect(), this.dispatch({ type: "CHANGE_DATE", dateMarker: t.dateEnv.createMarker(e) }) }, e.prototype.incrementDate = function (e) { var t = this.getCurrentData(), n = Nt(e); n && (this.unselect(), this.dispatch({ type: "CHANGE_DATE", dateMarker: t.dateEnv.add(t.currentDate, n) })) }, e.prototype.getDate = function () { var e = this.getCurrentData(); return e.dateEnv.toDate(e.currentDate) }, e.prototype.formatDate = function (e, t) { var n = this.getCurrentData().dateEnv; return n.format(n.createMarker(e), ln(t)) }, e.prototype.formatRange = function (e, t, n) { var r = this.getCurrentData().dateEnv; return r.formatRange(r.createMarker(e), r.createMarker(t), ln(n), n) }, e.prototype.formatIso = function (e, t) { var n = this.getCurrentData().dateEnv; return n.formatIso(n.createMarker(e), { omitTime: t }) }, e.prototype.select = function (e, t) { var n; n = null == t ? null != e.start ? e : { start: e, end: null } : { start: e, end: t }; var r = this.getCurrentData(), o = pr(n, r.dateEnv, Nt({ days: 1 })); o && (this.dispatch({ type: "SELECT_DATES", selection: o }), mr(o, null, r)) }, e.prototype.unselect = function (e) { var t = this.getCurrentData(); t.dateSelection && (this.dispatch({ type: "UNSELECT_DATES" }), function (e, t) { t.emitter.trigger("unselect", { jsEvent: e ? e.origEvent : null, view: t.viewApi || t.calendarApi.view }) }(e, t)) }, e.prototype.addEvent = function (e, t) { if (e instanceof xr) { var n = e._def, r = e._instance; return this.getCurrentData().eventStore.defs[n.defId] || (this.dispatch({ type: "ADD_EVENTS", eventStore: Sn({ def: n, instance: r }) }), this.triggerEventAdd(e)), e } var o, i = this.getCurrentData(); if (t instanceof ye) o = t.internalEventSource; else if ("boolean" == typeof t) t && (o = Ct(i.eventSources)[0]); else if (null != t) { var a = this.getEventSourceById(t); if (!a) return console.warn('Could not find an event source with ID "' + t + '"'), null; o = a.internalEventSource } var s = Hn(e, o, i, !1); if (s) { var l = new xr(i, s.def, s.def.recurringDef ? null : s.instance); return this.dispatch({ type: "ADD_EVENTS", eventStore: Sn(s) }), this.triggerEventAdd(l), l } return null }, e.prototype.triggerEventAdd = function (e) { var t = this; this.getCurrentData().emitter.trigger("eventAdd", { event: e, relatedEvents: [], revert: function () { t.dispatch({ type: "REMOVE_EVENTS", eventStore: Mr(e) }) } }) }, e.prototype.getEventById = function (e) { var t = this.getCurrentData(), n = t.eventStore, r = n.defs, o = n.instances; for (var i in e = String(e), r) { var a = r[i]; if (a.publicId === e) { if (a.recurringDef) return new xr(t, a, null); for (var s in o) { var l = o[s]; if (l.defId === a.defId) return new xr(t, a, l) } } } return null }, e.prototype.getEvents = function () { var e = this.getCurrentData(); return Ir(e.eventStore, e) }, e.prototype.removeAllEvents = function () { this.dispatch({ type: "REMOVE_ALL_EVENTS" }) }, e.prototype.getEventSources = function () { var e = this.getCurrentData(), t = e.eventSources, n = []; for (var r in t) n.push(new ye(e, t[r])); return n }, e.prototype.getEventSourceById = function (e) { var t = this.getCurrentData(), n = t.eventSources; for (var r in e = String(e), n) if (n[r].publicId === e) return new ye(t, n[r]); return null }, e.prototype.addEventSource = function (e) { var t = this.getCurrentData(); if (e instanceof ye) return t.eventSources[e.internalEventSource.sourceId] || this.dispatch({ type: "ADD_EVENT_SOURCES", sources: [e.internalEventSource] }), e; var n = Rr(e, t); return n ? (this.dispatch({ type: "ADD_EVENT_SOURCES", sources: [n] }), new ye(t, n)) : null }, e.prototype.removeAllEventSources = function () { this.dispatch({ type: "REMOVE_ALL_EVENT_SOURCES" }) }, e.prototype.refetchEvents = function () { this.dispatch({ type: "FETCH_EVENT_SOURCES", isRefetch: !0 }) }, e.prototype.scrollToTime = function (e) { var t = Nt(e); t && this.trigger("_scrollRequest", { time: t }) }, e }(), xr = function () { function e(e, t, n) { this._context = e, this._def = t, this._instance = n || null } return e.prototype.setProp = function (e, t) { var n, r; if (e in Pn) console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead."); else if ("id" === e) t = In[e](t), this.mutate({ standardProps: { publicId: t } }); else if (e in In) t = In[e](t), this.mutate({ standardProps: (n = {}, n[e] = t, n) }); else if (e in _n) { var o = _n[e](t); "color" === e ? o = { backgroundColor: t, borderColor: t } : "editable" === e ? o = { startEditable: t, durationEditable: t } : ((r = {})[e] = t, o = r), this.mutate({ standardProps: { ui: o } }) } else console.warn("Could not set prop '" + e + "'. Use setExtendedProp instead.") }, e.prototype.setExtendedProp = function (e, t) { var n; this.mutate({ extendedProps: (n = {}, n[e] = t, n) }) }, e.prototype.setStart = function (e, t) { void 0 === t && (t = {}); var n = this._context.dateEnv, r = n.createMarker(e); if (r && this._instance) { var o = Fn(this._instance.range.start, r, n, t.granularity); t.maintainDuration ? this.mutate({ datesDelta: o }) : this.mutate({ startDelta: o }) } }, e.prototype.setEnd = function (e, t) { void 0 === t && (t = {}); var n, r = this._context.dateEnv; if ((null == e || (n = r.createMarker(e))) && this._instance) if (n) { var o = Fn(this._instance.range.end, n, r, t.granularity); this.mutate({ endDelta: o }) } else this.mutate({ standardProps: { hasEnd: !1 } }) }, e.prototype.setDates = function (e, t, n) { void 0 === n && (n = {}); var r, o, i, a = this._context.dateEnv, s = { allDay: n.allDay }, l = a.createMarker(e); if (l && ((null == t || (r = a.createMarker(t))) && this._instance)) { var u = this._instance.range; !0 === n.allDay && (u = Un(u)); var c = Fn(u.start, l, a, n.granularity); if (r) { var d = Fn(u.end, r, a, n.granularity); i = d, (o = c).years === i.years && o.months === i.months && o.days === i.days && o.milliseconds === i.milliseconds ? this.mutate({ datesDelta: c, standardProps: s }) : this.mutate({ startDelta: c, endDelta: d, standardProps: s }) } else s.hasEnd = !1, this.mutate({ datesDelta: c, standardProps: s }) } }, e.prototype.moveStart = function (e) { var t = Nt(e); t && this.mutate({ startDelta: t }) }, e.prototype.moveEnd = function (e) { var t = Nt(e); t && this.mutate({ endDelta: t }) }, e.prototype.moveDates = function (e) { var t = Nt(e); t && this.mutate({ datesDelta: t }) }, e.prototype.setAllDay = function (e, t) { void 0 === t && (t = {}); var n = { allDay: e }, r = t.maintainDuration; null == r && (r = this._context.options.allDayMaintainDuration), this._def.allDay !== e && (n.hasEnd = r), this.mutate({ standardProps: n }) }, e.prototype.formatRange = function (e) { var t = this._context.dateEnv, n = this._instance, r = ln(e); return this._def.hasEnd ? t.formatRange(n.range.start, n.range.end, r, { forcedStartTzo: n.forcedStartTzo, forcedEndTzo: n.forcedEndTzo }) : t.format(n.range.start, r, { forcedTzo: n.forcedStartTzo }) }, e.prototype.mutate = function (t) { var n = this._instance; if (n) { var r = this._def, o = this._context, i = o.getCurrentData().eventStore, a = bn(i, n.instanceId); a = Sr(a, { "": { display: "", startEditable: !0, durationEditable: !0, constraints: [], overlap: null, allows: [], backgroundColor: "", borderColor: "", textColor: "", classNames: [] } }, t, o); var s = new e(o, r, n); this._def = a.defs[r.defId], this._instance = a.instances[n.instanceId], o.dispatch({ type: "MERGE_EVENTS", eventStore: a }), o.emitter.trigger("eventChange", { oldEvent: s, event: this, relatedEvents: Ir(a, o, n), revert: function () { o.dispatch({ type: "RESET_EVENTS", eventStore: i }) } }) } }, e.prototype.remove = function () { var e = this._context, t = Mr(this); e.dispatch({ type: "REMOVE_EVENTS", eventStore: t }), e.emitter.trigger("eventRemove", { event: this, relatedEvents: [], revert: function () { e.dispatch({ type: "MERGE_EVENTS", eventStore: t }) } }) }, Object.defineProperty(e.prototype, "source", { get: function () { var e = this._def.sourceId; return e ? new ye(this._context, this._context.getCurrentData().eventSources[e]) : null }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "start", { get: function () { return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "end", { get: function () { return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "startStr", { get: function () { var e = this._instance; return e ? this._context.dateEnv.formatIso(e.range.start, { omitTime: this._def.allDay, forcedTzo: e.forcedStartTzo }) : "" }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "endStr", { get: function () { var e = this._instance; return e && this._def.hasEnd ? this._context.dateEnv.formatIso(e.range.end, { omitTime: this._def.allDay, forcedTzo: e.forcedEndTzo }) : "" }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "id", { get: function () { return this._def.publicId }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "groupId", { get: function () { return this._def.groupId }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "allDay", { get: function () { return this._def.allDay }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "title", { get: function () { return this._def.title }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "url", { get: function () { return this._def.url }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "display", { get: function () { return this._def.ui.display || "auto" }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "startEditable", { get: function () { return this._def.ui.startEditable }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "durationEditable", { get: function () { return this._def.ui.durationEditable }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "constraint", { get: function () { return this._def.ui.constraints[0] || null }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "overlap", { get: function () { return this._def.ui.overlap }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "allow", { get: function () { return this._def.ui.allows[0] || null }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "backgroundColor", { get: function () { return this._def.ui.backgroundColor }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "borderColor", { get: function () { return this._def.ui.borderColor }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "textColor", { get: function () { return this._def.ui.textColor }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "classNames", { get: function () { return this._def.ui.classNames }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "extendedProps", { get: function () { return this._def.extendedProps }, enumerable: !1, configurable: !0 }), e.prototype.toPlainObject = function (e) { void 0 === e && (e = {}); var t = this._def, n = t.ui, o = this.startStr, i = this.endStr, a = {}; return t.title && (a.title = t.title), o && (a.start = o), i && (a.end = i), t.publicId && (a.id = t.publicId), t.groupId && (a.groupId = t.groupId), t.url && (a.url = t.url), n.display && "auto" !== n.display && (a.display = n.display), e.collapseColor && n.backgroundColor && n.backgroundColor === n.borderColor ? a.color = n.backgroundColor : (n.backgroundColor && (a.backgroundColor = n.backgroundColor), n.borderColor && (a.borderColor = n.borderColor)), n.textColor && (a.textColor = n.textColor), n.classNames.length && (a.classNames = n.classNames), Object.keys(t.extendedProps).length && (e.collapseExtendedProps ? r(a, t.extendedProps) : a.extendedProps = t.extendedProps), a }, e.prototype.toJSON = function () { return this.toPlainObject() }, e }(); function Mr(e) { var t, n, r = e._def, o = e._instance; return { defs: (t = {}, t[r.defId] = r, t), instances: o ? (n = {}, n[o.instanceId] = o, n) : {} } } function Ir(e, t, n) { var r = e.defs, o = e.instances, i = [], a = n ? n.instanceId : ""; for (var s in o) { var l = o[s], u = r[l.defId]; l.instanceId !== a && i.push(new xr(t, u, l)) } return i } var Pr = {}; var Nr, Hr = function () { function e() { } return e.prototype.getMarkerYear = function (e) { return e.getUTCFullYear() }, e.prototype.getMarkerMonth = function (e) { return e.getUTCMonth() }, e.prototype.getMarkerDay = function (e) { return e.getUTCDate() }, e.prototype.arrayToMarker = function (e) { return ht(e) }, e.prototype.markerToArray = function (e) { return ft(e) }, e }(); Nr = Hr, Pr["gregory"] = Nr; var Or = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/; function Ar(e) { var t = Or.exec(e); if (t) { var n = new Date(Date.UTC(Number(t[1]), t[3] ? Number(t[3]) - 1 : 0, Number(t[5] || 1), Number(t[7] || 0), Number(t[8] || 0), Number(t[10] || 0), t[12] ? 1e3 * Number("0." + t[12]) : 0)); if (vt(n)) { var r = null; return t[13] && (r = ("-" === t[15] ? -1 : 1) * (60 * Number(t[16] || 0) + Number(t[18] || 0))), { marker: n, isTimeUnspecified: !t[6], timeZoneOffset: r } } } return null } var Lr = function () { function e(e) { var t = this.timeZone = e.timeZone, n = "local" !== t && "UTC" !== t; e.namedTimeZoneImpl && n && (this.namedTimeZoneImpl = new e.namedTimeZoneImpl(t)), this.canComputeOffset = Boolean(!n || this.namedTimeZoneImpl), this.calendarSystem = function (e) { return new Pr[e] }(e.calendarSystem), this.locale = e.locale, this.weekDow = e.locale.week.dow, this.weekDoy = e.locale.week.doy, "ISO" === e.weekNumberCalculation && (this.weekDow = 1, this.weekDoy = 4), "number" == typeof e.firstDay && (this.weekDow = e.firstDay), "function" == typeof e.weekNumberCalculation && (this.weekNumberFunc = e.weekNumberCalculation), this.weekText = null != e.weekText ? e.weekText : e.locale.options.weekText, this.weekTextLong = (null != e.weekTextLong ? e.weekTextLong : e.locale.options.weekTextLong) || this.weekText, this.cmdFormatter = e.cmdFormatter, this.defaultSeparator = e.defaultSeparator } return e.prototype.createMarker = function (e) { var t = this.createMarkerMeta(e); return null === t ? null : t.marker }, e.prototype.createNowMarker = function () { return this.canComputeOffset ? this.timestampToMarker((new Date).valueOf()) : ht(dt(new Date)) }, e.prototype.createMarkerMeta = function (e) { if ("string" == typeof e) return this.parse(e); var t = null; return "number" == typeof e ? t = this.timestampToMarker(e) : e instanceof Date ? (e = e.valueOf(), isNaN(e) || (t = this.timestampToMarker(e))) : Array.isArray(e) && (t = ht(e)), null !== t && vt(t) ? { marker: t, isTimeUnspecified: !1, forcedTzo: null } : null }, e.prototype.parse = function (e) { var t = Ar(e); if (null === t) return null; var n = t.marker, r = null; return null !== t.timeZoneOffset && (this.canComputeOffset ? n = this.timestampToMarker(n.valueOf() - 60 * t.timeZoneOffset * 1e3) : r = t.timeZoneOffset), { marker: n, isTimeUnspecified: t.isTimeUnspecified, forcedTzo: r } }, e.prototype.getYear = function (e) { return this.calendarSystem.getMarkerYear(e) }, e.prototype.getMonth = function (e) { return this.calendarSystem.getMarkerMonth(e) }, e.prototype.add = function (e, t) { var n = this.calendarSystem.markerToArray(e); return n[0] += t.years, n[1] += t.months, n[2] += t.days, n[6] += t.milliseconds, this.calendarSystem.arrayToMarker(n) }, e.prototype.subtract = function (e, t) { var n = this.calendarSystem.markerToArray(e); return n[0] -= t.years, n[1] -= t.months, n[2] -= t.days, n[6] -= t.milliseconds, this.calendarSystem.arrayToMarker(n) }, e.prototype.addYears = function (e, t) { var n = this.calendarSystem.markerToArray(e); return n[0] += t, this.calendarSystem.arrayToMarker(n) }, e.prototype.addMonths = function (e, t) { var n = this.calendarSystem.markerToArray(e); return n[1] += t, this.calendarSystem.arrayToMarker(n) }, e.prototype.diffWholeYears = function (e, t) { var n = this.calendarSystem; return gt(e) === gt(t) && n.getMarkerDay(e) === n.getMarkerDay(t) && n.getMarkerMonth(e) === n.getMarkerMonth(t) ? n.getMarkerYear(t) - n.getMarkerYear(e) : null }, e.prototype.diffWholeMonths = function (e, t) { var n = this.calendarSystem; return gt(e) === gt(t) && n.getMarkerDay(e) === n.getMarkerDay(t) ? n.getMarkerMonth(t) - n.getMarkerMonth(e) + 12 * (n.getMarkerYear(t) - n.getMarkerYear(e)) : null }, e.prototype.greatestWholeUnit = function (e, t) { var n = this.diffWholeYears(e, t); return null !== n ? { unit: "year", value: n } : null !== (n = this.diffWholeMonths(e, t)) ? { unit: "month", value: n } : null !== (n = at(e, t)) ? { unit: "week", value: n } : null !== (n = st(e, t)) ? { unit: "day", value: n } : $e(n = function (e, t) { return (t.valueOf() - e.valueOf()) / 36e5 }(e, t)) ? { unit: "hour", value: n } : $e(n = function (e, t) { return (t.valueOf() - e.valueOf()) / 6e4 }(e, t)) ? { unit: "minute", value: n } : $e(n = function (e, t) { return (t.valueOf() - e.valueOf()) / 1e3 }(e, t)) ? { unit: "second", value: n } : { unit: "millisecond", value: t.valueOf() - e.valueOf() } }, e.prototype.countDurationsBetween = function (e, t, n) { var r; return n.years && null !== (r = this.diffWholeYears(e, t)) ? r / (Lt(n) / 365) : n.months && null !== (r = this.diffWholeMonths(e, t)) ? r / function (e) { return Lt(e) / 30 }(n) : n.days && null !== (r = st(e, t)) ? r / Lt(n) : (t.valueOf() - e.valueOf()) / Ut(n) }, e.prototype.startOf = function (e, t) { return "year" === t ? this.startOfYear(e) : "month" === t ? this.startOfMonth(e) : "week" === t ? this.startOfWeek(e) : "day" === t ? lt(e) : "hour" === t ? function (e) { return ht([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours()]) }(e) : "minute" === t ? function (e) { return ht([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes()]) }(e) : "second" === t ? function (e) { return ht([e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds()]) }(e) : null }, e.prototype.startOfYear = function (e) { return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e)]) }, e.prototype.startOfMonth = function (e) { return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e), this.calendarSystem.getMarkerMonth(e)]) }, e.prototype.startOfWeek = function (e) { return this.calendarSystem.arrayToMarker([this.calendarSystem.getMarkerYear(e), this.calendarSystem.getMarkerMonth(e), e.getUTCDate() - (e.getUTCDay() - this.weekDow + 7) % 7]) }, e.prototype.computeWeekNumber = function (e) { return this.weekNumberFunc ? this.weekNumberFunc(this.toDate(e)) : function (e, t, n) { var r = e.getUTCFullYear(), o = ut(e, r, t, n); if (o < 1) return ut(e, r - 1, t, n); var i = ut(e, r + 1, t, n); return i >= 1 ? Math.min(o, i) : o }(e, this.weekDow, this.weekDoy) }, e.prototype.format = function (e, t, n) { return void 0 === n && (n = {}), t.format({ marker: e, timeZoneOffset: null != n.forcedTzo ? n.forcedTzo : this.offsetForMarker(e) }, this) }, e.prototype.formatRange = function (e, t, n, r) { return void 0 === r && (r = {}), r.isEndExclusive && (t = nt(t, -1)), n.formatRange({ marker: e, timeZoneOffset: null != r.forcedStartTzo ? r.forcedStartTzo : this.offsetForMarker(e) }, { marker: t, timeZoneOffset: null != r.forcedEndTzo ? r.forcedEndTzo : this.offsetForMarker(t) }, this, r.defaultSeparator) }, e.prototype.formatIso = function (e, t) { void 0 === t && (t = {}); var n = null; return t.omitTimeZoneOffset || (n = null != t.forcedTzo ? t.forcedTzo : this.offsetForMarker(e)), Ft(e, n, t.omitTime) }, e.prototype.timestampToMarker = function (e) { return "local" === this.timeZone ? ht(dt(new Date(e))) : "UTC" !== this.timeZone && this.namedTimeZoneImpl ? ht(this.namedTimeZoneImpl.timestampToArray(e)) : new Date(e) }, e.prototype.offsetForMarker = function (e) { return "local" === this.timeZone ? -pt(ft(e)).getTimezoneOffset() : "UTC" === this.timeZone ? 0 : this.namedTimeZoneImpl ? this.namedTimeZoneImpl.offsetForArray(ft(e)) : null }, e.prototype.toDate = function (e, t) { return "local" === this.timeZone ? pt(ft(e)) : "UTC" === this.timeZone ? new Date(e.valueOf()) : this.namedTimeZoneImpl ? new Date(e.valueOf() - 1e3 * this.namedTimeZoneImpl.offsetForArray(ft(e)) * 60) : new Date(e.valueOf() - (t || 0)) }, e }(), Ur = [], Wr = { code: "en", week: { dow: 0, doy: 4 }, direction: "ltr", buttonText: { prev: "prev", next: "next", prevYear: "prev year", nextYear: "next year", year: "year", today: "today", month: "month", week: "week", day: "day", list: "list" }, weekText: "W", weekTextLong: "Week", closeHint: "Close", timeHint: "Time", eventHint: "Event", allDayText: "all-day", moreLinkText: "more", noEventsText: "No events to display" }, Vr = r(r({}, Wr), { buttonHints: { prev: "Previous $0", next: "Next $0", today: function (e, t) { return "day" === t ? "Today" : "This " + e } }, viewHint: "$0 view", navLinkHint: "Go to $0", moreLinkHint: function (e) { return "Show " + e + " more event" + (1 === e ? "" : "s") } }); function Fr(e) { for (var t = e.length > 0 ? e[0].code : "en", n = Ur.concat(e), r = { en: Vr }, o = 0, i = n; o < i.length; o++) { var a = i[o]; r[a.code] = a } return { map: r, defaultCode: t } } function Br(e, t) { return "object" != typeof e || Array.isArray(e) ? function (e, t) { var n = [].concat(e || []), r = function (e, t) { for (var n = 0; n < e.length; n += 1)for (var r = e[n].toLocaleLowerCase().split("-"), o = r.length; o > 0; o -= 1) { var i = r.slice(0, o).join("-"); if (t[i]) return t[i] } return null }(n, t) || Vr; return zr(e, n, r) }(e, t) : zr(e.code, [e.code], e) } function zr(e, t, n) { var r = Et([Wr, n], ["buttonText"]); delete r.code; var o = r.week; return delete r.week, { codeArg: e, codes: t, week: o, simpleNumberFormat: new Intl.NumberFormat(e), options: r } } function jr(e) { var t = Br(e.locale || "en", Fr([]).map); return new Lr(r(r({ timeZone: cn.timeZone, calendarSystem: "gregory" }, e), { locale: t })) } var Gr, qr = { startTime: "09:00", endTime: "17:00", daysOfWeek: [1, 2, 3, 4, 5], display: "inverse-background", classNames: "fc-non-business", groupId: "_businessHours" }; function Yr(e, t) { return En(function (e) { var t; t = !0 === e ? [{}] : Array.isArray(e) ? e.filter((function (e) { return e.daysOfWeek })) : "object" == typeof e && e ? [e] : []; return t = t.map((function (e) { return r(r({}, qr), e) })) }(e), null, t) } function Zr(e, t) { return e.left >= t.left && e.left < t.right && e.top >= t.top && e.top < t.bottom } function Xr(e, t) { var n = { left: Math.max(e.left, t.left), right: Math.min(e.right, t.right), top: Math.max(e.top, t.top), bottom: Math.min(e.bottom, t.bottom) }; return n.left < n.right && n.top < n.bottom && n } function Kr(e, t) { return { left: Math.min(Math.max(e.left, t.left), t.right), top: Math.min(Math.max(e.top, t.top), t.bottom) } } function $r(e) { return { left: (e.left + e.right) / 2, top: (e.top + e.bottom) / 2 } } function Jr(e, t) { return { left: e.left - t.left, top: e.top - t.top } } function Qr() { return null == Gr && (Gr = function () { if ("undefined" == typeof document) return !0; var e = document.createElement("div"); e.style.position = "absolute", e.style.top = "0px", e.style.left = "0px", e.innerHTML = "<table><tr><td><div></div></td></tr></table>", e.querySelector("table").style.height = "100px", e.querySelector("div").style.height = "100%", document.body.appendChild(e); var t = e.querySelector("div").offsetHeight > 0; return document.body.removeChild(e), t }()), Gr } var eo = { defs: {}, instances: {} }, to = function () { function e() { this.getKeysForEventDefs = qt(this._getKeysForEventDefs), this.splitDateSelection = qt(this._splitDateSpan), this.splitEventStore = qt(this._splitEventStore), this.splitIndividualUi = qt(this._splitIndividualUi), this.splitEventDrag = qt(this._splitInteraction), this.splitEventResize = qt(this._splitInteraction), this.eventUiBuilders = {} } return e.prototype.splitProps = function (e) { var t = this, n = this.getKeyInfo(e), r = this.getKeysForEventDefs(e.eventStore), o = this.splitDateSelection(e.dateSelection), i = this.splitIndividualUi(e.eventUiBases, r), a = this.splitEventStore(e.eventStore, r), s = this.splitEventDrag(e.eventDrag), l = this.splitEventResize(e.eventResize), u = {}; for (var c in this.eventUiBuilders = bt(n, (function (e, n) { return t.eventUiBuilders[n] || qt(no) })), n) { var d = n[c], p = a[c] || eo, f = this.eventUiBuilders[c]; u[c] = { businessHours: d.businessHours || e.businessHours, dateSelection: o[c] || null, eventStore: p, eventUiBases: f(e.eventUiBases[""], d.ui, i[c]), eventSelection: p.instances[e.eventSelection] ? e.eventSelection : "", eventDrag: s[c] || null, eventResize: l[c] || null } } return u }, e.prototype._splitDateSpan = function (e) { var t = {}; if (e) for (var n = 0, r = this.getKeysForDateSpan(e); n < r.length; n++) { t[r[n]] = e } return t }, e.prototype._getKeysForEventDefs = function (e) { var t = this; return bt(e.defs, (function (e) { return t.getKeysForEventDef(e) })) }, e.prototype._splitEventStore = function (e, t) { var n = e.defs, r = e.instances, o = {}; for (var i in n) for (var a = 0, s = t[i]; a < s.length; a++) { o[p = s[a]] || (o[p] = { defs: {}, instances: {} }), o[p].defs[i] = n[i] } for (var l in r) for (var u = r[l], c = 0, d = t[u.defId]; c < d.length; c++) { var p; o[p = d[c]] && (o[p].instances[l] = u) } return o }, e.prototype._splitIndividualUi = function (e, t) { var n = {}; for (var r in e) if (r) for (var o = 0, i = t[r]; o < i.length; o++) { var a = i[o]; n[a] || (n[a] = {}), n[a][r] = e[r] } return n }, e.prototype._splitInteraction = function (e) { var t = {}; if (e) { var n = this._splitEventStore(e.affectedEvents, this._getKeysForEventDefs(e.affectedEvents)), r = this._getKeysForEventDefs(e.mutatedEvents), o = this._splitEventStore(e.mutatedEvents, r), i = function (r) { t[r] || (t[r] = { affectedEvents: n[r] || eo, mutatedEvents: o[r] || eo, isEvent: e.isEvent }) }; for (var a in n) i(a); for (var a in o) i(a) } return t }, e }(); function no(e, t, n) { var o = []; e && o.push(e), t && o.push(t); var i = { "": xn(o) }; return n && r(i, n), i } function ro(e, t, n, r) { return { dow: e.getUTCDay(), isDisabled: Boolean(r && !Zn(r.activeRange, e)), isOther: Boolean(r && !Zn(r.currentRange, e)), isToday: Boolean(t && Zn(t, e)), isPast: Boolean(n ? e < n : !!t && e < t.start), isFuture: Boolean(n ? e > n : !!t && e >= t.end) } } function oo(e, t) { var n = ["fc-day", "fc-day-" + Qe[e.dow]]; return e.isDisabled ? n.push("fc-day-disabled") : (e.isToday && (n.push("fc-day-today"), n.push(t.getClass("today"))), e.isPast && n.push("fc-day-past"), e.isFuture && n.push("fc-day-future"), e.isOther && n.push("fc-day-other")), n } var io = ln({ year: "numeric", month: "long", day: "numeric" }), ao = ln({ week: "long" }); function so(e, t, n, o) { void 0 === n && (n = "day"), void 0 === o && (o = !0); var i = e.dateEnv, a = e.options, s = e.calendarApi, l = i.format(t, "week" === n ? ao : io); if (a.navLinks) { var u = i.toDate(t), c = function (e) { var r = "day" === n ? a.navLinkDayClick : "week" === n ? a.navLinkWeekClick : null; "function" == typeof r ? r.call(s, i.toDate(t), e) : ("string" == typeof r && (n = r), s.zoomTo(t, n)) }; return r({ title: Xe(a.navLinkHint, [l, u], l), "data-navlink": "" }, o ? He(c) : { onClick: c }) } return { "aria-label": l } } var lo, uo = null; function co() { return null === uo && (uo = function () { var e = document.createElement("div"); we(e, { position: "absolute", top: -1e3, left: 0, border: 0, padding: 0, overflow: "scroll", direction: "rtl" }), e.innerHTML = "<div></div>", document.body.appendChild(e); var t = e.firstChild.getBoundingClientRect().left > e.getBoundingClientRect().left; return Ee(e), t }()), uo } function po() { return lo || (lo = function () { var e = document.createElement("div"); e.style.overflow = "scroll", e.style.position = "absolute", e.style.top = "-9999px", e.style.left = "-9999px", document.body.appendChild(e); var t = fo(e); return document.body.removeChild(e), t }()), lo } function fo(e) { return { x: e.offsetHeight - e.clientHeight, y: e.offsetWidth - e.clientWidth } } function ho(e, t) { void 0 === t && (t = !1); var n = window.getComputedStyle(e), r = parseInt(n.borderLeftWidth, 10) || 0, o = parseInt(n.borderRightWidth, 10) || 0, i = parseInt(n.borderTopWidth, 10) || 0, a = parseInt(n.borderBottomWidth, 10) || 0, s = fo(e), l = s.y - r - o, u = { borderLeft: r, borderRight: o, borderTop: i, borderBottom: a, scrollbarBottom: s.x - i - a, scrollbarLeft: 0, scrollbarRight: 0 }; return co() && "rtl" === n.direction ? u.scrollbarLeft = l : u.scrollbarRight = l, t && (u.paddingLeft = parseInt(n.paddingLeft, 10) || 0, u.paddingRight = parseInt(n.paddingRight, 10) || 0, u.paddingTop = parseInt(n.paddingTop, 10) || 0, u.paddingBottom = parseInt(n.paddingBottom, 10) || 0), u } function vo(e, t, n) { void 0 === t && (t = !1); var r = n ? e.getBoundingClientRect() : go(e), o = ho(e, t), i = { left: r.left + o.borderLeft + o.scrollbarLeft, right: r.right - o.borderRight - o.scrollbarRight, top: r.top + o.borderTop, bottom: r.bottom - o.borderBottom - o.scrollbarBottom }; return t && (i.left += o.paddingLeft, i.right -= o.paddingRight, i.top += o.paddingTop, i.bottom -= o.paddingBottom), i } function go(e) { var t = e.getBoundingClientRect(); return { left: t.left + window.pageXOffset, top: t.top + window.pageYOffset, right: t.right + window.pageXOffset, bottom: t.bottom + window.pageYOffset } } function mo(e) { for (var t = []; e instanceof HTMLElement;) { var n = window.getComputedStyle(e); if ("fixed" === n.position) break; /(auto|scroll)/.test(n.overflow + n.overflowY + n.overflowX) && t.push(e), e = e.parentNode } return t } function yo(e, t, n) { var r = !1, o = function () { r || (r = !0, t.apply(this, arguments)) }, i = function () { r || (r = !0, n && n.apply(this, arguments)) }, a = e(o, i); a && "function" == typeof a.then && a.then(o, i) } var Eo = function () { function e() { this.handlers = {}, this.thisContext = null } return e.prototype.setThisContext = function (e) { this.thisContext = e }, e.prototype.setOptions = function (e) { this.options = e }, e.prototype.on = function (e, t) { !function (e, t, n) { (e[t] || (e[t] = [])).push(n) }(this.handlers, e, t) }, e.prototype.off = function (e, t) { !function (e, t, n) { n ? e[t] && (e[t] = e[t].filter((function (e) { return e !== n }))) : delete e[t] }(this.handlers, e, t) }, e.prototype.trigger = function (e) { for (var t = [], n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; for (var r = this.handlers[e] || [], o = this.options && this.options[e], i = [].concat(o || [], r), a = 0, s = i; a < s.length; a++) { var l = s[a]; l.apply(this.thisContext, t) } }, e.prototype.hasHandlers = function (e) { return Boolean(this.handlers[e] && this.handlers[e].length || this.options && this.options[e]) }, e }(); var So = function () { function e(e, t, n, r) { this.els = t; var o = this.originClientRect = e.getBoundingClientRect(); n && this.buildElHorizontals(o.left), r && this.buildElVerticals(o.top) } return e.prototype.buildElHorizontals = function (e) { for (var t = [], n = [], r = 0, o = this.els; r < o.length; r++) { var i = o[r].getBoundingClientRect(); t.push(i.left - e), n.push(i.right - e) } this.lefts = t, this.rights = n }, e.prototype.buildElVerticals = function (e) { for (var t = [], n = [], r = 0, o = this.els; r < o.length; r++) { var i = o[r].getBoundingClientRect(); t.push(i.top - e), n.push(i.bottom - e) } this.tops = t, this.bottoms = n }, e.prototype.leftToIndex = function (e) { var t, n = this.lefts, r = this.rights, o = n.length; for (t = 0; t < o; t += 1)if (e >= n[t] && e < r[t]) return t }, e.prototype.topToIndex = function (e) { var t, n = this.tops, r = this.bottoms, o = n.length; for (t = 0; t < o; t += 1)if (e >= n[t] && e < r[t]) return t }, e.prototype.getWidth = function (e) { return this.rights[e] - this.lefts[e] }, e.prototype.getHeight = function (e) { return this.bottoms[e] - this.tops[e] }, e }(), bo = function () { function e() { } return e.prototype.getMaxScrollTop = function () { return this.getScrollHeight() - this.getClientHeight() }, e.prototype.getMaxScrollLeft = function () { return this.getScrollWidth() - this.getClientWidth() }, e.prototype.canScrollVertically = function () { return this.getMaxScrollTop() > 0 }, e.prototype.canScrollHorizontally = function () { return this.getMaxScrollLeft() > 0 }, e.prototype.canScrollUp = function () { return this.getScrollTop() > 0 }, e.prototype.canScrollDown = function () { return this.getScrollTop() < this.getMaxScrollTop() }, e.prototype.canScrollLeft = function () { return this.getScrollLeft() > 0 }, e.prototype.canScrollRight = function () { return this.getScrollLeft() < this.getMaxScrollLeft() }, e }(), Do = function (e) { function t(t) { var n = e.call(this) || this; return n.el = t, n } return n(t, e), t.prototype.getScrollTop = function () { return this.el.scrollTop }, t.prototype.getScrollLeft = function () { return this.el.scrollLeft }, t.prototype.setScrollTop = function (e) { this.el.scrollTop = e }, t.prototype.setScrollLeft = function (e) { this.el.scrollLeft = e }, t.prototype.getScrollWidth = function () { return this.el.scrollWidth }, t.prototype.getScrollHeight = function () { return this.el.scrollHeight }, t.prototype.getClientHeight = function () { return this.el.clientHeight }, t.prototype.getClientWidth = function () { return this.el.clientWidth }, t }(bo), Co = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.getScrollTop = function () { return window.pageYOffset }, t.prototype.getScrollLeft = function () { return window.pageXOffset }, t.prototype.setScrollTop = function (e) { window.scroll(window.pageXOffset, e) }, t.prototype.setScrollLeft = function (e) { window.scroll(e, window.pageYOffset) }, t.prototype.getScrollWidth = function () { return document.documentElement.scrollWidth }, t.prototype.getScrollHeight = function () { return document.documentElement.scrollHeight }, t.prototype.getClientHeight = function () { return document.documentElement.clientHeight }, t.prototype.getClientWidth = function () { return document.documentElement.clientWidth }, t }(bo), wo = function () { function e(e) { this.iconOverrideOption && this.setIconOverride(e[this.iconOverrideOption]) } return e.prototype.setIconOverride = function (e) { var t, n; if ("object" == typeof e && e) { for (n in t = r({}, this.iconClasses), e) t[n] = this.applyIconOverridePrefix(e[n]); this.iconClasses = t } else !1 === e && (this.iconClasses = {}) }, e.prototype.applyIconOverridePrefix = function (e) { var t = this.iconOverridePrefix; return t && 0 !== e.indexOf(t) && (e = t + e), e }, e.prototype.getClass = function (e) { return this.classes[e] || "" }, e.prototype.getIconClass = function (e, t) { var n; return (n = t && this.rtlIconClasses && this.rtlIconClasses[e] || this.iconClasses[e]) ? this.baseIconClass + " " + n : "" }, e.prototype.getCustomButtonIconClass = function (e) { var t; return this.iconOverrideCustomButtonOption && (t = e[this.iconOverrideCustomButtonOption]) ? this.baseIconClass + " " + this.applyIconOverridePrefix(t) : "" }, e }(); if (wo.prototype.classes = {}, wo.prototype.iconClasses = {}, wo.prototype.baseIconClass = "", wo.prototype.iconOverridePrefix = "", "undefined" == typeof FullCalendarVDom) throw new Error("Please import the top-level fullcalendar lib before attempting to import a plugin."); var Ro = FullCalendarVDom.Component, _o = FullCalendarVDom.createElement, To = FullCalendarVDom.render, ko = FullCalendarVDom.createRef, xo = FullCalendarVDom.Fragment, Mo = FullCalendarVDom.createContext, Io = FullCalendarVDom.createPortal, Po = FullCalendarVDom.flushToDom, No = FullCalendarVDom.unmountComponentAtNode, Ho = function () { function e(e, t, n, o) { var i = this; this.execFunc = e, this.emitter = t, this.scrollTime = n, this.scrollTimeReset = o, this.handleScrollRequest = function (e) { i.queuedRequest = r({}, i.queuedRequest || {}, e), i.drain() }, t.on("_scrollRequest", this.handleScrollRequest), this.fireInitialScroll() } return e.prototype.detach = function () { this.emitter.off("_scrollRequest", this.handleScrollRequest) }, e.prototype.update = function (e) { e && this.scrollTimeReset ? this.fireInitialScroll() : this.drain() }, e.prototype.fireInitialScroll = function () { this.handleScrollRequest({ time: this.scrollTime }) }, e.prototype.drain = function () { this.queuedRequest && this.execFunc(this.queuedRequest) && (this.queuedRequest = null) }, e }(), Oo = Mo({}); function Ao(e, t, n, r, o, i, a, s, l, u, c, d, p) { return { dateEnv: o, options: n, pluginHooks: a, emitter: u, dispatch: s, getCurrentData: l, calendarApi: c, viewSpec: e, viewApi: t, dateProfileGenerator: r, theme: i, isRtl: "rtl" === n.direction, addResizeHandler: function (e) { u.on("_resize", e) }, removeResizeHandler: function (e) { u.off("_resize", e) }, createScrollResponder: function (e) { return new Ho(e, u, Nt(n.scrollTime), n.scrollTimeReset) }, registerInteractiveComponent: d, unregisterInteractiveComponent: p } } var Lo = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.shouldComponentUpdate = function (e, t) { return this.debug && console.log(Rt(e, this.props), Rt(t, this.state)), !_t(this.props, e, this.propEquality) || !_t(this.state, t, this.stateEquality) }, t.addPropsEquality = Wo, t.addStateEquality = Vo, t.contextType = Oo, t }(Ro); Lo.prototype.propEquality = {}, Lo.prototype.stateEquality = {}; var Uo = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.contextType = Oo, t }(Lo); function Wo(e) { var t = Object.create(this.prototype.propEquality); r(t, e), this.prototype.propEquality = t } function Vo(e) { var t = Object.create(this.prototype.stateEquality); r(t, e), this.prototype.stateEquality = t } function Fo(e, t) { "function" == typeof e ? e(t) : e && (e.current = t) } var Bo = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.uid = Le(), t } return n(t, e), t.prototype.prepareHits = function () { }, t.prototype.queryHit = function (e, t, n, r) { return null }, t.prototype.isValidSegDownEl = function (e) { return !this.props.eventDrag && !this.props.eventResize && !Se(e, ".fc-event-mirror") }, t.prototype.isValidDateDownEl = function (e) { return !(Se(e, ".fc-event:not(.fc-bg-event)") || Se(e, ".fc-more-link") || Se(e, "a[data-navlink]") || Se(e, ".fc-popover")) }, t }(Uo); function zo(e) { return { id: Le(), deps: e.deps || [], reducers: e.reducers || [], isLoadingFuncs: e.isLoadingFuncs || [], contextInit: [].concat(e.contextInit || []), eventRefiners: e.eventRefiners || {}, eventDefMemberAdders: e.eventDefMemberAdders || [], eventSourceRefiners: e.eventSourceRefiners || {}, isDraggableTransformers: e.isDraggableTransformers || [], eventDragMutationMassagers: e.eventDragMutationMassagers || [], eventDefMutationAppliers: e.eventDefMutationAppliers || [], dateSelectionTransformers: e.dateSelectionTransformers || [], datePointTransforms: e.datePointTransforms || [], dateSpanTransforms: e.dateSpanTransforms || [], views: e.views || {}, viewPropsTransformers: e.viewPropsTransformers || [], isPropsValid: e.isPropsValid || null, externalDefTransforms: e.externalDefTransforms || [], viewContainerAppends: e.viewContainerAppends || [], eventDropTransformers: e.eventDropTransformers || [], componentInteractions: e.componentInteractions || [], calendarInteractions: e.calendarInteractions || [], themeClasses: e.themeClasses || {}, eventSourceDefs: e.eventSourceDefs || [], cmdFormatter: e.cmdFormatter, recurringTypes: e.recurringTypes || [], namedTimeZonedImpl: e.namedTimeZonedImpl, initialView: e.initialView || "", elementDraggingImpl: e.elementDraggingImpl, optionChangeHandlers: e.optionChangeHandlers || {}, scrollGridImpl: e.scrollGridImpl || null, contentTypeHandlers: e.contentTypeHandlers || {}, listenerRefiners: e.listenerRefiners || {}, optionRefiners: e.optionRefiners || {}, propSetHandlers: e.propSetHandlers || {} } } function jo() { var e, t = [], n = []; return function (o, i) { return e && Gt(o, t) && Gt(i, n) || (e = function (e, t) { var n = {}, o = { reducers: [], isLoadingFuncs: [], contextInit: [], eventRefiners: {}, eventDefMemberAdders: [], eventSourceRefiners: {}, isDraggableTransformers: [], eventDragMutationMassagers: [], eventDefMutationAppliers: [], dateSelectionTransformers: [], datePointTransforms: [], dateSpanTransforms: [], views: {}, viewPropsTransformers: [], isPropsValid: null, externalDefTransforms: [], viewContainerAppends: [], eventDropTransformers: [], componentInteractions: [], calendarInteractions: [], themeClasses: {}, eventSourceDefs: [], cmdFormatter: null, recurringTypes: [], namedTimeZonedImpl: null, initialView: "", elementDraggingImpl: null, optionChangeHandlers: {}, scrollGridImpl: null, contentTypeHandlers: {}, listenerRefiners: {}, optionRefiners: {}, propSetHandlers: {} }; function i(e) { for (var t = 0, a = e; t < a.length; t++) { var s = a[t]; n[s.id] || (n[s.id] = !0, i(s.deps), u = s, o = { reducers: (l = o).reducers.concat(u.reducers), isLoadingFuncs: l.isLoadingFuncs.concat(u.isLoadingFuncs), contextInit: l.contextInit.concat(u.contextInit), eventRefiners: r(r({}, l.eventRefiners), u.eventRefiners), eventDefMemberAdders: l.eventDefMemberAdders.concat(u.eventDefMemberAdders), eventSourceRefiners: r(r({}, l.eventSourceRefiners), u.eventSourceRefiners), isDraggableTransformers: l.isDraggableTransformers.concat(u.isDraggableTransformers), eventDragMutationMassagers: l.eventDragMutationMassagers.concat(u.eventDragMutationMassagers), eventDefMutationAppliers: l.eventDefMutationAppliers.concat(u.eventDefMutationAppliers), dateSelectionTransformers: l.dateSelectionTransformers.concat(u.dateSelectionTransformers), datePointTransforms: l.datePointTransforms.concat(u.datePointTransforms), dateSpanTransforms: l.dateSpanTransforms.concat(u.dateSpanTransforms), views: r(r({}, l.views), u.views), viewPropsTransformers: l.viewPropsTransformers.concat(u.viewPropsTransformers), isPropsValid: u.isPropsValid || l.isPropsValid, externalDefTransforms: l.externalDefTransforms.concat(u.externalDefTransforms), viewContainerAppends: l.viewContainerAppends.concat(u.viewContainerAppends), eventDropTransformers: l.eventDropTransformers.concat(u.eventDropTransformers), calendarInteractions: l.calendarInteractions.concat(u.calendarInteractions), componentInteractions: l.componentInteractions.concat(u.componentInteractions), themeClasses: r(r({}, l.themeClasses), u.themeClasses), eventSourceDefs: l.eventSourceDefs.concat(u.eventSourceDefs), cmdFormatter: u.cmdFormatter || l.cmdFormatter, recurringTypes: l.recurringTypes.concat(u.recurringTypes), namedTimeZonedImpl: u.namedTimeZonedImpl || l.namedTimeZonedImpl, initialView: l.initialView || u.initialView, elementDraggingImpl: l.elementDraggingImpl || u.elementDraggingImpl, optionChangeHandlers: r(r({}, l.optionChangeHandlers), u.optionChangeHandlers), scrollGridImpl: u.scrollGridImpl || l.scrollGridImpl, contentTypeHandlers: r(r({}, l.contentTypeHandlers), u.contentTypeHandlers), listenerRefiners: r(r({}, l.listenerRefiners), u.listenerRefiners), optionRefiners: r(r({}, l.optionRefiners), u.optionRefiners), propSetHandlers: r(r({}, l.propSetHandlers), u.propSetHandlers) }) } var l, u } return e && i(e), i(t), o }(o, i)), t = o, n = i, e } } var Go = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t }(wo); function qo(e, t, n, o) { if (t[e]) return t[e]; var i = function (e, t, n, o) { var i = n[e], a = o[e], s = function (e) { return i && null !== i[e] ? i[e] : a && null !== a[e] ? a[e] : null }, l = s("component"), u = s("superType"), c = null; if (u) { if (u === e) throw new Error("Can't have a custom view type that references itself"); c = qo(u, t, n, o) } !l && c && (l = c.component); if (!l) return null; return { type: e, component: l, defaults: r(r({}, c ? c.defaults : {}), i ? i.rawOptions : {}), overrides: r(r({}, c ? c.overrides : {}), a ? a.rawOptions : {}) } }(e, t, n, o); return i && (t[e] = i), i } Go.prototype.classes = { root: "fc-theme-standard", tableCellShaded: "fc-cell-shaded", buttonGroup: "fc-button-group", button: "fc-button fc-button-primary", buttonActive: "fc-button-active" }, Go.prototype.baseIconClass = "fc-icon", Go.prototype.iconClasses = { close: "fc-icon-x", prev: "fc-icon-chevron-left", next: "fc-icon-chevron-right", prevYear: "fc-icon-chevrons-left", nextYear: "fc-icon-chevrons-right" }, Go.prototype.rtlIconClasses = { prev: "fc-icon-chevron-right", next: "fc-icon-chevron-left", prevYear: "fc-icon-chevrons-right", nextYear: "fc-icon-chevrons-left" }, Go.prototype.iconOverrideOption = "buttonIcons", Go.prototype.iconOverrideCustomButtonOption = "icon", Go.prototype.iconOverridePrefix = "fc-icon-"; var Yo = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.rootElRef = ko(), t.handleRootEl = function (e) { Fo(t.rootElRef, e), t.props.elRef && Fo(t.props.elRef, e) }, t } return n(t, e), t.prototype.render = function () { var e = this, t = this.props, n = t.hookProps; return _o($o, { hookProps: n, didMount: t.didMount, willUnmount: t.willUnmount, elRef: this.handleRootEl }, (function (r) { return _o(Xo, { hookProps: n, content: t.content, defaultContent: t.defaultContent, backupElRef: e.rootElRef }, (function (e, o) { return t.children(r, Qo(t.classNames, n), e, o) })) })) }, t }(Uo), Zo = Mo(0); function Xo(e) { return _o(Zo.Consumer, null, (function (t) { return _o(Ko, r({ renderId: t }, e)) })) } var Ko = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.innerElRef = ko(), t } return n(t, e), t.prototype.render = function () { return this.props.children(this.innerElRef, this.renderInnerContent()) }, t.prototype.componentDidMount = function () { this.updateCustomContent() }, t.prototype.componentDidUpdate = function () { this.updateCustomContent() }, t.prototype.componentWillUnmount = function () { this.customContentInfo && this.customContentInfo.destroy && this.customContentInfo.destroy() }, t.prototype.renderInnerContent = function () { var e = this.customContentInfo, t = this.getInnerContent(), n = this.getContentMeta(t); return e && e.contentKey === n.contentKey ? e && (e.contentVal = t[n.contentKey]) : (e && (e.destroy && e.destroy(), e = this.customContentInfo = null), n.contentKey && (e = this.customContentInfo = r({ contentKey: n.contentKey, contentVal: t[n.contentKey] }, n.buildLifecycleFuncs()))), e ? [] : t }, t.prototype.getInnerContent = function () { var e = this.props, t = ei(e.content, e.hookProps); return void 0 === t && (t = ei(e.defaultContent, e.hookProps)), null == t ? null : t }, t.prototype.getContentMeta = function (e) { var t = this.context.pluginHooks.contentTypeHandlers, n = "", r = null; if (e) for (var o in t) if (void 0 !== e[o]) { n = o, r = t[o]; break } return { contentKey: n, buildLifecycleFuncs: r } }, t.prototype.updateCustomContent = function () { this.customContentInfo && this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, this.customContentInfo.contentVal) }, t }(Uo), $o = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.handleRootEl = function (e) { t.rootEl = e, t.props.elRef && Fo(t.props.elRef, e) }, t } return n(t, e), t.prototype.render = function () { return this.props.children(this.handleRootEl) }, t.prototype.componentDidMount = function () { var e = this.props.didMount; e && e(r(r({}, this.props.hookProps), { el: this.rootEl })) }, t.prototype.componentWillUnmount = function () { var e = this.props.willUnmount; e && e(r(r({}, this.props.hookProps), { el: this.rootEl })) }, t }(Uo); function Jo() { var e, t, n = []; return function (r, o) { return t && wt(t, o) && r === e || (e = r, t = o, n = Qo(r, o)), n } } function Qo(e, t) { return "function" == typeof e && (e = e(t)), Rn(e) } function ei(e, t) { return "function" == typeof e ? e(t, _o) : e } var ti = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.normalizeClassNames = Jo(), t } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.context, n = t.options, r = { view: t.viewApi }, o = this.normalizeClassNames(n.viewClassNames, r); return _o($o, { hookProps: r, didMount: n.viewDidMount, willUnmount: n.viewWillUnmount, elRef: e.elRef }, (function (t) { return e.children(t, ["fc-" + e.viewSpec.type + "-view", "fc-view"].concat(o)) })) }, t }(Uo); function ni(e) { return bt(e, ri) } function ri(e) { var t, n = "function" == typeof e ? { component: e } : e, o = n.component; return n.content && (t = n, o = function (e) { return _o(Oo.Consumer, null, (function (n) { return _o(ti, { viewSpec: n.viewSpec }, (function (o, i) { var a = r(r({}, e), { nextDayThreshold: n.options.nextDayThreshold }); return _o(Yo, { hookProps: a, classNames: t.classNames, content: t.content, didMount: t.didMount, willUnmount: t.willUnmount, elRef: o }, (function (e, t, n, r) { return _o("div", { className: i.concat(t).join(" "), ref: e }, r) })) })) })) }), { superType: n.type, component: o, rawOptions: n } } function oi(e, t, n, o) { var i = ni(e), a = ni(t.views); return bt(function (e, t) { var n, r = {}; for (n in e) qo(n, r, e, t); for (n in t) qo(n, r, e, t); return r }(i, a), (function (e) { return function (e, t, n, o, i) { var a = e.overrides.duration || e.defaults.duration || o.duration || n.duration, s = null, l = "", u = "", c = {}; if (a && (s = function (e) { var t = JSON.stringify(e), n = ii[t]; void 0 === n && (n = Nt(e), ii[t] = n); return n }(a))) { var d = Vt(s); l = d.unit, 1 === d.value && (u = l, c = t[l] ? t[l].rawOptions : {}) } var p = function (t) { var n = t.buttonText || {}, r = e.defaults.buttonTextKey; return null != r && null != n[r] ? n[r] : null != n[e.type] ? n[e.type] : null != n[u] ? n[u] : null }, f = function (t) { var n = t.buttonHints || {}, r = e.defaults.buttonTextKey; return null != r && null != n[r] ? n[r] : null != n[e.type] ? n[e.type] : null != n[u] ? n[u] : null }; return { type: e.type, component: e.component, duration: s, durationUnit: l, singleUnit: u, optionDefaults: e.defaults, optionOverrides: r(r({}, c), e.overrides), buttonTextOverride: p(o) || p(n) || e.overrides.buttonText, buttonTextDefault: p(i) || e.defaults.buttonText || p(cn) || e.type, buttonTitleOverride: f(o) || f(n) || e.overrides.buttonHint, buttonTitleDefault: f(i) || e.defaults.buttonHint || f(cn) } }(e, a, t, n, o) })) } var ii = {}; var ai = function () { function e(e) { this.props = e, this.nowDate = Tr(e.nowInput, e.dateEnv), this.initHiddenDays() } return e.prototype.buildPrev = function (e, t, n) { var r = this.props.dateEnv, o = r.subtract(r.startOf(t, e.currentRangeUnit), e.dateIncrement); return this.build(o, -1, n) }, e.prototype.buildNext = function (e, t, n) { var r = this.props.dateEnv, o = r.add(r.startOf(t, e.currentRangeUnit), e.dateIncrement); return this.build(o, 1, n) }, e.prototype.build = function (e, t, n) { void 0 === n && (n = !0); var r, o, i, a, s, l, u, c, d = this.props; return r = this.buildValidRange(), r = this.trimHiddenDays(r), n && (u = e, e = null != (c = r).start && u < c.start ? c.start : null != c.end && u >= c.end ? new Date(c.end.valueOf() - 1) : u), o = this.buildCurrentRangeInfo(e, t), i = /^(year|month|week|day)$/.test(o.unit), a = this.buildRenderRange(this.trimHiddenDays(o.range), o.unit, i), s = a = this.trimHiddenDays(a), d.showNonCurrentDates || (s = jn(s, o.range)), s = jn(s = this.adjustActiveRange(s), r), l = qn(o.range, r), { validRange: r, currentRange: o.range, currentRangeUnit: o.unit, isRangeAllDay: i, activeRange: s, renderRange: a, slotMinTime: d.slotMinTime, slotMaxTime: d.slotMaxTime, isValid: l, dateIncrement: this.buildDateIncrement(o.duration) } }, e.prototype.buildValidRange = function () { var e = this.props.validRangeInput, t = "function" == typeof e ? e.call(this.props.calendarApi, this.nowDate) : e; return this.refineRange(t) || { start: null, end: null } }, e.prototype.buildCurrentRangeInfo = function (e, t) { var n, r = this.props, o = null, i = null, a = null; return r.duration ? (o = r.duration, i = r.durationUnit, a = this.buildRangeFromDuration(e, t, o, i)) : (n = this.props.dayCount) ? (i = "day", a = this.buildRangeFromDayCount(e, t, n)) : (a = this.buildCustomVisibleRange(e)) ? i = r.dateEnv.greatestWholeUnit(a.start, a.end).unit : (i = Vt(o = this.getFallbackDuration()).unit, a = this.buildRangeFromDuration(e, t, o, i)), { duration: o, unit: i, range: a } }, e.prototype.getFallbackDuration = function () { return Nt({ day: 1 }) }, e.prototype.adjustActiveRange = function (e) { var t = this.props, n = t.dateEnv, r = t.usesMinMaxTime, o = t.slotMinTime, i = t.slotMaxTime, a = e.start, s = e.end; return r && (Lt(o) < 0 && (a = lt(a), a = n.add(a, o)), Lt(i) > 1 && (s = tt(s = lt(s), -1), s = n.add(s, i))), { start: a, end: s } }, e.prototype.buildRangeFromDuration = function (e, t, n, r) { var o, i, a, s = this.props, l = s.dateEnv, u = s.dateAlignment; if (!u) { var c = this.props.dateIncrement; u = c && Ut(c) < Ut(n) ? Vt(c).unit : r } function d() { o = l.startOf(e, u), i = l.add(o, n), a = { start: o, end: i } } return Lt(n) <= 1 && this.isHiddenDay(o) && (o = lt(o = this.skipHiddenDays(o, t))), d(), this.trimHiddenDays(a) || (e = this.skipHiddenDays(e, t), d()), a }, e.prototype.buildRangeFromDayCount = function (e, t, n) { var r, o = this.props, i = o.dateEnv, a = o.dateAlignment, s = 0, l = e; a && (l = i.startOf(l, a)), l = lt(l), r = l = this.skipHiddenDays(l, t); do { r = tt(r, 1), this.isHiddenDay(r) || (s += 1) } while (s < n); return { start: l, end: r } }, e.prototype.buildCustomVisibleRange = function (e) { var t = this.props, n = t.visibleRangeInput, r = "function" == typeof n ? n.call(t.calendarApi, t.dateEnv.toDate(e)) : n, o = this.refineRange(r); return !o || null != o.start && null != o.end ? o : null }, e.prototype.buildRenderRange = function (e, t, n) { return e }, e.prototype.buildDateIncrement = function (e) { var t, n = this.props.dateIncrement; return n || ((t = this.props.dateAlignment) ? Nt(1, t) : e || Nt({ days: 1 })) }, e.prototype.refineRange = function (e) { if (e) { var t = (n = e, r = this.props.dateEnv, o = null, i = null, n.start && (o = r.createMarker(n.start)), n.end && (i = r.createMarker(n.end)), o || i ? o && i && i < o ? null : { start: o, end: i } : null); return t && (t = Wn(t)), t } var n, r, o, i; return null }, e.prototype.initHiddenDays = function () { var e, t = this.props.hiddenDays || [], n = [], r = 0; for (!1 === this.props.weekends && t.push(0, 6), e = 0; e < 7; e += 1)(n[e] = -1 !== t.indexOf(e)) || (r += 1); if (!r) throw new Error("invalid hiddenDays"); this.isHiddenDayHash = n }, e.prototype.trimHiddenDays = function (e) { var t = e.start, n = e.end; return t && (t = this.skipHiddenDays(t)), n && (n = this.skipHiddenDays(n, -1, !0)), null == t || null == n || t < n ? { start: t, end: n } : null }, e.prototype.isHiddenDay = function (e) { return e instanceof Date && (e = e.getUTCDay()), this.isHiddenDayHash[e] }, e.prototype.skipHiddenDays = function (e, t, n) { for (void 0 === t && (t = 1), void 0 === n && (n = !1); this.isHiddenDayHash[(e.getUTCDay() + (n ? t : 0) + 7) % 7];)e = tt(e, t); return e }, e }(); function si(e, t, n) { var r = t ? t.activeRange : null; return ci({}, function (e, t) { var n = _r(t), r = [].concat(e.eventSources || []), o = []; e.initialEvents && r.unshift(e.initialEvents); e.events && r.unshift(e.events); for (var i = 0, a = r; i < a.length; i++) { var s = Rr(a[i], t, n); s && o.push(s) } return o }(e, n), r, n) } function li(e, t, n, o) { var i, a, s = n ? n.activeRange : null; switch (t.type) { case "ADD_EVENT_SOURCES": return ci(e, t.sources, s, o); case "REMOVE_EVENT_SOURCE": return i = e, a = t.sourceId, St(i, (function (e) { return e.sourceId !== a })); case "PREV": case "NEXT": case "CHANGE_DATE": case "CHANGE_VIEW_TYPE": return n ? di(e, s, o) : e; case "FETCH_EVENT_SOURCES": return pi(e, t.sourceIds ? Dt(t.sourceIds) : hi(e, o), s, t.isRefetch || !1, o); case "RECEIVE_EVENTS": case "RECEIVE_EVENT_ERROR": return function (e, t, n, o) { var i, a = e[t]; if (a && n === a.latestFetchId) return r(r({}, e), ((i = {})[t] = r(r({}, a), { isFetching: !1, fetchRange: o }), i)); return e }(e, t.sourceId, t.fetchId, t.fetchRange); case "REMOVE_ALL_EVENT_SOURCES": return {}; default: return e } } function ui(e) { for (var t in e) if (e[t].isFetching) return !0; return !1 } function ci(e, t, n, o) { for (var i = {}, a = 0, s = t; a < s.length; a++) { var l = s[a]; i[l.sourceId] = l } return n && (i = di(i, n, o)), r(r({}, e), i) } function di(e, t, n) { return pi(e, St(e, (function (e) { return function (e, t, n) { if (!vi(e, n)) return !e.latestFetchId; return !n.options.lazyFetching || !e.fetchRange || e.isFetching || t.start < e.fetchRange.start || t.end > e.fetchRange.end }(e, t, n) })), t, !1, n) } function pi(e, t, n, r, o) { var i = {}; for (var a in e) { var s = e[a]; t[a] ? i[a] = fi(s, n, r, o) : i[a] = s } return i } function fi(e, t, n, o) { var i = o.options, a = o.calendarApi, s = o.pluginHooks.eventSourceDefs[e.sourceDefId], l = Le(); return s.fetch({ eventSource: e, range: t, isRefetch: n, context: o }, (function (n) { var r = n.rawEvents; i.eventSourceSuccess && (r = i.eventSourceSuccess.call(a, r, n.xhr) || r), e.success && (r = e.success.call(a, r, n.xhr) || r), o.dispatch({ type: "RECEIVE_EVENTS", sourceId: e.sourceId, fetchId: l, fetchRange: t, rawEvents: r }) }), (function (n) { console.warn(n.message, n), i.eventSourceFailure && i.eventSourceFailure.call(a, n), e.failure && e.failure(n), o.dispatch({ type: "RECEIVE_EVENT_ERROR", sourceId: e.sourceId, fetchId: l, fetchRange: t, error: n }) })), r(r({}, e), { isFetching: !0, latestFetchId: l }) } function hi(e, t) { return St(e, (function (e) { return vi(e, t) })) } function vi(e, t) { return !t.pluginHooks.eventSourceDefs[e.sourceDefId].ignoreRange } function gi(e, t, n, r, o) { switch (t.type) { case "RECEIVE_EVENTS": return function (e, t, n, r, o, i) { if (t && n === t.latestFetchId) { var a = En(function (e, t, n) { var r = n.options.eventDataTransform, o = t ? t.eventDataTransform : null; o && (e = mi(e, o)); r && (e = mi(e, r)); return e }(o, t, i), t, i); return r && (a = xt(a, r, i)), Cn(yi(e, t.sourceId), a) } return e }(e, n[t.sourceId], t.fetchId, t.fetchRange, t.rawEvents, o); case "ADD_EVENTS": return function (e, t, n, r) { n && (t = xt(t, n, r)); return Cn(e, t) }(e, t.eventStore, r ? r.activeRange : null, o); case "RESET_EVENTS": return t.eventStore; case "MERGE_EVENTS": return Cn(e, t.eventStore); case "PREV": case "NEXT": case "CHANGE_DATE": case "CHANGE_VIEW_TYPE": return r ? xt(e, r.activeRange, o) : e; case "REMOVE_EVENTS": return function (e, t) { var n = e.defs, r = e.instances, o = {}, i = {}; for (var a in n) t.defs[a] || (o[a] = n[a]); for (var s in r) !t.instances[s] && o[r[s].defId] && (i[s] = r[s]); return { defs: o, instances: i } }(e, t.eventStore); case "REMOVE_EVENT_SOURCE": return yi(e, t.sourceId); case "REMOVE_ALL_EVENT_SOURCES": return wn(e, (function (e) { return !e.sourceId })); case "REMOVE_ALL_EVENTS": return { defs: {}, instances: {} }; default: return e } } function mi(e, t) { var n; if (t) { n = []; for (var r = 0, o = e; r < o.length; r++) { var i = o[r], a = t(i); a ? n.push(a) : null == a && n.push(i) } } else n = e; return n } function yi(e, t) { return wn(e, (function (e) { return e.sourceId !== t })) } function Ei(e, t) { switch (t.type) { case "UNSELECT_DATES": return null; case "SELECT_DATES": return t.selection; default: return e } } function Si(e, t) { switch (t.type) { case "UNSELECT_EVENT": return ""; case "SELECT_EVENT": return t.eventInstanceId; default: return e } } function bi(e, t) { var n; switch (t.type) { case "UNSET_EVENT_DRAG": return null; case "SET_EVENT_DRAG": return { affectedEvents: (n = t.state).affectedEvents, mutatedEvents: n.mutatedEvents, isEvent: n.isEvent }; default: return e } } function Di(e, t) { var n; switch (t.type) { case "UNSET_EVENT_RESIZE": return null; case "SET_EVENT_RESIZE": return { affectedEvents: (n = t.state).affectedEvents, mutatedEvents: n.mutatedEvents, isEvent: n.isEvent }; default: return e } } function Ci(e, t, n, r, o) { return { header: e.headerToolbar ? wi(e.headerToolbar, e, t, n, r, o) : null, footer: e.footerToolbar ? wi(e.footerToolbar, e, t, n, r, o) : null } } function wi(e, t, n, r, o, i) { var a = {}, s = [], l = !1; for (var u in e) { var c = Ri(e[u], t, n, r, o, i); a[u] = c.widgets, s.push.apply(s, c.viewsWithButtons), l = l || c.hasTitle } return { sectionWidgets: a, viewsWithButtons: s, hasTitle: l } } function Ri(e, t, n, r, o, i) { var a = "rtl" === t.direction, s = t.customButtons || {}, l = n.buttonText || {}, u = t.buttonText || {}, c = n.buttonHints || {}, d = t.buttonHints || {}, p = e ? e.split(" ") : [], f = [], h = !1; return { widgets: p.map((function (e) { return e.split(",").map((function (e) { if ("title" === e) return h = !0, { buttonName: e }; var n, p, v, g, m, y; if (n = s[e]) v = function (e) { n.click && n.click.call(e.target, e, e.target) }, (g = r.getCustomButtonIconClass(n)) || (g = r.getIconClass(e, a)) || (m = n.text), y = n.hint || n.text; else if (p = o[e]) { f.push(e), v = function () { i.changeView(e) }, (m = p.buttonTextOverride) || (g = r.getIconClass(e, a)) || (m = p.buttonTextDefault); var E = p.buttonTextOverride || p.buttonTextDefault; y = Xe(p.buttonTitleOverride || p.buttonTitleDefault || t.viewHint, [E, e], E) } else if (i[e]) if (v = function () { i[e]() }, (m = l[e]) || (g = r.getIconClass(e, a)) || (m = u[e]), "prevYear" === e || "nextYear" === e) { var S = "prevYear" === e ? "prev" : "next"; y = Xe(c[S] || d[S], [u.year || "year", "year"], u[e]) } else y = function (t) { return Xe(c[e] || d[e], [u[t] || t, t], u[e]) }; return { buttonName: e, buttonClick: v, buttonIcon: g, buttonText: m, buttonHint: y } })) })), viewsWithButtons: f, hasTitle: h } } function _i(e, t, n, r, o) { var i = null; "GET" === (e = e.toUpperCase()) ? t = function (e, t) { return e + (-1 === e.indexOf("?") ? "?" : "&") + Ti(t) }(t, n) : i = Ti(n); var a = new XMLHttpRequest; a.open(e, t, !0), "GET" !== e && a.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), a.onload = function () { if (a.status >= 200 && a.status < 400) { var e = !1, t = void 0; try { t = JSON.parse(a.responseText), e = !0 } catch (e) { } e ? r(t, a) : o("Failure parsing JSON", a) } else o("Request failed", a) }, a.onerror = function () { o("Request failed", a) }, a.send(i) } function Ti(e) { var t = []; for (var n in e) t.push(encodeURIComponent(n) + "=" + encodeURIComponent(e[n])); return t.join("&") } function ki(e, t) { for (var n = Ct(t.getCurrentData().eventSources), r = [], o = 0, i = e; o < i.length; o++) { for (var a = i[o], s = !1, l = 0; l < n.length; l += 1)if (n[l]._raw === a) { n.splice(l, 1), s = !0; break } s || r.push(a) } for (var u = 0, c = n; u < c.length; u++) { var d = c[u]; t.dispatch({ type: "REMOVE_EVENT_SOURCE", sourceId: d.sourceId }) } for (var p = 0, f = r; p < f.length; p++) { var h = f[p]; t.calendarApi.addEventSource(h) } } var xi = [zo({ eventSourceDefs: [{ ignoreRange: !0, parseMeta: function (e) { return Array.isArray(e.events) ? e.events : null }, fetch: function (e, t) { t({ rawEvents: e.eventSource.meta }) } }] }), zo({ eventSourceDefs: [{ parseMeta: function (e) { return "function" == typeof e.events ? e.events : null }, fetch: function (e, t, n) { var r = e.context.dateEnv; yo(e.eventSource.meta.bind(null, hr(e.range, r)), (function (e) { t({ rawEvents: e }) }), n) } }] }), zo({ eventSourceRefiners: { method: String, extraParams: yn, startParam: String, endParam: String, timeZoneParam: String }, eventSourceDefs: [{ parseMeta: function (e) { return !e.url || "json" !== e.format && e.format ? null : { url: e.url, format: "json", method: (e.method || "GET").toUpperCase(), extraParams: e.extraParams, startParam: e.startParam, endParam: e.endParam, timeZoneParam: e.timeZoneParam } }, fetch: function (e, t, n) { var o = e.eventSource.meta, i = function (e, t, n) { var o, i, a, s, l = n.dateEnv, u = n.options, c = {}; null == (o = e.startParam) && (o = u.startParam); null == (i = e.endParam) && (i = u.endParam); null == (a = e.timeZoneParam) && (a = u.timeZoneParam); s = "function" == typeof e.extraParams ? e.extraParams() : e.extraParams || {}; r(c, s), c[o] = l.formatIso(t.start), c[i] = l.formatIso(t.end), "local" !== l.timeZone && (c[a] = l.timeZone); return c }(o, e.range, e.context); _i(o.method, o.url, i, (function (e, n) { t({ rawEvents: e, xhr: n }) }), (function (e, t) { n({ message: e, xhr: t }) })) } }] }), zo({ recurringTypes: [{ parse: function (e, t) { if (e.daysOfWeek || e.startTime || e.endTime || e.startRecur || e.endRecur) { var n = { daysOfWeek: e.daysOfWeek || null, startTime: e.startTime || null, endTime: e.endTime || null, startRecur: e.startRecur ? t.createMarker(e.startRecur) : null, endRecur: e.endRecur ? t.createMarker(e.endRecur) : null }, r = void 0; return e.duration && (r = e.duration), !r && e.startTime && e.endTime && (o = e.endTime, i = e.startTime, r = { years: o.years - i.years, months: o.months - i.months, days: o.days - i.days, milliseconds: o.milliseconds - i.milliseconds }), { allDayGuess: Boolean(!e.startTime && !e.endTime), duration: r, typeData: n } } var o, i; return null }, expand: function (e, t, n) { var r = jn(t, { start: e.startRecur, end: e.endRecur }); return r ? function (e, t, n, r) { var o = e ? Dt(e) : null, i = lt(n.start), a = n.end, s = []; for (; i < a;) { var l = void 0; o && !o[i.getUTCDay()] || (l = t ? r.add(i, t) : i, s.push(l)), i = tt(i, 1) } return s }(e.daysOfWeek, e.startTime, r, n) : [] } }], eventRefiners: { daysOfWeek: yn, startTime: Nt, endTime: Nt, duration: Nt, startRecur: yn, endRecur: yn } }), zo({ optionChangeHandlers: { events: function (e, t) { ki([e], t) }, eventSources: ki } }), zo({ isLoadingFuncs: [function (e) { return ui(e.eventSources) }], contentTypeHandlers: { html: function () { var e = null, t = ""; return { render: function (n, r) { n === e && r === t || (n.innerHTML = r), e = n, t = r }, destroy: function () { e.innerHTML = "", e = null, t = "" } } }, domNodes: function () { var e = null, t = []; function n() { t.forEach(Ee), t = [], e = null } return { render: function (r, o) { var i = Array.prototype.slice.call(o); if (r !== e || !Gt(t, i)) { for (var a = 0, s = i; a < s.length; a++) { var l = s[a]; r.appendChild(l) } n() } e = r, t = i }, destroy: n } } }, propSetHandlers: { dateProfile: function (e, t) { t.emitter.trigger("datesSet", r(r({}, hr(e.activeRange, t.dateEnv)), { view: t.viewApi })) }, eventStore: function (e, t) { var n = t.emitter; n.hasHandlers("eventsSet") && n.trigger("eventsSet", Ir(e, t)) } } })]; var Mi = function () { function e(e) { this.drainedOption = e, this.isRunning = !1, this.isDirty = !1, this.pauseDepths = {}, this.timeoutId = 0 } return e.prototype.request = function (e) { this.isDirty = !0, this.isPaused() || (this.clearTimeout(), null == e ? this.tryDrain() : this.timeoutId = setTimeout(this.tryDrain.bind(this), e)) }, e.prototype.pause = function (e) { void 0 === e && (e = ""); var t = this.pauseDepths; t[e] = (t[e] || 0) + 1, this.clearTimeout() }, e.prototype.resume = function (e, t) { void 0 === e && (e = ""); var n = this.pauseDepths; if (e in n) { if (t) delete n[e]; else n[e] -= 1, n[e] <= 0 && delete n[e]; this.tryDrain() } }, e.prototype.isPaused = function () { return Object.keys(this.pauseDepths).length }, e.prototype.tryDrain = function () { if (!this.isRunning && !this.isPaused()) { for (this.isRunning = !0; this.isDirty;)this.isDirty = !1, this.drained(); this.isRunning = !1 } }, e.prototype.clear = function () { this.clearTimeout(), this.isDirty = !1, this.pauseDepths = {} }, e.prototype.clearTimeout = function () { this.timeoutId && (clearTimeout(this.timeoutId), this.timeoutId = 0) }, e.prototype.drained = function () { this.drainedOption && this.drainedOption() }, e }(), Ii = function () { function e(e, t) { this.runTaskOption = e, this.drainedOption = t, this.queue = [], this.delayedRunner = new Mi(this.drain.bind(this)) } return e.prototype.request = function (e, t) { this.queue.push(e), this.delayedRunner.request(t) }, e.prototype.pause = function (e) { this.delayedRunner.pause(e) }, e.prototype.resume = function (e, t) { this.delayedRunner.resume(e, t) }, e.prototype.drain = function () { for (var e = this.queue; e.length;) { for (var t = [], n = void 0; n = e.shift();)this.runTask(n), t.push(n); this.drained(t) } }, e.prototype.runTask = function (e) { this.runTaskOption && this.runTaskOption(e) }, e.prototype.drained = function (e) { this.drainedOption && this.drainedOption(e) }, e }(); function Pi(e, t, n) { var r; return r = /^(year|month)$/.test(e.currentRangeUnit) ? e.currentRange : e.activeRange, n.formatRange(r.start, r.end, ln(t.titleFormat || function (e) { var t = e.currentRangeUnit; if ("year" === t) return { year: "numeric" }; if ("month" === t) return { year: "numeric", month: "long" }; var n = st(e.currentRange.start, e.currentRange.end); if (null !== n && n > 1) return { year: "numeric", month: "short", day: "numeric" }; return { year: "numeric", month: "long", day: "numeric" } }(e)), { isEndExclusive: e.isRangeAllDay, defaultSeparator: t.titleRangeSeparator }) } var Ni = function () { function e(e) { var t = this; this.computeOptionsData = qt(this._computeOptionsData), this.computeCurrentViewData = qt(this._computeCurrentViewData), this.organizeRawLocales = qt(Fr), this.buildLocale = qt(Br), this.buildPluginHooks = jo(), this.buildDateEnv = qt(Hi), this.buildTheme = qt(Oi), this.parseToolbars = qt(Ci), this.buildViewSpecs = qt(oi), this.buildDateProfileGenerator = Yt(Ai), this.buildViewApi = qt(Li), this.buildViewUiProps = Yt(Vi), this.buildEventUiBySource = qt(Ui, wt), this.buildEventUiBases = qt(Wi), this.parseContextBusinessHours = Yt(Bi), this.buildTitle = qt(Pi), this.emitter = new Eo, this.actionRunner = new Ii(this._handleAction.bind(this), this.updateData.bind(this)), this.currentCalendarOptionsInput = {}, this.currentCalendarOptionsRefined = {}, this.currentViewOptionsInput = {}, this.currentViewOptionsRefined = {}, this.currentCalendarOptionsRefiners = {}, this.getCurrentData = function () { return t.data }, this.dispatch = function (e) { t.actionRunner.request(e) }, this.props = e, this.actionRunner.pause(); var n = {}, o = this.computeOptionsData(e.optionOverrides, n, e.calendarApi), i = o.calendarOptions.initialView || o.pluginHooks.initialView, a = this.computeCurrentViewData(i, o, e.optionOverrides, n); e.calendarApi.currentDataManager = this, this.emitter.setThisContext(e.calendarApi), this.emitter.setOptions(a.options); var s, l, u, c = (s = o.calendarOptions, l = o.dateEnv, null != (u = s.initialDate) ? l.createMarker(u) : Tr(s.now, l)), d = a.dateProfileGenerator.build(c); Zn(d.activeRange, c) || (c = d.currentRange.start); for (var p = { dateEnv: o.dateEnv, options: o.calendarOptions, pluginHooks: o.pluginHooks, calendarApi: e.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, f = 0, h = o.pluginHooks.contextInit; f < h.length; f++) { (0, h[f])(p) } for (var v = si(o.calendarOptions, d, p), g = { dynamicOptionOverrides: n, currentViewType: i, currentDate: c, dateProfile: d, businessHours: this.parseContextBusinessHours(p), eventSources: v, eventUiBases: {}, eventStore: { defs: {}, instances: {} }, renderableEventStore: { defs: {}, instances: {} }, dateSelection: null, eventSelection: "", eventDrag: null, eventResize: null, selectionConfig: this.buildViewUiProps(p).selectionConfig }, m = r(r({}, p), g), y = 0, E = o.pluginHooks.reducers; y < E.length; y++) { var S = E[y]; r(g, S(null, null, m)) } Fi(g, p) && this.emitter.trigger("loading", !0), this.state = g, this.updateData(), this.actionRunner.resume() } return e.prototype.resetOptions = function (e, t) { var n = this.props; n.optionOverrides = t ? r(r({}, n.optionOverrides), e) : e, this.actionRunner.request({ type: "NOTHING" }) }, e.prototype._handleAction = function (e) { var t = this, n = t.props, o = t.state, i = t.emitter, a = function (e, t) { var n; switch (t.type) { case "SET_OPTION": return r(r({}, e), ((n = {})[t.optionName] = t.rawOptionValue, n)); default: return e } }(o.dynamicOptionOverrides, e), s = this.computeOptionsData(n.optionOverrides, a, n.calendarApi), l = function (e, t) { switch (t.type) { case "CHANGE_VIEW_TYPE": e = t.viewType }return e }(o.currentViewType, e), u = this.computeCurrentViewData(l, s, n.optionOverrides, a); n.calendarApi.currentDataManager = this, i.setThisContext(n.calendarApi), i.setOptions(u.options); var c = { dateEnv: s.dateEnv, options: s.calendarOptions, pluginHooks: s.pluginHooks, calendarApi: n.calendarApi, dispatch: this.dispatch, emitter: i, getCurrentData: this.getCurrentData }, d = o.currentDate, p = o.dateProfile; this.data && this.data.dateProfileGenerator !== u.dateProfileGenerator && (p = u.dateProfileGenerator.build(d)), p = function (e, t, n, r) { var o; switch (t.type) { case "CHANGE_VIEW_TYPE": return r.build(t.dateMarker || n); case "CHANGE_DATE": return r.build(t.dateMarker); case "PREV": if ((o = r.buildPrev(e, n)).isValid) return o; break; case "NEXT": if ((o = r.buildNext(e, n)).isValid) return o }return e }(p, e, d = function (e, t) { switch (t.type) { case "CHANGE_DATE": return t.dateMarker; default: return e } }(d, e), u.dateProfileGenerator), "PREV" !== e.type && "NEXT" !== e.type && Zn(p.currentRange, d) || (d = p.currentRange.start); for (var f = li(o.eventSources, e, p, c), h = gi(o.eventStore, e, f, p, c), v = ui(f) && !u.options.progressiveEventRendering && o.renderableEventStore || h, g = this.buildViewUiProps(c), m = g.eventUiSingleBase, y = g.selectionConfig, E = this.buildEventUiBySource(f), S = { dynamicOptionOverrides: a, currentViewType: l, currentDate: d, dateProfile: p, eventSources: f, eventStore: h, renderableEventStore: v, selectionConfig: y, eventUiBases: this.buildEventUiBases(v.defs, m, E), businessHours: this.parseContextBusinessHours(c), dateSelection: Ei(o.dateSelection, e), eventSelection: Si(o.eventSelection, e), eventDrag: bi(o.eventDrag, e), eventResize: Di(o.eventResize, e) }, b = r(r({}, c), S), D = 0, C = s.pluginHooks.reducers; D < C.length; D++) { var w = C[D]; r(S, w(o, e, b)) } var R = Fi(o, c), _ = Fi(S, c); !R && _ ? i.trigger("loading", !0) : R && !_ && i.trigger("loading", !1), this.state = S, n.onAction && n.onAction(e) }, e.prototype.updateData = function () { var e, t, n, o, i, a, s, l, u, c = this.props, d = this.state, p = this.data, f = this.computeOptionsData(c.optionOverrides, d.dynamicOptionOverrides, c.calendarApi), h = this.computeCurrentViewData(d.currentViewType, f, c.optionOverrides, d.dynamicOptionOverrides), v = this.data = r(r(r({ viewTitle: this.buildTitle(d.dateProfile, h.options, f.dateEnv), calendarApi: c.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, f), h), d), g = f.pluginHooks.optionChangeHandlers, m = p && p.calendarOptions, y = f.calendarOptions; if (m && m !== y) for (var E in m.timeZone !== y.timeZone && (d.eventSources = v.eventSources = (a = v.eventSources, s = d.dateProfile, l = v, u = s ? s.activeRange : null, pi(a, hi(a, l), u, !0, l)), d.eventStore = v.eventStore = (e = v.eventStore, t = p.dateEnv, n = v.dateEnv, o = e.defs, i = bt(e.instances, (function (e) { var i = o[e.defId]; return i.allDay || i.recurringDef ? e : r(r({}, e), { range: { start: n.createMarker(t.toDate(e.range.start, e.forcedStartTzo)), end: n.createMarker(t.toDate(e.range.end, e.forcedEndTzo)) }, forcedStartTzo: n.canComputeOffset ? null : e.forcedStartTzo, forcedEndTzo: n.canComputeOffset ? null : e.forcedEndTzo }) })), { defs: o, instances: i })), g) m[E] !== y[E] && g[E](y[E], v); c.onData && c.onData(v) }, e.prototype._computeOptionsData = function (e, t, n) { var r = this.processRawCalendarOptions(e, t), o = r.refinedOptions, i = r.pluginHooks, a = r.localeDefaults, s = r.availableLocaleData; zi(r.extra); var l = this.buildDateEnv(o.timeZone, o.locale, o.weekNumberCalculation, o.firstDay, o.weekText, i, s, o.defaultRangeSeparator), u = this.buildViewSpecs(i.views, e, t, a), c = this.buildTheme(o, i); return { calendarOptions: o, pluginHooks: i, dateEnv: l, viewSpecs: u, theme: c, toolbarConfig: this.parseToolbars(o, e, c, u, n), localeDefaults: a, availableRawLocales: s.map } }, e.prototype.processRawCalendarOptions = function (e, t) { var n = gn([cn, e, t]), o = n.locales, i = n.locale, a = this.organizeRawLocales(o), s = a.map, l = this.buildLocale(i || a.defaultCode, s).options, u = this.buildPluginHooks(e.plugins || [], xi), c = this.currentCalendarOptionsRefiners = r(r(r(r(r({}, un), dn), pn), u.listenerRefiners), u.optionRefiners), d = {}, p = gn([cn, l, e, t]), f = {}, h = this.currentCalendarOptionsInput, v = this.currentCalendarOptionsRefined, g = !1; for (var m in p) "plugins" !== m && (p[m] === h[m] || fn[m] && m in h && fn[m](h[m], p[m]) ? f[m] = v[m] : c[m] ? (f[m] = c[m](p[m]), g = !0) : d[m] = h[m]); return g && (this.currentCalendarOptionsInput = p, this.currentCalendarOptionsRefined = f), { rawOptions: this.currentCalendarOptionsInput, refinedOptions: this.currentCalendarOptionsRefined, pluginHooks: u, availableLocaleData: a, localeDefaults: l, extra: d } }, e.prototype._computeCurrentViewData = function (e, t, n, r) { var o = t.viewSpecs[e]; if (!o) throw new Error('viewType "' + e + "\" is not available. Please make sure you've loaded all neccessary plugins"); var i = this.processRawViewOptions(o, t.pluginHooks, t.localeDefaults, n, r), a = i.refinedOptions; return zi(i.extra), { viewSpec: o, options: a, dateProfileGenerator: this.buildDateProfileGenerator({ dateProfileGeneratorClass: o.optionDefaults.dateProfileGeneratorClass, duration: o.duration, durationUnit: o.durationUnit, usesMinMaxTime: o.optionDefaults.usesMinMaxTime, dateEnv: t.dateEnv, calendarApi: this.props.calendarApi, slotMinTime: a.slotMinTime, slotMaxTime: a.slotMaxTime, showNonCurrentDates: a.showNonCurrentDates, dayCount: a.dayCount, dateAlignment: a.dateAlignment, dateIncrement: a.dateIncrement, hiddenDays: a.hiddenDays, weekends: a.weekends, nowInput: a.now, validRangeInput: a.validRange, visibleRangeInput: a.visibleRange, monthMode: a.monthMode, fixedWeekCount: a.fixedWeekCount }), viewApi: this.buildViewApi(e, this.getCurrentData, t.dateEnv) } }, e.prototype.processRawViewOptions = function (e, t, n, o, i) { var a = gn([cn, e.optionDefaults, n, o, e.optionOverrides, i]), s = r(r(r(r(r(r({}, un), dn), pn), vn), t.listenerRefiners), t.optionRefiners), l = {}, u = this.currentViewOptionsInput, c = this.currentViewOptionsRefined, d = !1, p = {}; for (var f in a) a[f] === u[f] ? l[f] = c[f] : (a[f] === this.currentCalendarOptionsInput[f] ? f in this.currentCalendarOptionsRefined && (l[f] = this.currentCalendarOptionsRefined[f]) : s[f] ? l[f] = s[f](a[f]) : p[f] = a[f], d = !0); return d && (this.currentViewOptionsInput = a, this.currentViewOptionsRefined = l), { rawOptions: this.currentViewOptionsInput, refinedOptions: this.currentViewOptionsRefined, extra: p } }, e }(); function Hi(e, t, n, r, o, i, a, s) { var l = Br(t || a.defaultCode, a.map); return new Lr({ calendarSystem: "gregory", timeZone: e, namedTimeZoneImpl: i.namedTimeZonedImpl, locale: l, weekNumberCalculation: n, firstDay: r, weekText: o, cmdFormatter: i.cmdFormatter, defaultSeparator: s }) } function Oi(e, t) { return new (t.themeClasses[e.themeSystem] || Go)(e) } function Ai(e) { return new (e.dateProfileGeneratorClass || ai)(e) } function Li(e, t, n) { return new Cr(e, t, n) } function Ui(e) { return bt(e, (function (e) { return e.ui })) } function Wi(e, t, n) { var r = { "": t }; for (var o in e) { var i = e[o]; i.sourceId && n[i.sourceId] && (r[o] = n[i.sourceId]) } return r } function Vi(e) { var t = e.options; return { eventUiSingleBase: kn({ display: t.eventDisplay, editable: t.editable, startEditable: t.eventStartEditable, durationEditable: t.eventDurationEditable, constraint: t.eventConstraint, overlap: "boolean" == typeof t.eventOverlap ? t.eventOverlap : void 0, allow: t.eventAllow, backgroundColor: t.eventBackgroundColor, borderColor: t.eventBorderColor, textColor: t.eventTextColor, color: t.eventColor }, e), selectionConfig: kn({ constraint: t.selectConstraint, overlap: "boolean" == typeof t.selectOverlap ? t.selectOverlap : void 0, allow: t.selectAllow }, e) } } function Fi(e, t) { for (var n = 0, r = t.pluginHooks.isLoadingFuncs; n < r.length; n++) { if ((0, r[n])(e)) return !0 } return !1 } function Bi(e) { return Yr(e.options.businessHours, e) } function zi(e, t) { for (var n in e) console.warn("Unknown option '" + n + "'" + (t ? " for view '" + t + "'" : "")) } var ji = function (e) { function t(t) { var n = e.call(this, t) || this; return n.handleData = function (e) { n.dataManager ? n.setState(e) : n.state = e }, n.dataManager = new Ni({ optionOverrides: t.optionOverrides, calendarApi: t.calendarApi, onData: n.handleData }), n } return n(t, e), t.prototype.render = function () { return this.props.children(this.state) }, t.prototype.componentDidUpdate = function (e) { var t = this.props.optionOverrides; t !== e.optionOverrides && this.dataManager.resetOptions(t) }, t }(Ro); var Gi = function (e) { this.timeZoneName = e }, qi = function () { function e() { this.strictOrder = !1, this.allowReslicing = !1, this.maxCoord = -1, this.maxStackCnt = -1, this.levelCoords = [], this.entriesByLevel = [], this.stackCnts = {} } return e.prototype.addSegs = function (e) { for (var t = [], n = 0, r = e; n < r.length; n++) { var o = r[n]; this.insertEntry(o, t) } return t }, e.prototype.insertEntry = function (e, t) { var n = this.findInsertion(e); return this.isInsertionValid(n, e) ? (this.insertEntryAt(e, n), 1) : this.handleInvalidInsertion(n, e, t) }, e.prototype.isInsertionValid = function (e, t) { return (-1 === this.maxCoord || e.levelCoord + t.thickness <= this.maxCoord) && (-1 === this.maxStackCnt || e.stackCnt < this.maxStackCnt) }, e.prototype.handleInvalidInsertion = function (e, t, n) { return this.allowReslicing && e.touchingEntry ? this.splitEntry(t, e.touchingEntry, n) : (n.push(t), 0) }, e.prototype.splitEntry = function (e, t, n) { var r = 0, i = [], a = e.span, s = t.span; return a.start < s.start && (r += this.insertEntry({ index: e.index, thickness: e.thickness, span: { start: a.start, end: s.start } }, i)), a.end > s.end && (r += this.insertEntry({ index: e.index, thickness: e.thickness, span: { start: s.end, end: a.end } }, i)), r ? (n.push.apply(n, o([{ index: e.index, thickness: e.thickness, span: $i(s, a) }], i)), r) : (n.push(e), 0) }, e.prototype.insertEntryAt = function (e, t) { var n = this.entriesByLevel, r = this.levelCoords; -1 === t.lateral ? (Ji(r, t.level, t.levelCoord), Ji(n, t.level, [e])) : Ji(n[t.level], t.lateral, e), this.stackCnts[Zi(e)] = t.stackCnt }, e.prototype.findInsertion = function (e) { for (var t = this, n = t.levelCoords, r = t.entriesByLevel, o = t.strictOrder, i = t.stackCnts, a = n.length, s = 0, l = -1, u = -1, c = null, d = 0, p = 0; p < a; p += 1) { var f = n[p]; if (!o && f >= s + e.thickness) break; for (var h = r[p], v = void 0, g = Qi(h, e.span.start, Yi), m = g[0] + g[1]; (v = h[m]) && v.span.start < e.span.end;) { var y = f + v.thickness; y > s && (s = y, c = v, l = p, u = m), y === s && (d = Math.max(d, i[Zi(v)] + 1)), m += 1 } } var E = 0; if (c) for (E = l + 1; E < a && n[E] < s;)E += 1; var S = -1; return E < a && n[E] === s && (S = Qi(r[E], e.span.end, Yi)[0]), { touchingLevel: l, touchingLateral: u, touchingEntry: c, stackCnt: d, levelCoord: s, level: E, lateral: S } }, e.prototype.toRects = function () { for (var e = this.entriesByLevel, t = this.levelCoords, n = e.length, o = [], i = 0; i < n; i += 1)for (var a = e[i], s = t[i], l = 0, u = a; l < u.length; l++) { var c = u[l]; o.push(r(r({}, c), { levelCoord: s })) } return o }, e }(); function Yi(e) { return e.span.end } function Zi(e) { return e.index + ":" + e.span.start } function Xi(e) { for (var t = [], n = 0, r = e; n < r.length; n++) { for (var o = r[n], i = [], a = { span: o.span, entries: [o] }, s = 0, l = t; s < l.length; s++) { var u = l[s]; $i(u.span, a.span) ? a = { entries: u.entries.concat(a.entries), span: Ki(u.span, a.span) } : i.push(u) } i.push(a), t = i } return t } function Ki(e, t) { return { start: Math.min(e.start, t.start), end: Math.max(e.end, t.end) } } function $i(e, t) { var n = Math.max(e.start, t.start), r = Math.min(e.end, t.end); return n < r ? { start: n, end: r } : null } function Ji(e, t, n) { e.splice(t, 0, n) } function Qi(e, t, n) { var r = 0, o = e.length; if (!o || t < n(e[r])) return [0, 0]; if (t > n(e[o - 1])) return [o, 0]; for (; r < o;) { var i = Math.floor(r + (o - r) / 2), a = n(e[i]); if (t < a) o = i; else { if (!(t > a)) return [i, 1]; r = i + 1 } } return [r, 0] } var ea = function () { function e(e) { this.component = e.component, this.isHitComboAllowed = e.isHitComboAllowed || null } return e.prototype.destroy = function () { }, e }(); function ta(e, t) { return { component: e, el: t.el, useEventCenter: null == t.useEventCenter || t.useEventCenter, isHitComboAllowed: t.isHitComboAllowed || null } } function na(e) { var t; return (t = {})[e.component.uid] = e, t } var ra = {}, oa = function () { function e(e, t) { this.emitter = new Eo } return e.prototype.destroy = function () { }, e.prototype.setMirrorIsVisible = function (e) { }, e.prototype.setMirrorNeedsRevert = function (e) { }, e.prototype.setAutoScrollEnabled = function (e) { }, e }(), ia = {}, aa = { startTime: Nt, duration: Nt, create: Boolean, sourceId: String }; function sa(e) { var t = mn(e, aa), n = t.refined, r = t.extra; return { startTime: n.startTime || null, duration: n.duration || null, create: null == n.create || n.create, sourceId: n.sourceId, leftoverProps: r } } var la = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e = this, t = this.props.widgetGroups.map((function (t) { return e.renderWidgetGroup(t) })); return _o.apply(void 0, o(["div", { className: "fc-toolbar-chunk" }], t)) }, t.prototype.renderWidgetGroup = function (e) { for (var t = this.props, n = this.context.theme, r = [], i = !0, a = 0, s = e; a < s.length; a++) { var l = s[a], u = l.buttonName, c = l.buttonClick, d = l.buttonText, p = l.buttonIcon, f = l.buttonHint; if ("title" === u) i = !1, r.push(_o("h2", { className: "fc-toolbar-title", id: t.titleId }, t.title)); else { var h = u === t.activeButton, v = !t.isTodayEnabled && "today" === u || !t.isPrevEnabled && "prev" === u || !t.isNextEnabled && "next" === u, g = ["fc-" + u + "-button", n.getClass("button")]; h && g.push(n.getClass("buttonActive")), r.push(_o("button", { type: "button", title: "function" == typeof f ? f(t.navUnit) : f, disabled: v, "aria-pressed": h, className: g.join(" "), onClick: c }, d || (p ? _o("span", { className: p }) : ""))) } } if (r.length > 1) { var m = i && n.getClass("buttonGroup") || ""; return _o.apply(void 0, o(["div", { className: m }], r)) } return r[0] }, t }(Uo), ua = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e, t, n = this.props, r = n.model, o = n.extraClassName, i = !1, a = r.sectionWidgets, s = a.center; return a.left ? (i = !0, e = a.left) : e = a.start, a.right ? (i = !0, t = a.right) : t = a.end, _o("div", { className: [o || "", "fc-toolbar", i ? "fc-toolbar-ltr" : ""].join(" ") }, this.renderSection("start", e || []), this.renderSection("center", s || []), this.renderSection("end", t || [])) }, t.prototype.renderSection = function (e, t) { var n = this.props; return _o(la, { key: e, widgetGroups: t, title: n.title, navUnit: n.navUnit, activeButton: n.activeButton, isTodayEnabled: n.isTodayEnabled, isPrevEnabled: n.isPrevEnabled, isNextEnabled: n.isNextEnabled, titleId: n.titleId }) }, t }(Uo), ca = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.state = { availableWidth: null }, t.handleEl = function (e) { t.el = e, Fo(t.props.elRef, e), t.updateAvailableWidth() }, t.handleResize = function () { t.updateAvailableWidth() }, t } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.state, n = e.aspectRatio, r = ["fc-view-harness", n || e.liquid || e.height ? "fc-view-harness-active" : "fc-view-harness-passive"], o = "", i = ""; return n ? null !== t.availableWidth ? o = t.availableWidth / n : i = 1 / n * 100 + "%" : o = e.height || "", _o("div", { "aria-labelledby": e.labeledById, ref: this.handleEl, className: r.join(" "), style: { height: o, paddingBottom: i } }, e.children) }, t.prototype.componentDidMount = function () { this.context.addResizeHandler(this.handleResize) }, t.prototype.componentWillUnmount = function () { this.context.removeResizeHandler(this.handleResize) }, t.prototype.updateAvailableWidth = function () { this.el && this.props.aspectRatio && this.setState({ availableWidth: this.el.offsetWidth }) }, t }(Uo), da = function (e) { function t(t) { var n = e.call(this, t) || this; return n.handleSegClick = function (e, t) { var r = n.component, o = r.context, i = Jn(t); if (i && r.isValidSegDownEl(e.target)) { var a = Se(e.target, ".fc-event-forced-url"), s = a ? a.querySelector("a[href]").href : ""; o.emitter.trigger("eventClick", { el: t, event: new xr(r.context, i.eventRange.def, i.eventRange.instance), jsEvent: e, view: o.viewApi }), s && !e.defaultPrevented && (window.location.href = s) } }, n.destroy = Ie(t.el, "click", ".fc-event", n.handleSegClick), n } return n(t, e), t }(ea), pa = function (e) { function t(t) { var n, r, o, i, a, s = e.call(this, t) || this; return s.handleEventElRemove = function (e) { e === s.currentSegEl && s.handleSegLeave(null, s.currentSegEl) }, s.handleSegEnter = function (e, t) { Jn(t) && (s.currentSegEl = t, s.triggerEvent("eventMouseEnter", e, t)) }, s.handleSegLeave = function (e, t) { s.currentSegEl && (s.currentSegEl = null, s.triggerEvent("eventMouseLeave", e, t)) }, s.removeHoverListeners = (n = t.el, r = ".fc-event", o = s.handleSegEnter, i = s.handleSegLeave, Ie(n, "mouseover", r, (function (e, t) { if (t !== a) { a = t, o(e, t); var n = function (e) { a = null, i(e, t), t.removeEventListener("mouseleave", n) }; t.addEventListener("mouseleave", n) } }))), s } return n(t, e), t.prototype.destroy = function () { this.removeHoverListeners() }, t.prototype.triggerEvent = function (e, t, n) { var r = this.component, o = r.context, i = Jn(n); t && !r.isValidSegDownEl(t.target) || o.emitter.trigger(e, { el: n, event: new xr(o, i.eventRange.def, i.eventRange.instance), jsEvent: t, view: o.viewApi }) }, t }(ea), fa = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.buildViewContext = qt(Ao), t.buildViewPropTransformers = qt(va), t.buildToolbarProps = qt(ha), t.headerRef = ko(), t.footerRef = ko(), t.interactionsStore = {}, t.state = { viewLabelId: xe() }, t.registerInteractiveComponent = function (e, n) { var r = ta(e, n), o = [da, pa].concat(t.props.pluginHooks.componentInteractions).map((function (e) { return new e(r) })); t.interactionsStore[e.uid] = o, ra[e.uid] = r }, t.unregisterInteractiveComponent = function (e) { for (var n = 0, r = t.interactionsStore[e.uid]; n < r.length; n++) { r[n].destroy() } delete t.interactionsStore[e.uid], delete ra[e.uid] }, t.resizeRunner = new Mi((function () { t.props.emitter.trigger("_resize", !0), t.props.emitter.trigger("windowResize", { view: t.props.viewApi }) })), t.handleWindowResize = function (e) { var n = t.props.options; n.handleWindowResize && e.target === window && t.resizeRunner.request(n.windowResizeDelay) }, t } return n(t, e), t.prototype.render = function () { var e, t = this.props, n = t.toolbarConfig, o = t.options, i = this.buildToolbarProps(t.viewSpec, t.dateProfile, t.dateProfileGenerator, t.currentDate, Tr(t.options.now, t.dateEnv), t.viewTitle), a = !1, s = ""; t.isHeightAuto || t.forPrint ? s = "" : null != o.height ? a = !0 : null != o.contentHeight ? s = o.contentHeight : e = Math.max(o.aspectRatio, .5); var l = this.buildViewContext(t.viewSpec, t.viewApi, t.options, t.dateProfileGenerator, t.dateEnv, t.theme, t.pluginHooks, t.dispatch, t.getCurrentData, t.emitter, t.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent), u = n.header && n.header.hasTitle ? this.state.viewLabelId : ""; return _o(Oo.Provider, { value: l }, n.header && _o(ua, r({ ref: this.headerRef, extraClassName: "fc-header-toolbar", model: n.header, titleId: u }, i)), _o(ca, { liquid: a, height: s, aspectRatio: e, labeledById: u }, this.renderView(t), this.buildAppendContent()), n.footer && _o(ua, r({ ref: this.footerRef, extraClassName: "fc-footer-toolbar", model: n.footer, titleId: "" }, i))) }, t.prototype.componentDidMount = function () { var e = this.props; this.calendarInteractions = e.pluginHooks.calendarInteractions.map((function (t) { return new t(e) })), window.addEventListener("resize", this.handleWindowResize); var t = e.pluginHooks.propSetHandlers; for (var n in t) t[n](e[n], e) }, t.prototype.componentDidUpdate = function (e) { var t = this.props, n = t.pluginHooks.propSetHandlers; for (var r in n) t[r] !== e[r] && n[r](t[r], t) }, t.prototype.componentWillUnmount = function () { window.removeEventListener("resize", this.handleWindowResize), this.resizeRunner.clear(); for (var e = 0, t = this.calendarInteractions; e < t.length; e++) { t[e].destroy() } this.props.emitter.trigger("_unmount") }, t.prototype.buildAppendContent = function () { var e = this.props, t = e.pluginHooks.viewContainerAppends.map((function (t) { return t(e) })); return _o.apply(void 0, o([xo, {}], t)) }, t.prototype.renderView = function (e) { for (var t = e.pluginHooks, n = e.viewSpec, o = { dateProfile: e.dateProfile, businessHours: e.businessHours, eventStore: e.renderableEventStore, eventUiBases: e.eventUiBases, dateSelection: e.dateSelection, eventSelection: e.eventSelection, eventDrag: e.eventDrag, eventResize: e.eventResize, isHeightAuto: e.isHeightAuto, forPrint: e.forPrint }, i = 0, a = this.buildViewPropTransformers(t.viewPropsTransformers); i < a.length; i++) { var s = a[i]; r(o, s.transform(o, e)) } var l = n.component; return _o(l, r({}, o)) }, t }(Lo); function ha(e, t, n, r, o, i) { var a = n.build(o, void 0, !1), s = n.buildPrev(t, r, !1), l = n.buildNext(t, r, !1); return { title: i, activeButton: e.type, navUnit: e.singleUnit, isTodayEnabled: a.isValid && !Zn(t.currentRange, o), isPrevEnabled: s.isValid, isNextEnabled: l.isValid } } function va(e) { return e.map((function (e) { return new e })) } var ga = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.state = { forPrint: !1 }, t.handleBeforePrint = function () { t.setState({ forPrint: !0 }) }, t.handleAfterPrint = function () { t.setState({ forPrint: !1 }) }, t } return n(t, e), t.prototype.render = function () { var e = this.props, t = e.options, n = this.state.forPrint, r = n || "auto" === t.height || "auto" === t.contentHeight, o = r || null == t.height ? "" : t.height, i = ["fc", n ? "fc-media-print" : "fc-media-screen", "fc-direction-" + t.direction, e.theme.getClass("root")]; return Qr() || i.push("fc-liquid-hack"), e.children(i, o, r, n) }, t.prototype.componentDidMount = function () { var e = this.props.emitter; e.on("_beforeprint", this.handleBeforePrint), e.on("_afterprint", this.handleAfterPrint) }, t.prototype.componentWillUnmount = function () { var e = this.props.emitter; e.off("_beforeprint", this.handleBeforePrint), e.off("_afterprint", this.handleAfterPrint) }, t }(Uo); function ma(e, t) { return ln(!e || t > 10 ? { weekday: "short" } : t > 1 ? { weekday: "short", month: "numeric", day: "numeric", omitCommas: !0 } : { weekday: "long" }) } var ya = "fc-col-header-cell"; function Ea(e) { return e.text } var Sa = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e = this.context, t = e.dateEnv, n = e.options, o = e.theme, i = e.viewApi, a = this.props, s = a.date, l = a.dateProfile, u = ro(s, a.todayRange, null, l), c = [ya].concat(oo(u, o)), d = t.format(s, a.dayHeaderFormat), p = !u.isDisabled && a.colCnt > 1 ? so(this.context, s) : {}, f = r(r(r({ date: t.toDate(s), view: i }, a.extraHookProps), { text: d }), u); return _o(Yo, { hookProps: f, classNames: n.dayHeaderClassNames, content: n.dayHeaderContent, defaultContent: Ea, didMount: n.dayHeaderDidMount, willUnmount: n.dayHeaderWillUnmount }, (function (e, t, n, o) { return _o("th", r({ ref: e, role: "columnheader", className: c.concat(t).join(" "), "data-date": u.isDisabled ? void 0 : Bt(s), colSpan: a.colSpan }, a.extraDataAttrs), _o("div", { className: "fc-scrollgrid-sync-inner" }, !u.isDisabled && _o("a", r({ ref: n, className: ["fc-col-header-cell-cushion", a.isSticky ? "fc-sticky" : ""].join(" ") }, p), o))) })) }, t }(Uo), ba = ln({ weekday: "long" }), Da = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.context, n = t.dateEnv, o = t.theme, i = t.viewApi, a = t.options, s = tt(new Date(2592e5), e.dow), l = { dow: e.dow, isDisabled: !1, isFuture: !1, isPast: !1, isToday: !1, isOther: !1 }, u = [ya].concat(oo(l, o), e.extraClassNames || []), c = n.format(s, e.dayHeaderFormat), d = r(r(r(r({ date: s }, l), { view: i }), e.extraHookProps), { text: c }); return _o(Yo, { hookProps: d, classNames: a.dayHeaderClassNames, content: a.dayHeaderContent, defaultContent: Ea, didMount: a.dayHeaderDidMount, willUnmount: a.dayHeaderWillUnmount }, (function (t, o, i, a) { return _o("th", r({ ref: t, role: "columnheader", className: u.concat(o).join(" "), colSpan: e.colSpan }, e.extraDataAttrs), _o("div", { className: "fc-scrollgrid-sync-inner" }, _o("a", { "aria-label": n.format(s, ba), className: ["fc-col-header-cell-cushion", e.isSticky ? "fc-sticky" : ""].join(" "), ref: i }, a))) })) }, t }(Uo), Ca = function (e) { function t(t, n) { var r = e.call(this, t, n) || this; return r.initialNowDate = Tr(n.options.now, n.dateEnv), r.initialNowQueriedMs = (new Date).valueOf(), r.state = r.computeTiming().currentState, r } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.state; return e.children(t.nowDate, t.todayRange) }, t.prototype.componentDidMount = function () { this.setTimeout() }, t.prototype.componentDidUpdate = function (e) { e.unit !== this.props.unit && (this.clearTimeout(), this.setTimeout()) }, t.prototype.componentWillUnmount = function () { this.clearTimeout() }, t.prototype.computeTiming = function () { var e = this.props, t = this.context, n = nt(this.initialNowDate, (new Date).valueOf() - this.initialNowQueriedMs), r = t.dateEnv.startOf(n, e.unit), o = t.dateEnv.add(r, Nt(1, e.unit)), i = o.valueOf() - n.valueOf(); return i = Math.min(864e5, i), { currentState: { nowDate: r, todayRange: wa(r) }, nextState: { nowDate: o, todayRange: wa(o) }, waitMs: i } }, t.prototype.setTimeout = function () { var e = this, t = this.computeTiming(), n = t.nextState, r = t.waitMs; this.timeoutId = setTimeout((function () { e.setState(n, (function () { e.setTimeout() })) }), r) }, t.prototype.clearTimeout = function () { this.timeoutId && clearTimeout(this.timeoutId) }, t.contextType = Oo, t }(Ro); function wa(e) { var t = lt(e); return { start: t, end: tt(t, 1) } } var Ra = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.createDayHeaderFormatter = qt(_a), t } return n(t, e), t.prototype.render = function () { var e = this.context, t = this.props, n = t.dates, r = t.dateProfile, o = t.datesRepDistinctDays, i = t.renderIntro, a = this.createDayHeaderFormatter(e.options.dayHeaderFormat, o, n.length); return _o(Ca, { unit: "day" }, (function (e, t) { return _o("tr", { role: "row" }, i && i("day"), n.map((function (e) { return o ? _o(Sa, { key: e.toISOString(), date: e, dateProfile: r, todayRange: t, colCnt: n.length, dayHeaderFormat: a }) : _o(Da, { key: e.getUTCDay(), dow: e.getUTCDay(), dayHeaderFormat: a }) }))) })) }, t }(Uo); function _a(e, t, n) { return e || ma(t, n) } var Ta = function () { function e(e, t) { for (var n = e.start, r = e.end, o = [], i = [], a = -1; n < r;)t.isHiddenDay(n) ? o.push(a + .5) : (a += 1, o.push(a), i.push(n)), n = tt(n, 1); this.dates = i, this.indices = o, this.cnt = i.length } return e.prototype.sliceRange = function (e) { var t = this.getDateDayIndex(e.start), n = this.getDateDayIndex(tt(e.end, -1)), r = Math.max(0, t), o = Math.min(this.cnt - 1, n); return (r = Math.ceil(r)) <= (o = Math.floor(o)) ? { firstIndex: r, lastIndex: o, isStart: t === r, isEnd: n === o } : null }, e.prototype.getDateDayIndex = function (e) { var t = this.indices, n = Math.floor(ot(this.dates[0], e)); return n < 0 ? t[0] - 1 : n >= t.length ? t[t.length - 1] + 1 : t[n] }, e }(), ka = function () { function e(e, t) { var n, r, o, i = e.dates; if (t) { for (r = i[0].getUTCDay(), n = 1; n < i.length && i[n].getUTCDay() !== r; n += 1); o = Math.ceil(i.length / n) } else o = 1, n = i.length; this.rowCnt = o, this.colCnt = n, this.daySeries = e, this.cells = this.buildCells(), this.headerDates = this.buildHeaderDates() } return e.prototype.buildCells = function () { for (var e = [], t = 0; t < this.rowCnt; t += 1) { for (var n = [], r = 0; r < this.colCnt; r += 1)n.push(this.buildCell(t, r)); e.push(n) } return e }, e.prototype.buildCell = function (e, t) { var n = this.daySeries.dates[e * this.colCnt + t]; return { key: n.toISOString(), date: n } }, e.prototype.buildHeaderDates = function () { for (var e = [], t = 0; t < this.colCnt; t += 1)e.push(this.cells[0][t].date); return e }, e.prototype.sliceRange = function (e) { var t = this.colCnt, n = this.daySeries.sliceRange(e), r = []; if (n) for (var o = n.firstIndex, i = n.lastIndex, a = o; a <= i;) { var s = Math.floor(a / t), l = Math.min((s + 1) * t, i + 1); r.push({ row: s, firstCol: a % t, lastCol: (l - 1) % t, isStart: n.isStart && a === o, isEnd: n.isEnd && l - 1 === i }), a = l } return r }, e }(), xa = function () { function e() { this.sliceBusinessHours = qt(this._sliceBusinessHours), this.sliceDateSelection = qt(this._sliceDateSpan), this.sliceEventStore = qt(this._sliceEventStore), this.sliceEventDrag = qt(this._sliceInteraction), this.sliceEventResize = qt(this._sliceInteraction), this.forceDayIfListItem = !1 } return e.prototype.sliceProps = function (e, t, n, r) { for (var i = [], a = 4; a < arguments.length; a++)i[a - 4] = arguments[a]; var s = e.eventUiBases, l = this.sliceEventStore.apply(this, o([e.eventStore, s, t, n], i)); return { dateSelectionSegs: this.sliceDateSelection.apply(this, o([e.dateSelection, s, r], i)), businessHourSegs: this.sliceBusinessHours.apply(this, o([e.businessHours, t, n, r], i)), fgEventSegs: l.fg, bgEventSegs: l.bg, eventDrag: this.sliceEventDrag.apply(this, o([e.eventDrag, s, t, n], i)), eventResize: this.sliceEventResize.apply(this, o([e.eventResize, s, t, n], i)), eventSelection: e.eventSelection } }, e.prototype.sliceNowDate = function (e, t) { for (var n = [], r = 2; r < arguments.length; r++)n[r - 2] = arguments[r]; return this._sliceDateSpan.apply(this, o([{ range: { start: e, end: nt(e, 1) }, allDay: !1 }, {}, t], n)) }, e.prototype._sliceBusinessHours = function (e, t, n, r) { for (var i = [], a = 4; a < arguments.length; a++)i[a - 4] = arguments[a]; return e ? this._sliceEventStore.apply(this, o([xt(e, Ma(t, Boolean(n)), r), {}, t, n], i)).bg : [] }, e.prototype._sliceEventStore = function (e, t, n, r) { for (var o = [], i = 4; i < arguments.length; i++)o[i - 4] = arguments[i]; if (e) { var a = Xn(e, t, Ma(n, Boolean(r)), r); return { bg: this.sliceEventRanges(a.bg, o), fg: this.sliceEventRanges(a.fg, o) } } return { bg: [], fg: [] } }, e.prototype._sliceInteraction = function (e, t, n, r) { for (var o = [], i = 4; i < arguments.length; i++)o[i - 4] = arguments[i]; if (!e) return null; var a = Xn(e.mutatedEvents, t, Ma(n, Boolean(r)), r); return { segs: this.sliceEventRanges(a.fg, o), affectedInstances: e.affectedEvents.instances, isEvent: e.isEvent } }, e.prototype._sliceDateSpan = function (e, t, n) { for (var r = [], i = 3; i < arguments.length; i++)r[i - 3] = arguments[i]; if (!e) return []; for (var a = gr(e, t, n), s = this.sliceRange.apply(this, o([e.range], r)), l = 0, u = s; l < u.length; l++) { var c = u[l]; c.eventRange = a } return s }, e.prototype.sliceEventRanges = function (e, t) { for (var n = [], r = 0, o = e; r < o.length; r++) { var i = o[r]; n.push.apply(n, this.sliceEventRange(i, t)) } return n }, e.prototype.sliceEventRange = function (e, t) { var n = e.range; this.forceDayIfListItem && "list-item" === e.ui.display && (n = { start: n.start, end: tt(n.start, 1) }); for (var r = this.sliceRange.apply(this, o([n], t)), i = 0, a = r; i < a.length; i++) { var s = a[i]; s.eventRange = e, s.isStart = e.isStart && s.isStart, s.isEnd = e.isEnd && s.isEnd } return r }, e }(); function Ma(e, t) { var n = e.activeRange; return t ? n : { start: nt(n.start, e.slotMinTime.milliseconds), end: nt(n.end, e.slotMaxTime.milliseconds - 864e5) } } function Ia(e, t, n) { var r = e.mutatedEvents.instances; for (var o in r) if (!Yn(t.validRange, r[o].range)) return !1; return Na({ eventDrag: e }, n) } function Pa(e, t, n) { return !!Yn(t.validRange, e.range) && Na({ dateSelection: e }, n) } function Na(e, t) { var n = t.getCurrentData(), o = r({ businessHours: n.businessHours, dateSelection: "", eventStore: n.eventStore, eventUiBases: n.eventUiBases, eventSelection: "", eventDrag: null, eventResize: null }, e); return (t.pluginHooks.isPropsValid || Ha)(o, t) } function Ha(e, t, n, o) { return void 0 === n && (n = {}), !(e.eventDrag && !function (e, t, n, o) { var i = t.getCurrentData(), a = e.eventDrag, s = a.mutatedEvents, l = s.defs, u = s.instances, c = Qn(l, a.isEvent ? e.eventUiBases : { "": i.selectionConfig }); o && (c = bt(c, o)); var d = (v = e.eventStore, g = a.affectedEvents.instances, { defs: v.defs, instances: St(v.instances, (function (e) { return !g[e.instanceId] })) }), p = d.defs, f = d.instances, h = Qn(p, e.eventUiBases); var v, g; for (var m in u) { var y = u[m], E = y.range, S = c[y.defId], b = l[y.defId]; if (!Oa(S.constraints, E, d, e.businessHours, t)) return !1; var D = t.options.eventOverlap, C = "function" == typeof D ? D : null; for (var w in f) { var R = f[w]; if (qn(E, R.range)) { if (!1 === h[R.defId].overlap && a.isEvent) return !1; if (!1 === S.overlap) return !1; if (C && !C(new xr(t, p[R.defId], R), new xr(t, b, y))) return !1 } } for (var _ = i.eventStore, T = 0, k = S.allows; T < k.length; T++) { var x = k[T], M = r(r({}, n), { range: y.range, allDay: b.allDay }), I = _.defs[b.defId], P = _.instances[m], N = void 0; if (N = I ? new xr(t, I, P) : new xr(t, b), !x(yr(M, t), N)) return !1 } } return !0 }(e, t, n, o)) && !(e.dateSelection && !function (e, t, n, o) { var i = e.eventStore, a = i.defs, s = i.instances, l = e.dateSelection, u = l.range, c = t.getCurrentData().selectionConfig; o && (c = o(c)); if (!Oa(c.constraints, u, i, e.businessHours, t)) return !1; var d = t.options.selectOverlap, p = "function" == typeof d ? d : null; for (var f in s) { var h = s[f]; if (qn(u, h.range)) { if (!1 === c.overlap) return !1; if (p && !p(new xr(t, a[h.defId], h), null)) return !1 } } for (var v = 0, g = c.allows; v < g.length; v++) { if (!(0, g[v])(yr(r(r({}, n), l), t), null)) return !1 } return !0 }(e, t, n, o)) } function Oa(e, t, n, r, o) { for (var i = 0, a = e; i < a.length; i++) { if (!Ua(Aa(a[i], t, n, r, o), t)) return !1 } return !0 } function Aa(e, t, n, r, o) { return "businessHours" === e ? La(xt(r, t, o)) : "string" == typeof e ? La(wn(n, (function (t) { return t.groupId === e }))) : "object" == typeof e && e ? La(xt(e, t, o)) : [] } function La(e) { var t = e.instances, n = []; for (var r in t) n.push(t[r].range); return n } function Ua(e, t) { for (var n = 0, r = e; n < r.length; n++) { if (Yn(r[n], t)) return !0 } return !1 } var Wa = /^(visible|hidden)$/, Va = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.handleEl = function (e) { t.el = e, Fo(t.props.elRef, e) }, t } return n(t, e), t.prototype.render = function () { var e = this.props, t = e.liquid, n = e.liquidIsAbsolute, r = t && n, o = ["fc-scroller"]; return t && (n ? o.push("fc-scroller-liquid-absolute") : o.push("fc-scroller-liquid")), _o("div", { ref: this.handleEl, className: o.join(" "), style: { overflowX: e.overflowX, overflowY: e.overflowY, left: r && -(e.overcomeLeft || 0) || "", right: r && -(e.overcomeRight || 0) || "", bottom: r && -(e.overcomeBottom || 0) || "", marginLeft: !r && -(e.overcomeLeft || 0) || "", marginRight: !r && -(e.overcomeRight || 0) || "", marginBottom: !r && -(e.overcomeBottom || 0) || "", maxHeight: e.maxHeight || "" } }, e.children) }, t.prototype.needsXScrolling = function () { if (Wa.test(this.props.overflowX)) return !1; for (var e = this.el, t = this.el.getBoundingClientRect().width - this.getYScrollbarWidth(), n = e.children, r = 0; r < n.length; r += 1) { if (n[r].getBoundingClientRect().width > t) return !0 } return !1 }, t.prototype.needsYScrolling = function () { if (Wa.test(this.props.overflowY)) return !1; for (var e = this.el, t = this.el.getBoundingClientRect().height - this.getXScrollbarWidth(), n = e.children, r = 0; r < n.length; r += 1) { if (n[r].getBoundingClientRect().height > t) return !0 } return !1 }, t.prototype.getXScrollbarWidth = function () { return Wa.test(this.props.overflowX) ? 0 : this.el.offsetHeight - this.el.clientHeight }, t.prototype.getYScrollbarWidth = function () { return Wa.test(this.props.overflowY) ? 0 : this.el.offsetWidth - this.el.clientWidth }, t }(Uo), Fa = function () { function e(e) { var t = this; this.masterCallback = e, this.currentMap = {}, this.depths = {}, this.callbackMap = {}, this.handleValue = function (e, n) { var r = t, o = r.depths, i = r.currentMap, a = !1, s = !1; null !== e ? (a = n in i, i[n] = e, o[n] = (o[n] || 0) + 1, s = !0) : (o[n] -= 1, o[n] || (delete i[n], delete t.callbackMap[n], a = !0)), t.masterCallback && (a && t.masterCallback(null, String(n)), s && t.masterCallback(e, String(n))) } } return e.prototype.createRef = function (e) { var t = this, n = this.callbackMap[e]; return n || (n = this.callbackMap[e] = function (n) { t.handleValue(n, String(e)) }), n }, e.prototype.collect = function (e, t, n) { return kt(this.currentMap, e, t, n) }, e.prototype.getAll = function () { return Ct(this.currentMap) }, e }(); function Ba(e) { for (var t = 0, n = 0, r = De(e, ".fc-scrollgrid-shrink"); n < r.length; n++) { var o = r[n]; t = Math.max(t, Je(o)) } return Math.ceil(t) } function za(e, t) { return e.liquid && t.liquid } function ja(e, t) { return null != t.maxHeight || za(e, t) } function Ga(e, t, n, r) { var o = n.expandRows; return "function" == typeof t.content ? t.content(n) : _o("table", { role: "presentation", className: [t.tableClassName, e.syncRowHeights ? "fc-scrollgrid-sync-table" : ""].join(" "), style: { minWidth: n.tableMinWidth, width: n.clientWidth, height: o ? n.clientHeight : "" } }, n.tableColGroupNode, _o(r ? "thead" : "tbody", { role: "presentation" }, "function" == typeof t.rowContent ? t.rowContent(n) : t.rowContent)) } function qa(e, t) { return Gt(e, t, wt) } function Ya(e, t) { for (var n = [], r = 0, i = e; r < i.length; r++)for (var a = i[r], s = a.span || 1, l = 0; l < s; l += 1)n.push(_o("col", { style: { width: "shrink" === a.width ? Za(t) : a.width || "", minWidth: a.minWidth || "" } })); return _o.apply(void 0, o(["colgroup", {}], n)) } function Za(e) { return null == e ? 4 : e } function Xa(e) { for (var t = 0, n = e; t < n.length; t++) { if ("shrink" === n[t].width) return !0 } return !1 } function Ka(e, t) { var n = ["fc-scrollgrid", t.theme.getClass("table")]; return e && n.push("fc-scrollgrid-liquid"), n } function $a(e, t) { var n = ["fc-scrollgrid-section", "fc-scrollgrid-section-" + e.type, e.className]; return t && e.liquid && null == e.maxHeight && n.push("fc-scrollgrid-section-liquid"), e.isSticky && n.push("fc-scrollgrid-section-sticky"), n } function Ja(e) { return _o("div", { className: "fc-scrollgrid-sticky-shim", style: { width: e.clientWidth, minWidth: e.tableMinWidth } }) } function Qa(e) { var t = e.stickyHeaderDates; return null != t && "auto" !== t || (t = "auto" === e.height || "auto" === e.viewHeight), t } function es(e) { var t = e.stickyFooterScrollbar; return null != t && "auto" !== t || (t = "auto" === e.height || "auto" === e.viewHeight), t } var ts = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.processCols = qt((function (e) { return e }), qa), t.renderMicroColGroup = qt(Ya), t.scrollerRefs = new Fa, t.scrollerElRefs = new Fa(t._handleScrollerEl.bind(t)), t.state = { shrinkWidth: null, forceYScrollbars: !1, scrollerClientWidths: {}, scrollerClientHeights: {} }, t.handleSizing = function () { t.setState(r({ shrinkWidth: t.computeShrinkWidth() }, t.computeScrollerDims())) }, t } return n(t, e), t.prototype.render = function () { var e = this, t = e.props, n = e.state, r = e.context, i = t.sections || [], a = this.processCols(t.cols), s = this.renderMicroColGroup(a, n.shrinkWidth), l = Ka(t.liquid, r); t.collapsibleWidth && l.push("fc-scrollgrid-collapsible"); for (var u, c = i.length, d = 0, p = [], f = [], h = []; d < c && "header" === (u = i[d]).type;)p.push(this.renderSection(u, s, !0)), d += 1; for (; d < c && "body" === (u = i[d]).type;)f.push(this.renderSection(u, s, !1)), d += 1; for (; d < c && "footer" === (u = i[d]).type;)h.push(this.renderSection(u, s, !0)), d += 1; var v = !Qr(), g = { role: "rowgroup" }; return _o("table", { role: "grid", className: l.join(" "), style: { height: t.height } }, Boolean(!v && p.length) && _o.apply(void 0, o(["thead", g], p)), Boolean(!v && f.length) && _o.apply(void 0, o(["tbody", g], f)), Boolean(!v && h.length) && _o.apply(void 0, o(["tfoot", g], h)), v && _o.apply(void 0, o(o(o(["tbody", g], p), f), h))) }, t.prototype.renderSection = function (e, t, n) { return "outerContent" in e ? _o(xo, { key: e.key }, e.outerContent) : _o("tr", { key: e.key, role: "presentation", className: $a(e, this.props.liquid).join(" ") }, this.renderChunkTd(e, t, e.chunk, n)) }, t.prototype.renderChunkTd = function (e, t, n, r) { if ("outerContent" in n) return n.outerContent; var o = this.props, i = this.state, a = i.forceYScrollbars, s = i.scrollerClientWidths, l = i.scrollerClientHeights, u = ja(o, e), c = za(o, e), d = o.liquid ? a ? "scroll" : u ? "auto" : "hidden" : "visible", p = e.key, f = Ga(e, n, { tableColGroupNode: t, tableMinWidth: "", clientWidth: o.collapsibleWidth || void 0 === s[p] ? null : s[p], clientHeight: void 0 !== l[p] ? l[p] : null, expandRows: e.expandRows, syncRowHeights: !1, rowSyncHeights: [], reportRowHeightChange: function () { } }, r); return _o(r ? "th" : "td", { ref: n.elRef, role: "presentation" }, _o("div", { className: "fc-scroller-harness" + (c ? " fc-scroller-harness-liquid" : "") }, _o(Va, { ref: this.scrollerRefs.createRef(p), elRef: this.scrollerElRefs.createRef(p), overflowY: d, overflowX: o.liquid ? "hidden" : "visible", maxHeight: e.maxHeight, liquid: c, liquidIsAbsolute: !0 }, f))) }, t.prototype._handleScrollerEl = function (e, t) { var n = function (e, t) { for (var n = 0, r = e; n < r.length; n++) { var o = r[n]; if (o.key === t) return o } return null }(this.props.sections, t); n && Fo(n.chunk.scrollerElRef, e) }, t.prototype.componentDidMount = function () { this.handleSizing(), this.context.addResizeHandler(this.handleSizing) }, t.prototype.componentDidUpdate = function () { this.handleSizing() }, t.prototype.componentWillUnmount = function () { this.context.removeResizeHandler(this.handleSizing) }, t.prototype.computeShrinkWidth = function () { return Xa(this.props.cols) ? Ba(this.scrollerElRefs.getAll()) : 0 }, t.prototype.computeScrollerDims = function () { var e = po(), t = this.scrollerRefs, n = this.scrollerElRefs, r = !1, o = {}, i = {}; for (var a in t.currentMap) { var s = t.currentMap[a]; if (s && s.needsYScrolling()) { r = !0; break } } for (var l = 0, u = this.props.sections; l < u.length; l++) { a = u[l].key; var c = n.currentMap[a]; if (c) { var d = c.parentNode; o[a] = Math.floor(d.getBoundingClientRect().width - (r ? e.y : 0)), i[a] = Math.floor(d.getBoundingClientRect().height) } } return { forceYScrollbars: r, scrollerClientWidths: o, scrollerClientHeights: i } }, t }(Uo); ts.addStateEquality({ scrollerClientWidths: wt, scrollerClientHeights: wt }); var ns = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.elRef = ko(), t } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.context, n = t.options, r = e.seg, o = r.eventRange, i = o.ui, a = { event: new xr(t, o.def, o.instance), view: t.viewApi, timeText: e.timeText, textColor: i.textColor, backgroundColor: i.backgroundColor, borderColor: i.borderColor, isDraggable: !e.disableDragging && rr(r, t), isStartResizable: !e.disableResizing && or(r, t), isEndResizable: !e.disableResizing && ir(r), isMirror: Boolean(e.isDragging || e.isResizing || e.isDateSelecting), isStart: Boolean(r.isStart), isEnd: Boolean(r.isEnd), isPast: Boolean(e.isPast), isFuture: Boolean(e.isFuture), isToday: Boolean(e.isToday), isSelected: Boolean(e.isSelected), isDragging: Boolean(e.isDragging), isResizing: Boolean(e.isResizing) }, s = lr(a).concat(i.classNames); return _o(Yo, { hookProps: a, classNames: n.eventClassNames, content: n.eventContent, defaultContent: e.defaultContent, didMount: n.eventDidMount, willUnmount: n.eventWillUnmount, elRef: this.elRef }, (function (t, n, r, o) { return e.children(t, s.concat(n), r, o, a) })) }, t.prototype.componentDidMount = function () { $n(this.elRef.current, this.props.seg) }, t.prototype.componentDidUpdate = function (e) { var t = this.props.seg; t !== e.seg && $n(this.elRef.current, t) }, t }(Uo), rs = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.context, n = e.seg, o = t.options.eventTimeFormat || e.defaultTimeFormat, i = ar(n, o, t, e.defaultDisplayEventTime, e.defaultDisplayEventEnd); return _o(ns, { seg: n, timeText: i, disableDragging: e.disableDragging, disableResizing: e.disableResizing, defaultContent: e.defaultContent || os, isDragging: e.isDragging, isResizing: e.isResizing, isDateSelecting: e.isDateSelecting, isSelected: e.isSelected, isPast: e.isPast, isFuture: e.isFuture, isToday: e.isToday }, (function (o, i, a, s, l) { return _o("a", r({ className: e.extraClassNames.concat(i).join(" "), style: { borderColor: l.borderColor, backgroundColor: l.backgroundColor }, ref: o }, cr(n, t)), _o("div", { className: "fc-event-main", ref: a, style: { color: l.textColor } }, s), l.isStartResizable && _o("div", { className: "fc-event-resizer fc-event-resizer-start" }), l.isEndResizable && _o("div", { className: "fc-event-resizer fc-event-resizer-end" })) })) }, t }(Uo); function os(e) { return _o("div", { className: "fc-event-main-frame" }, e.timeText && _o("div", { className: "fc-event-time" }, e.timeText), _o("div", { className: "fc-event-title-container" }, _o("div", { className: "fc-event-title fc-sticky" }, e.event.title || _o(xo, null, " ")))) } var is = function (e) { return _o(Oo.Consumer, null, (function (t) { var n = t.options, r = { isAxis: e.isAxis, date: t.dateEnv.toDate(e.date), view: t.viewApi }; return _o(Yo, { hookProps: r, classNames: n.nowIndicatorClassNames, content: n.nowIndicatorContent, didMount: n.nowIndicatorDidMount, willUnmount: n.nowIndicatorWillUnmount }, e.children) })) }, as = ln({ day: "numeric" }), ss = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.context, n = t.options, r = ls({ date: e.date, dateProfile: e.dateProfile, todayRange: e.todayRange, showDayNumber: e.showDayNumber, extraProps: e.extraHookProps, viewApi: t.viewApi, dateEnv: t.dateEnv }); return _o(Xo, { hookProps: r, content: n.dayCellContent, defaultContent: e.defaultContent }, e.children) }, t }(Uo); function ls(e) { var t = e.date, n = e.dateEnv, o = ro(t, e.todayRange, null, e.dateProfile); return r(r(r({ date: n.toDate(t), view: e.viewApi }, o), { dayNumberText: e.showDayNumber ? n.format(t, as) : "" }), e.extraProps) } var us = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.refineHookProps = Yt(ls), t.normalizeClassNames = Jo(), t } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.context, n = t.options, r = this.refineHookProps({ date: e.date, dateProfile: e.dateProfile, todayRange: e.todayRange, showDayNumber: e.showDayNumber, extraProps: e.extraHookProps, viewApi: t.viewApi, dateEnv: t.dateEnv }), o = oo(r, t.theme).concat(r.isDisabled ? [] : this.normalizeClassNames(n.dayCellClassNames, r)), i = r.isDisabled ? {} : { "data-date": Bt(e.date) }; return _o($o, { hookProps: r, didMount: n.dayCellDidMount, willUnmount: n.dayCellWillUnmount, elRef: e.elRef }, (function (t) { return e.children(t, o, i, r.isDisabled) })) }, t }(Uo); function cs(e) { return _o("div", { className: "fc-" + e }) } var ds = function (e) { return _o(ns, { defaultContent: ps, seg: e.seg, timeText: "", disableDragging: !0, disableResizing: !0, isDragging: !1, isResizing: !1, isDateSelecting: !1, isSelected: !1, isPast: e.isPast, isFuture: e.isFuture, isToday: e.isToday }, (function (e, t, n, r, o) { return _o("div", { ref: e, className: ["fc-bg-event"].concat(t).join(" "), style: { backgroundColor: o.backgroundColor } }, r) })) }; function ps(e) { return e.event.title && _o("div", { className: "fc-event-title" }, e.event.title) } var fs = function (e) { return _o(Oo.Consumer, null, (function (t) { var n = t.dateEnv, r = t.options, o = e.date, i = r.weekNumberFormat || e.defaultFormat, a = n.computeWeekNumber(o), s = n.format(o, i); return _o(Yo, { hookProps: { num: a, text: s, date: o }, classNames: r.weekNumberClassNames, content: r.weekNumberContent, defaultContent: hs, didMount: r.weekNumberDidMount, willUnmount: r.weekNumberWillUnmount }, e.children) })) }; function hs(e) { return e.text } var vs = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.state = { titleId: xe() }, t.handleRootEl = function (e) { t.rootEl = e, t.props.elRef && Fo(t.props.elRef, e) }, t.handleDocumentMouseDown = function (e) { var n = _e(e); t.rootEl.contains(n) || t.handleCloseClick() }, t.handleDocumentKeyDown = function (e) { "Escape" === e.key && t.handleCloseClick() }, t.handleCloseClick = function () { var e = t.props.onClose; e && e() }, t } return n(t, e), t.prototype.render = function () { var e = this.context, t = e.theme, n = e.options, o = this.props, i = this.state, a = ["fc-popover", t.getClass("popover")].concat(o.extraClassNames || []); return Io(_o("div", r({ id: o.id, className: a.join(" "), "aria-labelledby": i.titleId }, o.extraAttrs, { ref: this.handleRootEl }), _o("div", { className: "fc-popover-header " + t.getClass("popoverHeader") }, _o("span", { className: "fc-popover-title", id: i.titleId }, o.title), _o("span", { className: "fc-popover-close " + t.getIconClass("close"), title: n.closeHint, onClick: this.handleCloseClick })), _o("div", { className: "fc-popover-body " + t.getClass("popoverContent") }, o.children)), o.parentEl) }, t.prototype.componentDidMount = function () { document.addEventListener("mousedown", this.handleDocumentMouseDown), document.addEventListener("keydown", this.handleDocumentKeyDown), this.updateSize() }, t.prototype.componentWillUnmount = function () { document.removeEventListener("mousedown", this.handleDocumentMouseDown), document.removeEventListener("keydown", this.handleDocumentKeyDown) }, t.prototype.updateSize = function () { var e = this.context.isRtl, t = this.props, n = t.alignmentEl, r = t.alignGridTop, o = this.rootEl, i = function (e) { for (var t = mo(e), n = e.getBoundingClientRect(), r = 0, o = t; r < o.length; r++) { var i = Xr(n, o[r].getBoundingClientRect()); if (!i) return null; n = i } return n }(n); if (i) { var a = o.getBoundingClientRect(), s = r ? Se(n, ".fc-scrollgrid").getBoundingClientRect().top : i.top, l = e ? i.right - a.width : i.left; s = Math.max(s, 10), l = Math.min(l, document.documentElement.clientWidth - 10 - a.width), l = Math.max(l, 10); var u = o.offsetParent.getBoundingClientRect(); we(o, { top: s - u.top, left: l - u.left }) } }, t }(Uo), gs = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.handleRootEl = function (e) { t.rootEl = e, e ? t.context.registerInteractiveComponent(t, { el: e, useEventCenter: !1 }) : t.context.unregisterInteractiveComponent(t) }, t } return n(t, e), t.prototype.render = function () { var e = this.context, t = e.options, n = e.dateEnv, r = this.props, o = r.startDate, i = r.todayRange, a = r.dateProfile, s = n.format(o, t.dayPopoverFormat); return _o(us, { date: o, dateProfile: a, todayRange: i, elRef: this.handleRootEl }, (function (e, t, n) { return _o(vs, { elRef: e, id: r.id, title: s, extraClassNames: ["fc-more-popover"].concat(t), extraAttrs: n, parentEl: r.parentEl, alignmentEl: r.alignmentEl, alignGridTop: r.alignGridTop, onClose: r.onClose }, _o(ss, { date: o, dateProfile: a, todayRange: i }, (function (e, t) { return t && _o("div", { className: "fc-more-popover-misc", ref: e }, t) })), r.children) })) }, t.prototype.queryHit = function (e, t, n, o) { var i = this.rootEl, a = this.props; return e >= 0 && e < n && t >= 0 && t < o ? { dateProfile: a.dateProfile, dateSpan: r({ allDay: !0, range: { start: a.startDate, end: a.endDate } }, a.extraDateSpan), dayEl: i, rect: { left: 0, top: 0, right: n, bottom: o }, layer: 1 } : null }, t }(Bo), ms = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.linkElRef = ko(), t.state = { isPopoverOpen: !1, popoverId: xe() }, t.handleClick = function (e) { var n = t, r = n.props, o = n.context, i = o.options.moreLinkClick, a = Es(r).start; function s(e) { var t = e.eventRange, n = t.def, r = t.instance, i = t.range; return { event: new xr(o, n, r), start: o.dateEnv.toDate(i.start), end: o.dateEnv.toDate(i.end), isStart: e.isStart, isEnd: e.isEnd } } "function" == typeof i && (i = i({ date: a, allDay: Boolean(r.allDayDate), allSegs: r.allSegs.map(s), hiddenSegs: r.hiddenSegs.map(s), jsEvent: e, view: o.viewApi })), i && "popover" !== i ? "string" == typeof i && o.calendarApi.zoomTo(a, i) : t.setState({ isPopoverOpen: !0 }) }, t.handlePopoverClose = function () { t.setState({ isPopoverOpen: !1 }) }, t } return n(t, e), t.prototype.render = function () { var e = this, t = this.props, n = this.state; return _o(Oo.Consumer, null, (function (r) { var o = r.viewApi, i = r.options, a = r.calendarApi, s = i.moreLinkText, l = t.moreCnt, u = Es(t), c = "function" == typeof s ? s.call(a, l) : "+" + l + " " + s, d = Xe(i.moreLinkHint, [l], c), p = { num: l, shortText: "+" + l, text: c, view: o }; return _o(xo, null, Boolean(t.moreCnt) && _o(Yo, { elRef: e.linkElRef, hookProps: p, classNames: i.moreLinkClassNames, content: i.moreLinkContent, defaultContent: t.defaultContent || ys, didMount: i.moreLinkDidMount, willUnmount: i.moreLinkWillUnmount }, (function (r, o, i, a) { return t.children(r, ["fc-more-link"].concat(o), i, a, e.handleClick, d, n.isPopoverOpen, n.isPopoverOpen ? n.popoverId : "") })), n.isPopoverOpen && _o(gs, { id: n.popoverId, startDate: u.start, endDate: u.end, dateProfile: t.dateProfile, todayRange: t.todayRange, extraDateSpan: t.extraDateSpan, parentEl: e.parentEl, alignmentEl: t.alignmentElRef.current, alignGridTop: t.alignGridTop, onClose: e.handlePopoverClose }, t.popoverContent())) })) }, t.prototype.componentDidMount = function () { this.updateParentEl() }, t.prototype.componentDidUpdate = function () { this.updateParentEl() }, t.prototype.updateParentEl = function () { this.linkElRef.current && (this.parentEl = Se(this.linkElRef.current, ".fc-view-harness")) }, t }(Uo); function ys(e) { return e.text } function Es(e) { if (e.allDayDate) return { start: e.allDayDate, end: tt(e.allDayDate, 1) }; var t, n = e.hiddenSegs; return { start: Ss(n), end: (t = n, t.reduce(Ds).eventRange.range.end) } } function Ss(e) { return e.reduce(bs).eventRange.range.start } function bs(e, t) { return e.eventRange.range.start < t.eventRange.range.start ? e : t } function Ds(e, t) { return e.eventRange.range.end > t.eventRange.range.end ? e : t } var Cs = function (e) { function t(t, n) { void 0 === n && (n = {}); var o = e.call(this) || this; return o.isRendering = !1, o.isRendered = !1, o.currentClassNames = [], o.customContentRenderId = 0, o.handleAction = function (e) { switch (e.type) { case "SET_EVENT_DRAG": case "SET_EVENT_RESIZE": o.renderRunner.tryDrain() } }, o.handleData = function (e) { o.currentData = e, o.renderRunner.request(e.calendarOptions.rerenderDelay) }, o.handleRenderRequest = function () { if (o.isRendering) { o.isRendered = !0; var e = o.currentData; To(_o(ga, { options: e.calendarOptions, theme: e.theme, emitter: e.emitter }, (function (t, n, i, a) { return o.setClassNames(t), o.setHeight(n), _o(Zo.Provider, { value: o.customContentRenderId }, _o(fa, r({ isHeightAuto: i, forPrint: a }, e))) })), o.el) } else o.isRendered && (o.isRendered = !1, No(o.el), o.setClassNames([]), o.setHeight("")); Po() }, o.el = t, o.renderRunner = new Mi(o.handleRenderRequest), new Ni({ optionOverrides: n, calendarApi: o, onAction: o.handleAction, onData: o.handleData }), o } return n(t, e), Object.defineProperty(t.prototype, "view", { get: function () { return this.currentData.viewApi }, enumerable: !1, configurable: !0 }), t.prototype.render = function () { var e = this.isRendering; e ? this.customContentRenderId += 1 : this.isRendering = !0, this.renderRunner.request(), e && this.updateSize() }, t.prototype.destroy = function () { this.isRendering && (this.isRendering = !1, this.renderRunner.request()) }, t.prototype.updateSize = function () { e.prototype.updateSize.call(this), Po() }, t.prototype.batchRendering = function (e) { this.renderRunner.pause("batchRendering"), e(), this.renderRunner.resume("batchRendering") }, t.prototype.pauseRendering = function () { this.renderRunner.pause("pauseRendering") }, t.prototype.resumeRendering = function () { this.renderRunner.resume("pauseRendering", !0) }, t.prototype.resetOptions = function (e, t) { this.currentDataManager.resetOptions(e, t) }, t.prototype.setClassNames = function (e) { if (!Gt(e, this.currentClassNames)) { for (var t = this.el.classList, n = 0, r = this.currentClassNames; n < r.length; n++) { var o = r[n]; t.remove(o) } for (var i = 0, a = e; i < a.length; i++) { o = a[i]; t.add(o) } this.currentClassNames = e } }, t.prototype.setHeight = function (e) { Re(this.el, "height", e) }, t }(kr); ia.touchMouseIgnoreWait = 500; var ws = 0, Rs = 0, _s = !1, Ts = function () { function e(e) { var t = this; this.subjectEl = null, this.selector = "", this.handleSelector = "", this.shouldIgnoreMove = !1, this.shouldWatchScroll = !0, this.isDragging = !1, this.isTouchDragging = !1, this.wasTouchScroll = !1, this.handleMouseDown = function (e) { if (!t.shouldIgnoreMouse() && function (e) { return 0 === e.button && !e.ctrlKey }(e) && t.tryStart(e)) { var n = t.createEventFromMouse(e, !0); t.emitter.trigger("pointerdown", n), t.initScrollWatch(n), t.shouldIgnoreMove || document.addEventListener("mousemove", t.handleMouseMove), document.addEventListener("mouseup", t.handleMouseUp) } }, this.handleMouseMove = function (e) { var n = t.createEventFromMouse(e); t.recordCoords(n), t.emitter.trigger("pointermove", n) }, this.handleMouseUp = function (e) { document.removeEventListener("mousemove", t.handleMouseMove), document.removeEventListener("mouseup", t.handleMouseUp), t.emitter.trigger("pointerup", t.createEventFromMouse(e)), t.cleanup() }, this.handleTouchStart = function (e) { if (t.tryStart(e)) { t.isTouchDragging = !0; var n = t.createEventFromTouch(e, !0); t.emitter.trigger("pointerdown", n), t.initScrollWatch(n); var r = e.target; t.shouldIgnoreMove || r.addEventListener("touchmove", t.handleTouchMove), r.addEventListener("touchend", t.handleTouchEnd), r.addEventListener("touchcancel", t.handleTouchEnd), window.addEventListener("scroll", t.handleTouchScroll, !0) } }, this.handleTouchMove = function (e) { var n = t.createEventFromTouch(e); t.recordCoords(n), t.emitter.trigger("pointermove", n) }, this.handleTouchEnd = function (e) { if (t.isDragging) { var n = e.target; n.removeEventListener("touchmove", t.handleTouchMove), n.removeEventListener("touchend", t.handleTouchEnd), n.removeEventListener("touchcancel", t.handleTouchEnd), window.removeEventListener("scroll", t.handleTouchScroll, !0), t.emitter.trigger("pointerup", t.createEventFromTouch(e)), t.cleanup(), t.isTouchDragging = !1, ws += 1, setTimeout((function () { ws -= 1 }), ia.touchMouseIgnoreWait) } }, this.handleTouchScroll = function () { t.wasTouchScroll = !0 }, this.handleScroll = function (e) { if (!t.shouldIgnoreMove) { var n = window.pageXOffset - t.prevScrollX + t.prevPageX, r = window.pageYOffset - t.prevScrollY + t.prevPageY; t.emitter.trigger("pointermove", { origEvent: e, isTouch: t.isTouchDragging, subjectEl: t.subjectEl, pageX: n, pageY: r, deltaX: n - t.origPageX, deltaY: r - t.origPageY }) } }, this.containerEl = e, this.emitter = new Eo, e.addEventListener("mousedown", this.handleMouseDown), e.addEventListener("touchstart", this.handleTouchStart, { passive: !0 }), 1 === (Rs += 1) && window.addEventListener("touchmove", ks, { passive: !1 }) } return e.prototype.destroy = function () { this.containerEl.removeEventListener("mousedown", this.handleMouseDown), this.containerEl.removeEventListener("touchstart", this.handleTouchStart, { passive: !0 }), (Rs -= 1) || window.removeEventListener("touchmove", ks, { passive: !1 }) }, e.prototype.tryStart = function (e) { var t = this.querySubjectEl(e), n = e.target; return !(!t || this.handleSelector && !Se(n, this.handleSelector)) && (this.subjectEl = t, this.isDragging = !0, this.wasTouchScroll = !1, !0) }, e.prototype.cleanup = function () { _s = !1, this.isDragging = !1, this.subjectEl = null, this.destroyScrollWatch() }, e.prototype.querySubjectEl = function (e) { return this.selector ? Se(e.target, this.selector) : this.containerEl }, e.prototype.shouldIgnoreMouse = function () { return ws || this.isTouchDragging }, e.prototype.cancelTouchScroll = function () { this.isDragging && (_s = !0) }, e.prototype.initScrollWatch = function (e) { this.shouldWatchScroll && (this.recordCoords(e), window.addEventListener("scroll", this.handleScroll, !0)) }, e.prototype.recordCoords = function (e) { this.shouldWatchScroll && (this.prevPageX = e.pageX, this.prevPageY = e.pageY, this.prevScrollX = window.pageXOffset, this.prevScrollY = window.pageYOffset) }, e.prototype.destroyScrollWatch = function () { this.shouldWatchScroll && window.removeEventListener("scroll", this.handleScroll, !0) }, e.prototype.createEventFromMouse = function (e, t) { var n = 0, r = 0; return t ? (this.origPageX = e.pageX, this.origPageY = e.pageY) : (n = e.pageX - this.origPageX, r = e.pageY - this.origPageY), { origEvent: e, isTouch: !1, subjectEl: this.subjectEl, pageX: e.pageX, pageY: e.pageY, deltaX: n, deltaY: r } }, e.prototype.createEventFromTouch = function (e, t) { var n, r, o = e.touches, i = 0, a = 0; return o && o.length ? (n = o[0].pageX, r = o[0].pageY) : (n = e.pageX, r = e.pageY), t ? (this.origPageX = n, this.origPageY = r) : (i = n - this.origPageX, a = r - this.origPageY), { origEvent: e, isTouch: !0, subjectEl: this.subjectEl, pageX: n, pageY: r, deltaX: i, deltaY: a } }, e }(); function ks(e) { _s && e.preventDefault() } var xs = function () { function e() { this.isVisible = !1, this.sourceEl = null, this.mirrorEl = null, this.sourceElRect = null, this.parentNode = document.body, this.zIndex = 9999, this.revertDuration = 0 } return e.prototype.start = function (e, t, n) { this.sourceEl = e, this.sourceElRect = this.sourceEl.getBoundingClientRect(), this.origScreenX = t - window.pageXOffset, this.origScreenY = n - window.pageYOffset, this.deltaX = 0, this.deltaY = 0, this.updateElPosition() }, e.prototype.handleMove = function (e, t) { this.deltaX = e - window.pageXOffset - this.origScreenX, this.deltaY = t - window.pageYOffset - this.origScreenY, this.updateElPosition() }, e.prototype.setIsVisible = function (e) { e ? this.isVisible || (this.mirrorEl && (this.mirrorEl.style.display = ""), this.isVisible = e, this.updateElPosition()) : this.isVisible && (this.mirrorEl && (this.mirrorEl.style.display = "none"), this.isVisible = e) }, e.prototype.stop = function (e, t) { var n = this, r = function () { n.cleanup(), t() }; e && this.mirrorEl && this.isVisible && this.revertDuration && (this.deltaX || this.deltaY) ? this.doRevertAnimation(r, this.revertDuration) : setTimeout(r, 0) }, e.prototype.doRevertAnimation = function (e, t) { var n = this.mirrorEl, r = this.sourceEl.getBoundingClientRect(); n.style.transition = "top " + t + "ms,left " + t + "ms", we(n, { left: r.left, top: r.top }), Ne(n, (function () { n.style.transition = "", e() })) }, e.prototype.cleanup = function () { this.mirrorEl && (Ee(this.mirrorEl), this.mirrorEl = null), this.sourceEl = null }, e.prototype.updateElPosition = function () { this.sourceEl && this.isVisible && we(this.getMirrorEl(), { left: this.sourceElRect.left + this.deltaX, top: this.sourceElRect.top + this.deltaY }) }, e.prototype.getMirrorEl = function () { var e = this.sourceElRect, t = this.mirrorEl; return t || ((t = this.mirrorEl = this.sourceEl.cloneNode(!0)).classList.add("fc-unselectable"), t.classList.add("fc-event-dragging"), we(t, { position: "fixed", zIndex: this.zIndex, visibility: "", boxSizing: "border-box", width: e.right - e.left, height: e.bottom - e.top, right: "auto", bottom: "auto", margin: 0 }), this.parentNode.appendChild(t)), t }, e }(), Ms = function (e) { function t(t, n) { var r = e.call(this) || this; return r.handleScroll = function () { r.scrollTop = r.scrollController.getScrollTop(), r.scrollLeft = r.scrollController.getScrollLeft(), r.handleScrollChange() }, r.scrollController = t, r.doesListening = n, r.scrollTop = r.origScrollTop = t.getScrollTop(), r.scrollLeft = r.origScrollLeft = t.getScrollLeft(), r.scrollWidth = t.getScrollWidth(), r.scrollHeight = t.getScrollHeight(), r.clientWidth = t.getClientWidth(), r.clientHeight = t.getClientHeight(), r.clientRect = r.computeClientRect(), r.doesListening && r.getEventTarget().addEventListener("scroll", r.handleScroll), r } return n(t, e), t.prototype.destroy = function () { this.doesListening && this.getEventTarget().removeEventListener("scroll", this.handleScroll) }, t.prototype.getScrollTop = function () { return this.scrollTop }, t.prototype.getScrollLeft = function () { return this.scrollLeft }, t.prototype.setScrollTop = function (e) { this.scrollController.setScrollTop(e), this.doesListening || (this.scrollTop = Math.max(Math.min(e, this.getMaxScrollTop()), 0), this.handleScrollChange()) }, t.prototype.setScrollLeft = function (e) { this.scrollController.setScrollLeft(e), this.doesListening || (this.scrollLeft = Math.max(Math.min(e, this.getMaxScrollLeft()), 0), this.handleScrollChange()) }, t.prototype.getClientWidth = function () { return this.clientWidth }, t.prototype.getClientHeight = function () { return this.clientHeight }, t.prototype.getScrollWidth = function () { return this.scrollWidth }, t.prototype.getScrollHeight = function () { return this.scrollHeight }, t.prototype.handleScrollChange = function () { }, t }(bo), Is = function (e) { function t(t, n) { return e.call(this, new Do(t), n) || this } return n(t, e), t.prototype.getEventTarget = function () { return this.scrollController.el }, t.prototype.computeClientRect = function () { return vo(this.scrollController.el) }, t }(Ms), Ps = function (e) { function t(t) { return e.call(this, new Co, t) || this } return n(t, e), t.prototype.getEventTarget = function () { return window }, t.prototype.computeClientRect = function () { return { left: this.scrollLeft, right: this.scrollLeft + this.clientWidth, top: this.scrollTop, bottom: this.scrollTop + this.clientHeight } }, t.prototype.handleScrollChange = function () { this.clientRect = this.computeClientRect() }, t }(Ms), Ns = "function" == typeof performance ? performance.now : Date.now, Hs = function () { function e() { var e = this; this.isEnabled = !0, this.scrollQuery = [window, ".fc-scroller"], this.edgeThreshold = 50, this.maxVelocity = 300, this.pointerScreenX = null, this.pointerScreenY = null, this.isAnimating = !1, this.scrollCaches = null, this.everMovedUp = !1, this.everMovedDown = !1, this.everMovedLeft = !1, this.everMovedRight = !1, this.animate = function () { if (e.isAnimating) { var t = e.computeBestEdge(e.pointerScreenX + window.pageXOffset, e.pointerScreenY + window.pageYOffset); if (t) { var n = Ns(); e.handleSide(t, (n - e.msSinceRequest) / 1e3), e.requestAnimation(n) } else e.isAnimating = !1 } } } return e.prototype.start = function (e, t, n) { this.isEnabled && (this.scrollCaches = this.buildCaches(n), this.pointerScreenX = null, this.pointerScreenY = null, this.everMovedUp = !1, this.everMovedDown = !1, this.everMovedLeft = !1, this.everMovedRight = !1, this.handleMove(e, t)) }, e.prototype.handleMove = function (e, t) { if (this.isEnabled) { var n = e - window.pageXOffset, r = t - window.pageYOffset, o = null === this.pointerScreenY ? 0 : r - this.pointerScreenY, i = null === this.pointerScreenX ? 0 : n - this.pointerScreenX; o < 0 ? this.everMovedUp = !0 : o > 0 && (this.everMovedDown = !0), i < 0 ? this.everMovedLeft = !0 : i > 0 && (this.everMovedRight = !0), this.pointerScreenX = n, this.pointerScreenY = r, this.isAnimating || (this.isAnimating = !0, this.requestAnimation(Ns())) } }, e.prototype.stop = function () { if (this.isEnabled) { this.isAnimating = !1; for (var e = 0, t = this.scrollCaches; e < t.length; e++) { t[e].destroy() } this.scrollCaches = null } }, e.prototype.requestAnimation = function (e) { this.msSinceRequest = e, requestAnimationFrame(this.animate) }, e.prototype.handleSide = function (e, t) { var n = e.scrollCache, r = this.edgeThreshold, o = r - e.distance, i = o * o / (r * r) * this.maxVelocity * t, a = 1; switch (e.name) { case "left": a = -1; case "right": n.setScrollLeft(n.getScrollLeft() + i * a); break; case "top": a = -1; case "bottom": n.setScrollTop(n.getScrollTop() + i * a) } }, e.prototype.computeBestEdge = function (e, t) { for (var n = this.edgeThreshold, r = null, o = 0, i = this.scrollCaches; o < i.length; o++) { var a = i[o], s = a.clientRect, l = e - s.left, u = s.right - e, c = t - s.top, d = s.bottom - t; l >= 0 && u >= 0 && c >= 0 && d >= 0 && (c <= n && this.everMovedUp && a.canScrollUp() && (!r || r.distance > c) && (r = { scrollCache: a, name: "top", distance: c }), d <= n && this.everMovedDown && a.canScrollDown() && (!r || r.distance > d) && (r = { scrollCache: a, name: "bottom", distance: d }), l <= n && this.everMovedLeft && a.canScrollLeft() && (!r || r.distance > l) && (r = { scrollCache: a, name: "left", distance: l }), u <= n && this.everMovedRight && a.canScrollRight() && (!r || r.distance > u) && (r = { scrollCache: a, name: "right", distance: u })) } return r }, e.prototype.buildCaches = function (e) { return this.queryScrollEls(e).map((function (e) { return e === window ? new Ps(!1) : new Is(e, !1) })) }, e.prototype.queryScrollEls = function (e) { for (var t = [], n = 0, r = this.scrollQuery; n < r.length; n++) { var o = r[n]; "object" == typeof o ? t.push(o) : t.push.apply(t, Array.prototype.slice.call(Te(e).querySelectorAll(o))) } return t }, e }(), Os = function (e) { function t(t, n) { var r = e.call(this, t) || this; r.containerEl = t, r.delay = null, r.minDistance = 0, r.touchScrollAllowed = !0, r.mirrorNeedsRevert = !1, r.isInteracting = !1, r.isDragging = !1, r.isDelayEnded = !1, r.isDistanceSurpassed = !1, r.delayTimeoutId = null, r.onPointerDown = function (e) { r.isDragging || (r.isInteracting = !0, r.isDelayEnded = !1, r.isDistanceSurpassed = !1, Ve(document.body), Be(document.body), e.isTouch || e.origEvent.preventDefault(), r.emitter.trigger("pointerdown", e), r.isInteracting && !r.pointer.shouldIgnoreMove && (r.mirror.setIsVisible(!1), r.mirror.start(e.subjectEl, e.pageX, e.pageY), r.startDelay(e), r.minDistance || r.handleDistanceSurpassed(e))) }, r.onPointerMove = function (e) { if (r.isInteracting) { if (r.emitter.trigger("pointermove", e), !r.isDistanceSurpassed) { var t = r.minDistance, n = e.deltaX, o = e.deltaY; n * n + o * o >= t * t && r.handleDistanceSurpassed(e) } r.isDragging && ("scroll" !== e.origEvent.type && (r.mirror.handleMove(e.pageX, e.pageY), r.autoScroller.handleMove(e.pageX, e.pageY)), r.emitter.trigger("dragmove", e)) } }, r.onPointerUp = function (e) { r.isInteracting && (r.isInteracting = !1, Fe(document.body), ze(document.body), r.emitter.trigger("pointerup", e), r.isDragging && (r.autoScroller.stop(), r.tryStopDrag(e)), r.delayTimeoutId && (clearTimeout(r.delayTimeoutId), r.delayTimeoutId = null)) }; var o = r.pointer = new Ts(t); return o.emitter.on("pointerdown", r.onPointerDown), o.emitter.on("pointermove", r.onPointerMove), o.emitter.on("pointerup", r.onPointerUp), n && (o.selector = n), r.mirror = new xs, r.autoScroller = new Hs, r } return n(t, e), t.prototype.destroy = function () { this.pointer.destroy(), this.onPointerUp({}) }, t.prototype.startDelay = function (e) { var t = this; "number" == typeof this.delay ? this.delayTimeoutId = setTimeout((function () { t.delayTimeoutId = null, t.handleDelayEnd(e) }), this.delay) : this.handleDelayEnd(e) }, t.prototype.handleDelayEnd = function (e) { this.isDelayEnded = !0, this.tryStartDrag(e) }, t.prototype.handleDistanceSurpassed = function (e) { this.isDistanceSurpassed = !0, this.tryStartDrag(e) }, t.prototype.tryStartDrag = function (e) { this.isDelayEnded && this.isDistanceSurpassed && (this.pointer.wasTouchScroll && !this.touchScrollAllowed || (this.isDragging = !0, this.mirrorNeedsRevert = !1, this.autoScroller.start(e.pageX, e.pageY, this.containerEl), this.emitter.trigger("dragstart", e), !1 === this.touchScrollAllowed && this.pointer.cancelTouchScroll())) }, t.prototype.tryStopDrag = function (e) { this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, e)) }, t.prototype.stopDrag = function (e) { this.isDragging = !1, this.emitter.trigger("dragend", e) }, t.prototype.setIgnoreMove = function (e) { this.pointer.shouldIgnoreMove = e }, t.prototype.setMirrorIsVisible = function (e) { this.mirror.setIsVisible(e) }, t.prototype.setMirrorNeedsRevert = function (e) { this.mirrorNeedsRevert = e }, t.prototype.setAutoScrollEnabled = function (e) { this.autoScroller.isEnabled = e }, t }(oa), As = function () { function e(e) { this.origRect = go(e), this.scrollCaches = mo(e).map((function (e) { return new Is(e, !0) })) } return e.prototype.destroy = function () { for (var e = 0, t = this.scrollCaches; e < t.length; e++) { t[e].destroy() } }, e.prototype.computeLeft = function () { for (var e = this.origRect.left, t = 0, n = this.scrollCaches; t < n.length; t++) { var r = n[t]; e += r.origScrollLeft - r.getScrollLeft() } return e }, e.prototype.computeTop = function () { for (var e = this.origRect.top, t = 0, n = this.scrollCaches; t < n.length; t++) { var r = n[t]; e += r.origScrollTop - r.getScrollTop() } return e }, e.prototype.isWithinClipping = function (e, t) { for (var n, r, o = { left: e, top: t }, i = 0, a = this.scrollCaches; i < a.length; i++) { var s = a[i]; if (n = s.getEventTarget(), r = void 0, "HTML" !== (r = n.tagName) && "BODY" !== r && !Zr(o, s.clientRect)) return !1 } return !0 }, e }(); var Ls = function () { function e(e, t) { var n = this; this.useSubjectCenter = !1, this.requireInitial = !0, this.initialHit = null, this.movingHit = null, this.finalHit = null, this.handlePointerDown = function (e) { var t = n.dragging; n.initialHit = null, n.movingHit = null, n.finalHit = null, n.prepareHits(), n.processFirstCoord(e), n.initialHit || !n.requireInitial ? (t.setIgnoreMove(!1), n.emitter.trigger("pointerdown", e)) : t.setIgnoreMove(!0) }, this.handleDragStart = function (e) { n.emitter.trigger("dragstart", e), n.handleMove(e, !0) }, this.handleDragMove = function (e) { n.emitter.trigger("dragmove", e), n.handleMove(e) }, this.handlePointerUp = function (e) { n.releaseHits(), n.emitter.trigger("pointerup", e) }, this.handleDragEnd = function (e) { n.movingHit && n.emitter.trigger("hitupdate", null, !0, e), n.finalHit = n.movingHit, n.movingHit = null, n.emitter.trigger("dragend", e) }, this.droppableStore = t, e.emitter.on("pointerdown", this.handlePointerDown), e.emitter.on("dragstart", this.handleDragStart), e.emitter.on("dragmove", this.handleDragMove), e.emitter.on("pointerup", this.handlePointerUp), e.emitter.on("dragend", this.handleDragEnd), this.dragging = e, this.emitter = new Eo } return e.prototype.processFirstCoord = function (e) { var t, n = { left: e.pageX, top: e.pageY }, r = n, o = e.subjectEl; o instanceof HTMLElement && (r = Kr(r, t = go(o))); var i = this.initialHit = this.queryHitForOffset(r.left, r.top); if (i) { if (this.useSubjectCenter && t) { var a = Xr(t, i.rect); a && (r = $r(a)) } this.coordAdjust = Jr(r, n) } else this.coordAdjust = { left: 0, top: 0 } }, e.prototype.handleMove = function (e, t) { var n = this.queryHitForOffset(e.pageX + this.coordAdjust.left, e.pageY + this.coordAdjust.top); !t && Us(this.movingHit, n) || (this.movingHit = n, this.emitter.trigger("hitupdate", n, !1, e)) }, e.prototype.prepareHits = function () { this.offsetTrackers = bt(this.droppableStore, (function (e) { return e.component.prepareHits(), new As(e.el) })) }, e.prototype.releaseHits = function () { var e = this.offsetTrackers; for (var t in e) e[t].destroy(); this.offsetTrackers = {} }, e.prototype.queryHitForOffset = function (e, t) { var n = this.droppableStore, r = this.offsetTrackers, o = null; for (var i in n) { var a = n[i].component, s = r[i]; if (s && s.isWithinClipping(e, t)) { var l = s.computeLeft(), u = s.computeTop(), c = e - l, d = t - u, p = s.origRect, f = p.right - p.left, h = p.bottom - p.top; if (c >= 0 && c < f && d >= 0 && d < h) { var v = a.queryHit(c, d, f, h); v && Yn(v.dateProfile.activeRange, v.dateSpan.range) && (!o || v.layer > o.layer) && (v.componentId = i, v.context = a.context, v.rect.left += l, v.rect.right += l, v.rect.top += u, v.rect.bottom += u, o = v) } } } return o }, e }(); function Us(e, t) { return !e && !t || Boolean(e) === Boolean(t) && fr(e.dateSpan, t.dateSpan) } function Ws(e, t) { for (var n, o, i = {}, a = 0, s = t.pluginHooks.datePointTransforms; a < s.length; a++) { var l = s[a]; r(i, l(e, t)) } return r(i, (n = e, { date: (o = t.dateEnv).toDate(n.range.start), dateStr: o.formatIso(n.range.start, { omitTime: n.allDay }), allDay: n.allDay })), i } var Vs = function (e) { function t(t) { var n = e.call(this, t) || this; n.handlePointerDown = function (e) { var t = n.dragging, r = e.origEvent.target; t.setIgnoreMove(!n.component.isValidDateDownEl(r)) }, n.handleDragEnd = function (e) { var t = n.component; if (!n.dragging.pointer.wasTouchScroll) { var o = n.hitDragging, i = o.initialHit, a = o.finalHit; if (i && a && Us(i, a)) { var s = t.context, l = r(r({}, Ws(i.dateSpan, s)), { dayEl: i.dayEl, jsEvent: e.origEvent, view: s.viewApi || s.calendarApi.view }); s.emitter.trigger("dateClick", l) } } }, n.dragging = new Os(t.el), n.dragging.autoScroller.isEnabled = !1; var o = n.hitDragging = new Ls(n.dragging, na(t)); return o.emitter.on("pointerdown", n.handlePointerDown), o.emitter.on("dragend", n.handleDragEnd), n } return n(t, e), t.prototype.destroy = function () { this.dragging.destroy() }, t }(ea), Fs = function (e) { function t(t) { var n = e.call(this, t) || this; n.dragSelection = null, n.handlePointerDown = function (e) { var t = n, r = t.component, o = t.dragging, i = r.context.options.selectable && r.isValidDateDownEl(e.origEvent.target); o.setIgnoreMove(!i), o.delay = e.isTouch ? function (e) { var t = e.context.options, n = t.selectLongPressDelay; null == n && (n = t.longPressDelay); return n }(r) : null }, n.handleDragStart = function (e) { n.component.context.calendarApi.unselect(e) }, n.handleHitUpdate = function (e, t) { var o = n.component.context, i = null, a = !1; if (e) { var s = n.hitDragging.initialHit; e.componentId === s.componentId && n.isHitComboAllowed && !n.isHitComboAllowed(s, e) || (i = function (e, t, n) { var o = e.dateSpan, i = t.dateSpan, a = [o.range.start, o.range.end, i.range.start, i.range.end]; a.sort(Ke); for (var s = {}, l = 0, u = n; l < u.length; l++) { var c = (0, u[l])(e, t); if (!1 === c) return null; c && r(s, c) } return s.range = { start: a[0], end: a[3] }, s.allDay = o.allDay, s }(s, e, o.pluginHooks.dateSelectionTransformers)), i && Pa(i, e.dateProfile, o) || (a = !0, i = null) } i ? o.dispatch({ type: "SELECT_DATES", selection: i }) : t || o.dispatch({ type: "UNSELECT_DATES" }), a ? Ue() : We(), t || (n.dragSelection = i) }, n.handlePointerUp = function (e) { n.dragSelection && (mr(n.dragSelection, e, n.component.context), n.dragSelection = null) }; var o = t.component.context.options, i = n.dragging = new Os(t.el); i.touchScrollAllowed = !1, i.minDistance = o.selectMinDistance || 0, i.autoScroller.isEnabled = o.dragScroll; var a = n.hitDragging = new Ls(n.dragging, na(t)); return a.emitter.on("pointerdown", n.handlePointerDown), a.emitter.on("dragstart", n.handleDragStart), a.emitter.on("hitupdate", n.handleHitUpdate), a.emitter.on("pointerup", n.handlePointerUp), n } return n(t, e), t.prototype.destroy = function () { this.dragging.destroy() }, t }(ea); var Bs = function (e) { function t(n) { var o = e.call(this, n) || this; o.subjectEl = null, o.subjectSeg = null, o.isDragging = !1, o.eventRange = null, o.relevantEvents = null, o.receivingContext = null, o.validMutation = null, o.mutatedRelevantEvents = null, o.handlePointerDown = function (e) { var t = e.origEvent.target, n = o, r = n.component, i = n.dragging, a = i.mirror, s = r.context.options, l = r.context; o.subjectEl = e.subjectEl; var u = o.subjectSeg = Jn(e.subjectEl), c = (o.eventRange = u.eventRange).instance.instanceId; o.relevantEvents = bn(l.getCurrentData().eventStore, c), i.minDistance = e.isTouch ? 0 : s.eventDragMinDistance, i.delay = e.isTouch && c !== r.props.eventSelection ? function (e) { var t = e.context.options, n = t.eventLongPressDelay; null == n && (n = t.longPressDelay); return n }(r) : null, s.fixedMirrorParent ? a.parentNode = s.fixedMirrorParent : a.parentNode = Se(t, ".fc"), a.revertDuration = s.dragRevertDuration; var d = r.isValidSegDownEl(t) && !Se(t, ".fc-event-resizer"); i.setIgnoreMove(!d), o.isDragging = d && e.subjectEl.classList.contains("fc-event-draggable") }, o.handleDragStart = function (e) { var t = o.component.context, n = o.eventRange, r = n.instance.instanceId; e.isTouch ? r !== o.component.props.eventSelection && t.dispatch({ type: "SELECT_EVENT", eventInstanceId: r }) : t.dispatch({ type: "UNSELECT_EVENT" }), o.isDragging && (t.calendarApi.unselect(e), t.emitter.trigger("eventDragStart", { el: o.subjectEl, event: new xr(t, n.def, n.instance), jsEvent: e.origEvent, view: t.viewApi })) }, o.handleHitUpdate = function (e, t) { if (o.isDragging) { var n = o.relevantEvents, r = o.hitDragging.initialHit, i = o.component.context, a = null, s = null, l = null, u = !1, c = { affectedEvents: n, mutatedEvents: { defs: {}, instances: {} }, isEvent: !0 }; if (e) { var d = (a = e.context).options; i === a || d.editable && d.droppable ? (s = function (e, t, n) { var r = e.dateSpan, o = t.dateSpan, i = r.range.start, a = o.range.start, s = {}; r.allDay !== o.allDay && (s.allDay = o.allDay, s.hasEnd = t.context.options.allDayMaintainDuration, o.allDay && (i = lt(i))); var l = Fn(i, a, e.context.dateEnv, e.componentId === t.componentId ? e.largeUnit : null); l.milliseconds && (s.allDay = !1); for (var u = { datesDelta: l, standardProps: s }, c = 0, d = n; c < d.length; c++) { (0, d[c])(u, e, t) } return u }(r, e, a.getCurrentData().pluginHooks.eventDragMutationMassagers)) && (l = Sr(n, a.getCurrentData().eventUiBases, s, a), c.mutatedEvents = l, Ia(c, e.dateProfile, a) || (u = !0, s = null, l = null, c.mutatedEvents = { defs: {}, instances: {} })) : a = null } o.displayDrag(a, c), u ? Ue() : We(), t || (i === a && Us(r, e) && (s = null), o.dragging.setMirrorNeedsRevert(!s), o.dragging.setMirrorIsVisible(!e || !Te(o.subjectEl).querySelector(".fc-event-mirror")), o.receivingContext = a, o.validMutation = s, o.mutatedRelevantEvents = l) } }, o.handlePointerUp = function () { o.isDragging || o.cleanup() }, o.handleDragEnd = function (e) { if (o.isDragging) { var t = o.component.context, n = t.viewApi, i = o, a = i.receivingContext, s = i.validMutation, l = o.eventRange.def, u = o.eventRange.instance, c = new xr(t, l, u), d = o.relevantEvents, p = o.mutatedRelevantEvents, f = o.hitDragging.finalHit; if (o.clearDrag(), t.emitter.trigger("eventDragStop", { el: o.subjectEl, event: c, jsEvent: e.origEvent, view: n }), s) { if (a === t) { var h = new xr(t, p.defs[l.defId], u ? p.instances[u.instanceId] : null); t.dispatch({ type: "MERGE_EVENTS", eventStore: p }); for (var v = { oldEvent: c, event: h, relatedEvents: Ir(p, t, u), revert: function () { t.dispatch({ type: "MERGE_EVENTS", eventStore: d }) } }, g = {}, m = 0, y = t.getCurrentData().pluginHooks.eventDropTransformers; m < y.length; m++) { var E = y[m]; r(g, E(s, t)) } t.emitter.trigger("eventDrop", r(r(r({}, v), g), { el: e.subjectEl, delta: s.datesDelta, jsEvent: e.origEvent, view: n })), t.emitter.trigger("eventChange", v) } else if (a) { var S = { event: c, relatedEvents: Ir(d, t, u), revert: function () { t.dispatch({ type: "MERGE_EVENTS", eventStore: d }) } }; t.emitter.trigger("eventLeave", r(r({}, S), { draggedEl: e.subjectEl, view: n })), t.dispatch({ type: "REMOVE_EVENTS", eventStore: d }), t.emitter.trigger("eventRemove", S); var b = p.defs[l.defId], D = p.instances[u.instanceId], C = new xr(a, b, D); a.dispatch({ type: "MERGE_EVENTS", eventStore: p }); var w = { event: C, relatedEvents: Ir(p, a, D), revert: function () { a.dispatch({ type: "REMOVE_EVENTS", eventStore: p }) } }; a.emitter.trigger("eventAdd", w), e.isTouch && a.dispatch({ type: "SELECT_EVENT", eventInstanceId: u.instanceId }), a.emitter.trigger("drop", r(r({}, Ws(f.dateSpan, a)), { draggedEl: e.subjectEl, jsEvent: e.origEvent, view: f.context.viewApi })), a.emitter.trigger("eventReceive", r(r({}, w), { draggedEl: e.subjectEl, view: f.context.viewApi })) } } else t.emitter.trigger("_noEventDrop") } o.cleanup() }; var i = o.component.context.options, a = o.dragging = new Os(n.el); a.pointer.selector = t.SELECTOR, a.touchScrollAllowed = !1, a.autoScroller.isEnabled = i.dragScroll; var s = o.hitDragging = new Ls(o.dragging, ra); return s.useSubjectCenter = n.useEventCenter, s.emitter.on("pointerdown", o.handlePointerDown), s.emitter.on("dragstart", o.handleDragStart), s.emitter.on("hitupdate", o.handleHitUpdate), s.emitter.on("pointerup", o.handlePointerUp), s.emitter.on("dragend", o.handleDragEnd), o } return n(t, e), t.prototype.destroy = function () { this.dragging.destroy() }, t.prototype.displayDrag = function (e, t) { var n = this.component.context, r = this.receivingContext; r && r !== e && (r === n ? r.dispatch({ type: "SET_EVENT_DRAG", state: { affectedEvents: t.affectedEvents, mutatedEvents: { defs: {}, instances: {} }, isEvent: !0 } }) : r.dispatch({ type: "UNSET_EVENT_DRAG" })), e && e.dispatch({ type: "SET_EVENT_DRAG", state: t }) }, t.prototype.clearDrag = function () { var e = this.component.context, t = this.receivingContext; t && t.dispatch({ type: "UNSET_EVENT_DRAG" }), e !== t && e.dispatch({ type: "UNSET_EVENT_DRAG" }) }, t.prototype.cleanup = function () { this.subjectSeg = null, this.isDragging = !1, this.eventRange = null, this.relevantEvents = null, this.receivingContext = null, this.validMutation = null, this.mutatedRelevantEvents = null }, t.SELECTOR = ".fc-event-draggable, .fc-event-resizable", t }(ea); var zs = function (e) { function t(t) { var n = e.call(this, t) || this; n.draggingSegEl = null, n.draggingSeg = null, n.eventRange = null, n.relevantEvents = null, n.validMutation = null, n.mutatedRelevantEvents = null, n.handlePointerDown = function (e) { var t = n.component, r = Jn(n.querySegEl(e)), o = n.eventRange = r.eventRange; n.dragging.minDistance = t.context.options.eventDragMinDistance, n.dragging.setIgnoreMove(!n.component.isValidSegDownEl(e.origEvent.target) || e.isTouch && n.component.props.eventSelection !== o.instance.instanceId) }, n.handleDragStart = function (e) { var t = n.component.context, r = n.eventRange; n.relevantEvents = bn(t.getCurrentData().eventStore, n.eventRange.instance.instanceId); var o = n.querySegEl(e); n.draggingSegEl = o, n.draggingSeg = Jn(o), t.calendarApi.unselect(), t.emitter.trigger("eventResizeStart", { el: o, event: new xr(t, r.def, r.instance), jsEvent: e.origEvent, view: t.viewApi }) }, n.handleHitUpdate = function (e, t, r) { var o = n.component.context, i = n.relevantEvents, a = n.hitDragging.initialHit, s = n.eventRange.instance, l = null, u = null, c = !1, d = { affectedEvents: i, mutatedEvents: { defs: {}, instances: {} }, isEvent: !0 }; e && (e.componentId === a.componentId && n.isHitComboAllowed && !n.isHitComboAllowed(a, e) || (l = function (e, t, n, r) { var o = e.context.dateEnv, i = e.dateSpan.range.start, a = t.dateSpan.range.start, s = Fn(i, a, o, e.largeUnit); if (n) { if (o.add(r.start, s) < r.end) return { startDelta: s } } else if (o.add(r.end, s) > r.start) return { endDelta: s }; return null }(a, e, r.subjectEl.classList.contains("fc-event-resizer-start"), s.range))); l && (u = Sr(i, o.getCurrentData().eventUiBases, l, o), d.mutatedEvents = u, Ia(d, e.dateProfile, o) || (c = !0, l = null, u = null, d.mutatedEvents = null)), u ? o.dispatch({ type: "SET_EVENT_RESIZE", state: d }) : o.dispatch({ type: "UNSET_EVENT_RESIZE" }), c ? Ue() : We(), t || (l && Us(a, e) && (l = null), n.validMutation = l, n.mutatedRelevantEvents = u) }, n.handleDragEnd = function (e) { var t = n.component.context, o = n.eventRange.def, i = n.eventRange.instance, a = new xr(t, o, i), s = n.relevantEvents, l = n.mutatedRelevantEvents; if (t.emitter.trigger("eventResizeStop", { el: n.draggingSegEl, event: a, jsEvent: e.origEvent, view: t.viewApi }), n.validMutation) { var u = new xr(t, l.defs[o.defId], i ? l.instances[i.instanceId] : null); t.dispatch({ type: "MERGE_EVENTS", eventStore: l }); var c = { oldEvent: a, event: u, relatedEvents: Ir(l, t, i), revert: function () { t.dispatch({ type: "MERGE_EVENTS", eventStore: s }) } }; t.emitter.trigger("eventResize", r(r({}, c), { el: n.draggingSegEl, startDelta: n.validMutation.startDelta || Nt(0), endDelta: n.validMutation.endDelta || Nt(0), jsEvent: e.origEvent, view: t.viewApi })), t.emitter.trigger("eventChange", c) } else t.emitter.trigger("_noEventResize"); n.draggingSeg = null, n.relevantEvents = null, n.validMutation = null }; var o = t.component, i = n.dragging = new Os(t.el); i.pointer.selector = ".fc-event-resizer", i.touchScrollAllowed = !1, i.autoScroller.isEnabled = o.context.options.dragScroll; var a = n.hitDragging = new Ls(n.dragging, na(t)); return a.emitter.on("pointerdown", n.handlePointerDown), a.emitter.on("dragstart", n.handleDragStart), a.emitter.on("hitupdate", n.handleHitUpdate), a.emitter.on("dragend", n.handleDragEnd), n } return n(t, e), t.prototype.destroy = function () { this.dragging.destroy() }, t.prototype.querySegEl = function (e) { return Se(e.subjectEl, ".fc-event") }, t }(ea); var js = function () { function e(e) { var t = this; this.context = e, this.isRecentPointerDateSelect = !1, this.matchesCancel = !1, this.matchesEvent = !1, this.onSelect = function (e) { e.jsEvent && (t.isRecentPointerDateSelect = !0) }, this.onDocumentPointerDown = function (e) { var n = t.context.options.unselectCancel, r = _e(e.origEvent); t.matchesCancel = !!Se(r, n), t.matchesEvent = !!Se(r, Bs.SELECTOR) }, this.onDocumentPointerUp = function (e) { var n = t.context, r = t.documentPointer, o = n.getCurrentData(); if (!r.wasTouchScroll) { if (o.dateSelection && !t.isRecentPointerDateSelect) { var i = n.options.unselectAuto; !i || i && t.matchesCancel || n.calendarApi.unselect(e) } o.eventSelection && !t.matchesEvent && n.dispatch({ type: "UNSELECT_EVENT" }) } t.isRecentPointerDateSelect = !1 }; var n = this.documentPointer = new Ts(document); n.shouldIgnoreMove = !0, n.shouldWatchScroll = !1, n.emitter.on("pointerdown", this.onDocumentPointerDown), n.emitter.on("pointerup", this.onDocumentPointerUp), e.emitter.on("select", this.onSelect) } return e.prototype.destroy = function () { this.context.emitter.off("select", this.onSelect), this.documentPointer.destroy() }, e }(), Gs = { fixedMirrorParent: yn }, qs = { dateClick: yn, eventDragStart: yn, eventDragStop: yn, eventDrop: yn, eventResizeStart: yn, eventResizeStop: yn, eventResize: yn, drop: yn, eventReceive: yn, eventLeave: yn }, Ys = function () { function e(e, t) { var n = this; this.receivingContext = null, this.droppableEvent = null, this.suppliedDragMeta = null, this.dragMeta = null, this.handleDragStart = function (e) { n.dragMeta = n.buildDragMeta(e.subjectEl) }, this.handleHitUpdate = function (e, t, o) { var i = n.hitDragging.dragging, a = null, s = null, l = !1, u = { affectedEvents: { defs: {}, instances: {} }, mutatedEvents: { defs: {}, instances: {} }, isEvent: n.dragMeta.create }; e && (a = e.context, n.canDropElOnCalendar(o.subjectEl, a) && (s = function (e, t, n) { for (var o = r({}, t.leftoverProps), i = 0, a = n.pluginHooks.externalDefTransforms; i < a.length; i++) { var s = a[i]; r(o, s(e, t)) } var l = On(o, n), u = l.refined, c = l.extra, d = Ln(u, c, t.sourceId, e.allDay, n.options.forceEventDuration || Boolean(t.duration), n), p = e.range.start; e.allDay && t.startTime && (p = n.dateEnv.add(p, t.startTime)); var f = t.duration ? n.dateEnv.add(p, t.duration) : Er(e.allDay, p, n), h = mt(d.defId, { start: p, end: f }); return { def: d, instance: h } }(e.dateSpan, n.dragMeta, a), u.mutatedEvents = Sn(s), (l = !Ia(u, e.dateProfile, a)) && (u.mutatedEvents = { defs: {}, instances: {} }, s = null))), n.displayDrag(a, u), i.setMirrorIsVisible(t || !s || !document.querySelector(".fc-event-mirror")), l ? Ue() : We(), t || (i.setMirrorNeedsRevert(!s), n.receivingContext = a, n.droppableEvent = s) }, this.handleDragEnd = function (e) { var t = n, o = t.receivingContext, i = t.droppableEvent; if (n.clearDrag(), o && i) { var a = n.hitDragging.finalHit, s = a.context.viewApi, l = n.dragMeta; if (o.emitter.trigger("drop", r(r({}, Ws(a.dateSpan, o)), { draggedEl: e.subjectEl, jsEvent: e.origEvent, view: s })), l.create) { var u = Sn(i); o.dispatch({ type: "MERGE_EVENTS", eventStore: u }), e.isTouch && o.dispatch({ type: "SELECT_EVENT", eventInstanceId: i.instance.instanceId }), o.emitter.trigger("eventReceive", { event: new xr(o, i.def, i.instance), relatedEvents: [], revert: function () { o.dispatch({ type: "REMOVE_EVENTS", eventStore: u }) }, draggedEl: e.subjectEl, view: s }) } } n.receivingContext = null, n.droppableEvent = null }; var o = this.hitDragging = new Ls(e, ra); o.requireInitial = !1, o.emitter.on("dragstart", this.handleDragStart), o.emitter.on("hitupdate", this.handleHitUpdate), o.emitter.on("dragend", this.handleDragEnd), this.suppliedDragMeta = t } return e.prototype.buildDragMeta = function (e) { return "object" == typeof this.suppliedDragMeta ? sa(this.suppliedDragMeta) : "function" == typeof this.suppliedDragMeta ? sa(this.suppliedDragMeta(e)) : sa((t = function (e, t) { var n = ia.dataAttrPrefix, r = (n ? n + "-" : "") + t; return e.getAttribute("data-" + r) || "" }(e, "event")) ? JSON.parse(t) : { create: !1 }); var t }, e.prototype.displayDrag = function (e, t) { var n = this.receivingContext; n && n !== e && n.dispatch({ type: "UNSET_EVENT_DRAG" }), e && e.dispatch({ type: "SET_EVENT_DRAG", state: t }) }, e.prototype.clearDrag = function () { this.receivingContext && this.receivingContext.dispatch({ type: "UNSET_EVENT_DRAG" }) }, e.prototype.canDropElOnCalendar = function (e, t) { var n = t.options.dropAccept; return "function" == typeof n ? n.call(t.calendarApi, e) : "string" != typeof n || !n || Boolean(be(e, n)) }, e }(); ia.dataAttrPrefix = ""; var Zs = function () { function e(e, t) { var n = this; void 0 === t && (t = {}), this.handlePointerDown = function (e) { var t = n.dragging, r = n.settings, o = r.minDistance, i = r.longPressDelay; t.minDistance = null != o ? o : e.isTouch ? 0 : cn.eventDragMinDistance, t.delay = e.isTouch ? null != i ? i : cn.longPressDelay : 0 }, this.handleDragStart = function (e) { e.isTouch && n.dragging.delay && e.subjectEl.classList.contains("fc-event") && n.dragging.mirror.getMirrorEl().classList.add("fc-event-selected") }, this.settings = t; var r = this.dragging = new Os(e); r.touchScrollAllowed = !1, null != t.itemSelector && (r.pointer.selector = t.itemSelector), null != t.appendTo && (r.mirror.parentNode = t.appendTo), r.emitter.on("pointerdown", this.handlePointerDown), r.emitter.on("dragstart", this.handleDragStart), new Ys(r, t.eventData) } return e.prototype.destroy = function () { this.dragging.destroy() }, e }(), Xs = function (e) { function t(t) { var n = e.call(this, t) || this; n.shouldIgnoreMove = !1, n.mirrorSelector = "", n.currentMirrorEl = null, n.handlePointerDown = function (e) { n.emitter.trigger("pointerdown", e), n.shouldIgnoreMove || n.emitter.trigger("dragstart", e) }, n.handlePointerMove = function (e) { n.shouldIgnoreMove || n.emitter.trigger("dragmove", e) }, n.handlePointerUp = function (e) { n.emitter.trigger("pointerup", e), n.shouldIgnoreMove || n.emitter.trigger("dragend", e) }; var r = n.pointer = new Ts(t); return r.emitter.on("pointerdown", n.handlePointerDown), r.emitter.on("pointermove", n.handlePointerMove), r.emitter.on("pointerup", n.handlePointerUp), n } return n(t, e), t.prototype.destroy = function () { this.pointer.destroy() }, t.prototype.setIgnoreMove = function (e) { this.shouldIgnoreMove = e }, t.prototype.setMirrorIsVisible = function (e) { if (e) this.currentMirrorEl && (this.currentMirrorEl.style.visibility = "", this.currentMirrorEl = null); else { var t = this.mirrorSelector ? document.querySelector(this.mirrorSelector) : null; t && (this.currentMirrorEl = t, t.style.visibility = "hidden") } }, t }(oa), Ks = function () { function e(e, t) { var n = document; e === document || e instanceof Element ? (n = e, t = t || {}) : t = e || {}; var r = this.dragging = new Xs(n); "string" == typeof t.itemSelector ? r.pointer.selector = t.itemSelector : n === document && (r.pointer.selector = "[data-event]"), "string" == typeof t.mirrorSelector && (r.mirrorSelector = t.mirrorSelector), new Ys(r, t.eventData) } return e.prototype.destroy = function () { this.dragging.destroy() }, e }(), $s = zo({ componentInteractions: [Vs, Fs, Bs, zs], calendarInteractions: [js], elementDraggingImpl: Os, optionRefiners: Gs, listenerRefiners: qs }), Js = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.headerElRef = ko(), t } return n(t, e), t.prototype.renderSimpleLayout = function (e, t) { var n = this.props, r = this.context, o = [], i = Qa(r.options); return e && o.push({ type: "header", key: "header", isSticky: i, chunk: { elRef: this.headerElRef, tableClassName: "fc-col-header", rowContent: e } }), o.push({ type: "body", key: "body", liquid: !0, chunk: { content: t } }), _o(ti, { viewSpec: r.viewSpec }, (function (e, t) { return _o("div", { ref: e, className: ["fc-daygrid"].concat(t).join(" ") }, _o(ts, { liquid: !n.isHeightAuto && !n.forPrint, collapsibleWidth: n.forPrint, cols: [], sections: o })) })) }, t.prototype.renderHScrollLayout = function (e, t, n, r) { var o = this.context.pluginHooks.scrollGridImpl; if (!o) throw new Error("No ScrollGrid implementation"); var i = this.props, a = this.context, s = !i.forPrint && Qa(a.options), l = !i.forPrint && es(a.options), u = []; return e && u.push({ type: "header", key: "header", isSticky: s, chunks: [{ key: "main", elRef: this.headerElRef, tableClassName: "fc-col-header", rowContent: e }] }), u.push({ type: "body", key: "body", liquid: !0, chunks: [{ key: "main", content: t }] }), l && u.push({ type: "footer", key: "footer", isSticky: !0, chunks: [{ key: "main", content: Ja }] }), _o(ti, { viewSpec: a.viewSpec }, (function (e, t) { return _o("div", { ref: e, className: ["fc-daygrid"].concat(t).join(" ") }, _o(o, { liquid: !i.isHeightAuto && !i.forPrint, collapsibleWidth: i.forPrint, colGroups: [{ cols: [{ span: n, minWidth: r }] }], sections: u })) })) }, t }(Bo); function Qs(e, t) { for (var n = [], r = 0; r < t; r += 1)n[r] = []; for (var o = 0, i = e; o < i.length; o++) { var a = i[o]; n[a.row].push(a) } return n } function el(e, t) { for (var n = [], r = 0; r < t; r += 1)n[r] = []; for (var o = 0, i = e; o < i.length; o++) { var a = i[o]; n[a.firstCol].push(a) } return n } function tl(e, t) { var n = []; if (e) { for (a = 0; a < t; a += 1)n[a] = { affectedInstances: e.affectedInstances, isEvent: e.isEvent, segs: [] }; for (var r = 0, o = e.segs; r < o.length; r++) { var i = o[r]; n[i.row].segs.push(i) } } else for (var a = 0; a < t; a += 1)n[a] = null; return n } var nl = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e = this.props, t = so(this.context, e.date); return _o(ss, { date: e.date, dateProfile: e.dateProfile, todayRange: e.todayRange, showDayNumber: e.showDayNumber, extraHookProps: e.extraHookProps, defaultContent: rl }, (function (n, o) { return (o || e.forceDayTop) && _o("div", { className: "fc-daygrid-day-top", ref: n }, _o("a", r({ id: e.dayNumberId, className: "fc-daygrid-day-number" }, t), o || _o(xo, null, " "))) })) }, t }(Uo); function rl(e) { return e.dayNumberText } var ol = ln({ hour: "numeric", minute: "2-digit", omitZeroMinute: !0, meridiem: "narrow" }); function il(e) { var t = e.eventRange.ui.display; return "list-item" === t || "auto" === t && !e.eventRange.def.allDay && e.firstCol === e.lastCol && e.isStart && e.isEnd } var al = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e = this.props; return _o(rs, r({}, e, { extraClassNames: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"], defaultTimeFormat: ol, defaultDisplayEventEnd: e.defaultDisplayEventEnd, disableResizing: !e.seg.eventRange.def.allDay })) }, t }(Uo), sl = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.context, n = t.options.eventTimeFormat || ol, o = ar(e.seg, n, t, !0, e.defaultDisplayEventEnd); return _o(ns, { seg: e.seg, timeText: o, defaultContent: ll, isDragging: e.isDragging, isResizing: !1, isDateSelecting: !1, isSelected: e.isSelected, isPast: e.isPast, isFuture: e.isFuture, isToday: e.isToday }, (function (n, o, i, a) { return _o("a", r({ className: ["fc-daygrid-event", "fc-daygrid-dot-event"].concat(o).join(" "), ref: n }, cr(e.seg, t)), a) })) }, t }(Uo); function ll(e) { return _o(xo, null, _o("div", { className: "fc-daygrid-event-dot", style: { borderColor: e.borderColor || e.backgroundColor } }), e.timeText && _o("div", { className: "fc-event-time" }, e.timeText), _o("div", { className: "fc-event-title" }, e.event.title || _o(xo, null, " "))) } var ul = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.compileSegs = qt(cl), t } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.compileSegs(e.singlePlacements), n = t.allSegs, o = t.invisibleSegs; return _o(ms, { dateProfile: e.dateProfile, todayRange: e.todayRange, allDayDate: e.allDayDate, moreCnt: e.moreCnt, allSegs: n, hiddenSegs: o, alignmentElRef: e.alignmentElRef, alignGridTop: e.alignGridTop, extraDateSpan: e.extraDateSpan, popoverContent: function () { var t = (e.eventDrag ? e.eventDrag.affectedInstances : null) || (e.eventResize ? e.eventResize.affectedInstances : null) || {}; return _o(xo, null, n.map((function (n) { var o = n.eventRange.instance.instanceId; return _o("div", { className: "fc-daygrid-event-harness", key: o, style: { visibility: t[o] ? "hidden" : "" } }, il(n) ? _o(sl, r({ seg: n, isDragging: !1, isSelected: o === e.eventSelection, defaultDisplayEventEnd: !1 }, sr(n, e.todayRange))) : _o(al, r({ seg: n, isDragging: !1, isResizing: !1, isDateSelecting: !1, isSelected: o === e.eventSelection, defaultDisplayEventEnd: !1 }, sr(n, e.todayRange)))) }))) } }, (function (e, t, n, o, i, a, s, l) { return _o("a", r({ ref: e, className: ["fc-daygrid-more-link"].concat(t).join(" "), title: a, "aria-expanded": s, "aria-controls": l }, He(i)), o) })) }, t }(Uo); function cl(e) { for (var t = [], n = [], r = 0, o = e; r < o.length; r++) { var i = o[r]; t.push(i.seg), i.isVisible || n.push(i.seg) } return { allSegs: t, invisibleSegs: n } } var dl = ln({ week: "narrow" }), pl = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.rootElRef = ko(), t.state = { dayNumberId: xe() }, t.handleRootEl = function (e) { Fo(t.rootElRef, e), Fo(t.props.elRef, e) }, t } return n(t, e), t.prototype.render = function () { var e = this, t = e.context, n = e.props, o = e.state, i = e.rootElRef, a = n.date, s = n.dateProfile, l = so(t, a, "week"); return _o(us, { date: a, dateProfile: s, todayRange: n.todayRange, showDayNumber: n.showDayNumber, extraHookProps: n.extraHookProps, elRef: this.handleRootEl }, (function (e, t, u, c) { return _o("td", r({ ref: e, role: "gridcell", className: ["fc-daygrid-day"].concat(t, n.extraClassNames || []).join(" ") }, u, n.extraDataAttrs, n.showDayNumber ? { "aria-labelledby": o.dayNumberId } : {}), _o("div", { className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner", ref: n.innerElRef }, n.showWeekNumber && _o(fs, { date: a, defaultFormat: dl }, (function (e, t, n, o) { return _o("a", r({ ref: e, className: ["fc-daygrid-week-number"].concat(t).join(" ") }, l), o) })), !c && _o(nl, { date: a, dateProfile: s, showDayNumber: n.showDayNumber, dayNumberId: o.dayNumberId, forceDayTop: n.forceDayTop, todayRange: n.todayRange, extraHookProps: n.extraHookProps }), _o("div", { className: "fc-daygrid-day-events", ref: n.fgContentElRef }, n.fgContent, _o("div", { className: "fc-daygrid-day-bottom", style: { marginTop: n.moreMarginTop } }, _o(ul, { allDayDate: a, singlePlacements: n.singlePlacements, moreCnt: n.moreCnt, alignmentElRef: i, alignGridTop: !n.showDayNumber, extraDateSpan: n.extraDateSpan, dateProfile: n.dateProfile, eventSelection: n.eventSelection, eventDrag: n.eventDrag, eventResize: n.eventResize, todayRange: n.todayRange }))), _o("div", { className: "fc-daygrid-day-bg" }, n.bgContent))) })) }, t }(Bo); function fl(e, t, n, r, o, i, a) { var s = new vl; s.allowReslicing = !0, s.strictOrder = r, !0 === t || !0 === n ? (s.maxCoord = i, s.hiddenConsumes = !0) : "number" == typeof t ? s.maxStackCnt = t : "number" == typeof n && (s.maxStackCnt = n, s.hiddenConsumes = !0); for (var l = [], u = [], c = 0; c < e.length; c += 1) { var d = o[(R = e[c]).eventRange.instance.instanceId]; null != d ? l.push({ index: c, thickness: d, span: { start: R.firstCol, end: R.lastCol + 1 } }) : u.push(R) } for (var p = s.addSegs(l), f = function (e, t, n) { for (var r = function (e, t) { for (var n = [], r = 0; r < t; r += 1)n.push([]); for (var o = 0, i = e; o < i.length; o++) { var a = i[o]; for (r = a.span.start; r < a.span.end; r += 1)n[r].push(a) } return n }(e, n.length), o = [], i = [], a = [], s = 0; s < n.length; s += 1) { for (var l = r[s], u = [], c = 0, d = 0, p = 0, f = l; p < f.length; p++) { var h = t[(y = f[p]).index]; u.push({ seg: hl(h, s, s + 1, n), isVisible: !0, isAbsolute: !1, absoluteTop: y.levelCoord, marginTop: y.levelCoord - c }), c = y.levelCoord + y.thickness } var v = []; c = 0, d = 0; for (var g = 0, m = l; g < m.length; g++) { h = t[(y = m[g]).index]; var y, E = y.span.end - y.span.start > 1, S = y.span.start === s; d += y.levelCoord - c, c = y.levelCoord + y.thickness, E ? (d += y.thickness, S && v.push({ seg: hl(h, y.span.start, y.span.end, n), isVisible: !0, isAbsolute: !0, absoluteTop: y.levelCoord, marginTop: 0 })) : S && (v.push({ seg: hl(h, y.span.start, y.span.end, n), isVisible: !0, isAbsolute: !1, absoluteTop: y.levelCoord, marginTop: d }), d = 0) } o.push(u), i.push(v), a.push(d) } return { singleColPlacements: o, multiColPlacements: i, leftoverMargins: a } }(s.toRects(), e, a), h = f.singleColPlacements, v = f.multiColPlacements, g = f.leftoverMargins, m = [], y = [], E = 0, S = u; E < S.length; E++) { v[(R = S[E]).firstCol].push({ seg: R, isVisible: !1, isAbsolute: !0, absoluteTop: 0, marginTop: 0 }); for (var b = R.firstCol; b <= R.lastCol; b += 1)h[b].push({ seg: hl(R, b, b + 1, a), isVisible: !1, isAbsolute: !1, absoluteTop: 0, marginTop: 0 }) } for (b = 0; b < a.length; b += 1)m.push(0); for (var D = 0, C = p; D < C.length; D++) { var w = C[D], R = e[w.index], _ = w.span; v[_.start].push({ seg: hl(R, _.start, _.end, a), isVisible: !1, isAbsolute: !0, absoluteTop: 0, marginTop: 0 }); for (b = _.start; b < _.end; b += 1)m[b] += 1, h[b].push({ seg: hl(R, b, b + 1, a), isVisible: !1, isAbsolute: !1, absoluteTop: 0, marginTop: 0 }) } for (b = 0; b < a.length; b += 1)y.push(g[b]); return { singleColPlacements: h, multiColPlacements: v, moreCnts: m, moreMarginTops: y } } function hl(e, t, n, o) { if (e.firstCol === t && e.lastCol === n - 1) return e; var i = e.eventRange, a = i.range, s = jn(a, { start: o[t].date, end: tt(o[n - 1].date, 1) }); return r(r({}, e), { firstCol: t, lastCol: n - 1, eventRange: { def: i.def, ui: r(r({}, i.ui), { durationEditable: !1 }), instance: i.instance, range: s }, isStart: e.isStart && s.start.valueOf() === a.start.valueOf(), isEnd: e.isEnd && s.end.valueOf() === a.end.valueOf() }) } var vl = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.hiddenConsumes = !1, t.forceHidden = {}, t } return n(t, e), t.prototype.addSegs = function (t) { for (var n = this, r = e.prototype.addSegs.call(this, t), o = this.entriesByLevel, i = function (e) { return !n.forceHidden[Zi(e)] }, a = 0; a < o.length; a += 1)o[a] = o[a].filter(i); return r }, t.prototype.handleInvalidInsertion = function (t, n, o) { var i = this.entriesByLevel, a = this.forceHidden, s = t.touchingEntry, l = t.touchingLevel, u = t.touchingLateral; if (this.hiddenConsumes && s) { var c = Zi(s); if (!a[c]) if (this.allowReslicing) { var d = r(r({}, s), { span: $i(s.span, n.span) }); a[Zi(d)] = !0, i[l][u] = d, this.splitEntry(s, n, o) } else a[c] = !0, o.push(s) } return e.prototype.handleInvalidInsertion.call(this, t, n, o) }, t }(qi), gl = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.cellElRefs = new Fa, t.frameElRefs = new Fa, t.fgElRefs = new Fa, t.segHarnessRefs = new Fa, t.rootElRef = ko(), t.state = { framePositions: null, maxContentHeight: null, eventInstanceHeights: {} }, t } return n(t, e), t.prototype.render = function () { var e = this, t = this, n = t.props, r = t.state, o = t.context.options, i = n.cells.length, a = el(n.businessHourSegs, i), s = el(n.bgEventSegs, i), l = el(this.getHighlightSegs(), i), u = el(this.getMirrorSegs(), i), c = fl(tr(n.fgEventSegs, o.eventOrder), n.dayMaxEvents, n.dayMaxEventRows, o.eventOrderStrict, r.eventInstanceHeights, r.maxContentHeight, n.cells), d = c.singleColPlacements, p = c.multiColPlacements, f = c.moreCnts, h = c.moreMarginTops, v = n.eventDrag && n.eventDrag.affectedInstances || n.eventResize && n.eventResize.affectedInstances || {}; return _o("tr", { ref: this.rootElRef, role: "row" }, n.renderIntro && n.renderIntro(), n.cells.map((function (t, r) { var o = e.renderFgSegs(r, n.forPrint ? d[r] : p[r], n.todayRange, v), i = e.renderFgSegs(r, function (e, t) { if (!e.length) return []; var n = function (e) { for (var t = {}, n = 0, r = e; n < r.length; n++)for (var o = 0, i = r[n]; o < i.length; o++) { var a = i[o]; t[a.seg.eventRange.instance.instanceId] = a.absoluteTop } return t }(t); return e.map((function (e) { return { seg: e, isVisible: !0, isAbsolute: !0, absoluteTop: n[e.eventRange.instance.instanceId], marginTop: 0 } })) }(u[r], p), n.todayRange, {}, Boolean(n.eventDrag), Boolean(n.eventResize), !1); return _o(pl, { key: t.key, elRef: e.cellElRefs.createRef(t.key), innerElRef: e.frameElRefs.createRef(t.key), dateProfile: n.dateProfile, date: t.date, showDayNumber: n.showDayNumbers, showWeekNumber: n.showWeekNumbers && 0 === r, forceDayTop: n.showWeekNumbers, todayRange: n.todayRange, eventSelection: n.eventSelection, eventDrag: n.eventDrag, eventResize: n.eventResize, extraHookProps: t.extraHookProps, extraDataAttrs: t.extraDataAttrs, extraClassNames: t.extraClassNames, extraDateSpan: t.extraDateSpan, moreCnt: f[r], moreMarginTop: h[r], singlePlacements: d[r], fgContentElRef: e.fgElRefs.createRef(t.key), fgContent: _o(xo, null, _o(xo, null, o), _o(xo, null, i)), bgContent: _o(xo, null, e.renderFillSegs(l[r], "highlight"), e.renderFillSegs(a[r], "non-business"), e.renderFillSegs(s[r], "bg-event")) }) }))) }, t.prototype.componentDidMount = function () { this.updateSizing(!0) }, t.prototype.componentDidUpdate = function (e, t) { var n = this.props; this.updateSizing(!wt(e, n)) }, t.prototype.getHighlightSegs = function () { var e = this.props; return e.eventDrag && e.eventDrag.segs.length ? e.eventDrag.segs : e.eventResize && e.eventResize.segs.length ? e.eventResize.segs : e.dateSelectionSegs }, t.prototype.getMirrorSegs = function () { var e = this.props; return e.eventResize && e.eventResize.segs.length ? e.eventResize.segs : [] }, t.prototype.renderFgSegs = function (e, t, n, o, i, a, s) { var l = this.context, u = this.props.eventSelection, c = this.state.framePositions, d = 1 === this.props.cells.length, p = i || a || s, f = []; if (c) for (var h = 0, v = t; h < v.length; h++) { var g = v[h], m = g.seg, y = m.eventRange.instance.instanceId, E = y + ":" + e, S = g.isVisible && !o[y], b = g.isAbsolute, D = "", C = ""; b && (l.isRtl ? (C = 0, D = c.lefts[m.lastCol] - c.lefts[m.firstCol]) : (D = 0, C = c.rights[m.firstCol] - c.rights[m.lastCol])), f.push(_o("div", { className: "fc-daygrid-event-harness" + (b ? " fc-daygrid-event-harness-abs" : ""), key: E, ref: p ? null : this.segHarnessRefs.createRef(E), style: { visibility: S ? "" : "hidden", marginTop: b ? "" : g.marginTop, top: b ? g.absoluteTop : "", left: D, right: C } }, il(m) ? _o(sl, r({ seg: m, isDragging: i, isSelected: y === u, defaultDisplayEventEnd: d }, sr(m, n))) : _o(al, r({ seg: m, isDragging: i, isResizing: a, isDateSelecting: s, isSelected: y === u, defaultDisplayEventEnd: d }, sr(m, n))))) } return f }, t.prototype.renderFillSegs = function (e, t) { var n = this.context.isRtl, i = this.props.todayRange, a = this.state.framePositions, s = []; if (a) for (var l = 0, u = e; l < u.length; l++) { var c = u[l], d = n ? { right: 0, left: a.lefts[c.lastCol] - a.lefts[c.firstCol] } : { left: 0, right: a.rights[c.firstCol] - a.rights[c.lastCol] }; s.push(_o("div", { key: ur(c.eventRange), className: "fc-daygrid-bg-harness", style: d }, "bg-event" === t ? _o(ds, r({ seg: c }, sr(c, i))) : cs(t))) } return _o.apply(void 0, o([xo, {}], s)) }, t.prototype.updateSizing = function (e) { var t = this.props, n = this.frameElRefs; if (!t.forPrint && null !== t.clientWidth) { if (e) { var o = t.cells.map((function (e) { return n.currentMap[e.key] })); if (o.length) { var i = this.rootElRef.current; this.setState({ framePositions: new So(i, o, !0, !1) }) } } var a = this.state.eventInstanceHeights, s = this.queryEventInstanceHeights(), l = !0 === t.dayMaxEvents || !0 === t.dayMaxEventRows; this.setState({ eventInstanceHeights: r(r({}, a), s), maxContentHeight: l ? this.computeMaxContentHeight() : null }) } }, t.prototype.queryEventInstanceHeights = function () { var e = this.segHarnessRefs.currentMap, t = {}; for (var n in e) { var r = Math.round(e[n].getBoundingClientRect().height), o = n.split(":")[0]; t[o] = Math.max(t[o] || 0, r) } return t }, t.prototype.computeMaxContentHeight = function () { var e = this.props.cells[0].key, t = this.cellElRefs.currentMap[e], n = this.fgElRefs.currentMap[e]; return t.getBoundingClientRect().bottom - n.getBoundingClientRect().top }, t.prototype.getCellEls = function () { var e = this.cellElRefs.currentMap; return this.props.cells.map((function (t) { return e[t.key] })) }, t }(Bo); gl.addStateEquality({ eventInstanceHeights: wt }); var ml = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.splitBusinessHourSegs = qt(Qs), t.splitBgEventSegs = qt(Qs), t.splitFgEventSegs = qt(Qs), t.splitDateSelectionSegs = qt(Qs), t.splitEventDrag = qt(tl), t.splitEventResize = qt(tl), t.rowRefs = new Fa, t.handleRootEl = function (e) { t.rootEl = e, e ? t.context.registerInteractiveComponent(t, { el: e, isHitComboAllowed: t.props.isHitComboAllowed }) : t.context.unregisterInteractiveComponent(t) }, t } return n(t, e), t.prototype.render = function () { var e = this, t = this.props, n = t.dateProfile, r = t.dayMaxEventRows, o = t.dayMaxEvents, i = t.expandRows, a = t.cells.length, s = this.splitBusinessHourSegs(t.businessHourSegs, a), l = this.splitBgEventSegs(t.bgEventSegs, a), u = this.splitFgEventSegs(t.fgEventSegs, a), c = this.splitDateSelectionSegs(t.dateSelectionSegs, a), d = this.splitEventDrag(t.eventDrag, a), p = this.splitEventResize(t.eventResize, a), f = !0 === o || !0 === r; return f && !i && (f = !1, r = null, o = null), _o("div", { className: ["fc-daygrid-body", f ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced", i ? "" : "fc-daygrid-body-natural"].join(" "), ref: this.handleRootEl, style: { width: t.clientWidth, minWidth: t.tableMinWidth } }, _o(Ca, { unit: "day" }, (function (f, h) { return _o(xo, null, _o("table", { role: "presentation", className: "fc-scrollgrid-sync-table", style: { width: t.clientWidth, minWidth: t.tableMinWidth, height: i ? t.clientHeight : "" } }, t.colGroupNode, _o("tbody", { role: "presentation" }, t.cells.map((function (i, f) { return _o(gl, { ref: e.rowRefs.createRef(f), key: i.length ? i[0].date.toISOString() : f, showDayNumbers: a > 1, showWeekNumbers: t.showWeekNumbers, todayRange: h, dateProfile: n, cells: i, renderIntro: t.renderRowIntro, businessHourSegs: s[f], eventSelection: t.eventSelection, bgEventSegs: l[f].filter(yl), fgEventSegs: u[f], dateSelectionSegs: c[f], eventDrag: d[f], eventResize: p[f], dayMaxEvents: o, dayMaxEventRows: r, clientWidth: t.clientWidth, clientHeight: t.clientHeight, forPrint: t.forPrint }) }))))) }))) }, t.prototype.prepareHits = function () { this.rowPositions = new So(this.rootEl, this.rowRefs.collect().map((function (e) { return e.getCellEls()[0] })), !1, !0), this.colPositions = new So(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), !0, !1) }, t.prototype.queryHit = function (e, t) { var n = this.colPositions, o = this.rowPositions, i = n.leftToIndex(e), a = o.topToIndex(t); if (null != a && null != i) { var s = this.props.cells[a][i]; return { dateProfile: this.props.dateProfile, dateSpan: r({ range: this.getCellRange(a, i), allDay: !0 }, s.extraDateSpan), dayEl: this.getCellEl(a, i), rect: { left: n.lefts[i], right: n.rights[i], top: o.tops[a], bottom: o.bottoms[a] }, layer: 0 } } return null }, t.prototype.getCellEl = function (e, t) { return this.rowRefs.currentMap[e].getCellEls()[t] }, t.prototype.getCellRange = function (e, t) { var n = this.props.cells[e][t].date; return { start: n, end: tt(n, 1) } }, t }(Bo); function yl(e) { return e.eventRange.def.allDay } var El = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.forceDayIfListItem = !0, t } return n(t, e), t.prototype.sliceRange = function (e, t) { return t.sliceRange(e) }, t }(xa), Sl = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.slicer = new El, t.tableRef = ko(), t } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.context; return _o(ml, r({ ref: this.tableRef }, this.slicer.sliceProps(e, e.dateProfile, e.nextDayThreshold, t, e.dayTableModel), { dateProfile: e.dateProfile, cells: e.dayTableModel.cells, colGroupNode: e.colGroupNode, tableMinWidth: e.tableMinWidth, renderRowIntro: e.renderRowIntro, dayMaxEvents: e.dayMaxEvents, dayMaxEventRows: e.dayMaxEventRows, showWeekNumbers: e.showWeekNumbers, expandRows: e.expandRows, headerAlignElRef: e.headerAlignElRef, clientWidth: e.clientWidth, clientHeight: e.clientHeight, forPrint: e.forPrint })) }, t }(Bo), bl = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.buildDayTableModel = qt(Dl), t.headerRef = ko(), t.tableRef = ko(), t } return n(t, e), t.prototype.render = function () { var e = this, t = this.context, n = t.options, r = t.dateProfileGenerator, o = this.props, i = this.buildDayTableModel(o.dateProfile, r), a = n.dayHeaders && _o(Ra, { ref: this.headerRef, dateProfile: o.dateProfile, dates: i.headerDates, datesRepDistinctDays: 1 === i.rowCnt }), s = function (t) { return _o(Sl, { ref: e.tableRef, dateProfile: o.dateProfile, dayTableModel: i, businessHours: o.businessHours, dateSelection: o.dateSelection, eventStore: o.eventStore, eventUiBases: o.eventUiBases, eventSelection: o.eventSelection, eventDrag: o.eventDrag, eventResize: o.eventResize, nextDayThreshold: n.nextDayThreshold, colGroupNode: t.tableColGroupNode, tableMinWidth: t.tableMinWidth, dayMaxEvents: n.dayMaxEvents, dayMaxEventRows: n.dayMaxEventRows, showWeekNumbers: n.weekNumbers, expandRows: !o.isHeightAuto, headerAlignElRef: e.headerElRef, clientWidth: t.clientWidth, clientHeight: t.clientHeight, forPrint: o.forPrint }) }; return n.dayMinWidth ? this.renderHScrollLayout(a, s, i.colCnt, n.dayMinWidth) : this.renderSimpleLayout(a, s) }, t }(Js); function Dl(e, t) { var n = new Ta(e.renderRange, t); return new ka(n, /year|month|week/.test(e.currentRangeUnit)) } var Cl = zo({ initialView: "dayGridMonth", views: { dayGrid: { component: bl, dateProfileGeneratorClass: function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.buildRenderRange = function (t, n, r) { var o, i = this.props.dateEnv, a = e.prototype.buildRenderRange.call(this, t, n, r), s = a.start, l = a.end; (/^(year|month)$/.test(n) && (s = i.startOfWeek(s), (o = i.startOfWeek(l)).valueOf() !== l.valueOf() && (l = et(o, 1))), this.props.monthMode && this.props.fixedWeekCount) && (l = et(l, 6 - Math.ceil(rt(s, l)))); return { start: s, end: l } }, t }(ai) }, dayGridDay: { type: "dayGrid", duration: { days: 1 } }, dayGridWeek: { type: "dayGrid", duration: { weeks: 1 } }, dayGridMonth: { type: "dayGrid", duration: { months: 1 }, monthMode: !0, fixedWeekCount: !0 } } }), wl = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.getKeyInfo = function () { return { allDay: {}, timed: {} } }, t.prototype.getKeysForDateSpan = function (e) { return e.allDay ? ["allDay"] : ["timed"] }, t.prototype.getKeysForEventDef = function (e) { return e.allDay ? Kn(e) ? ["timed", "allDay"] : ["allDay"] : ["timed"] }, t }(to), Rl = ln({ hour: "numeric", minute: "2-digit", omitZeroMinute: !0, meridiem: "short" }); function _l(e) { var t = ["fc-timegrid-slot", "fc-timegrid-slot-label", e.isLabeled ? "fc-scrollgrid-shrink" : "fc-timegrid-slot-minor"]; return _o(Oo.Consumer, null, (function (n) { if (!e.isLabeled) return _o("td", { className: t.join(" "), "data-time": e.isoTimeStr }); var r = n.dateEnv, o = n.options, i = n.viewApi, a = null == o.slotLabelFormat ? Rl : Array.isArray(o.slotLabelFormat) ? ln(o.slotLabelFormat[0]) : ln(o.slotLabelFormat), s = { level: 0, time: e.time, date: r.toDate(e.date), view: i, text: r.format(e.date, a) }; return _o(Yo, { hookProps: s, classNames: o.slotLabelClassNames, content: o.slotLabelContent, defaultContent: Tl, didMount: o.slotLabelDidMount, willUnmount: o.slotLabelWillUnmount }, (function (n, r, o, i) { return _o("td", { ref: n, className: t.concat(r).join(" "), "data-time": e.isoTimeStr }, _o("div", { className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame" }, _o("div", { className: "fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion", ref: o }, i))) })) })) } function Tl(e) { return e.text } var kl = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { return this.props.slatMetas.map((function (e) { return _o("tr", { key: e.key }, _o(_l, r({}, e))) })) }, t }(Uo), xl = ln({ week: "short" }), Ml = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.allDaySplitter = new wl, t.headerElRef = ko(), t.rootElRef = ko(), t.scrollerElRef = ko(), t.state = { slatCoords: null }, t.handleScrollTopRequest = function (e) { var n = t.scrollerElRef.current; n && (n.scrollTop = e) }, t.renderHeadAxis = function (e, n) { void 0 === n && (n = ""); var o = t.context.options, i = t.props.dateProfile.renderRange, a = 1 === ot(i.start, i.end) ? so(t.context, i.start, "week") : {}; return o.weekNumbers && "day" === e ? _o(fs, { date: i.start, defaultFormat: xl }, (function (e, t, o, i) { return _o("th", { ref: e, "aria-hidden": !0, className: ["fc-timegrid-axis", "fc-scrollgrid-shrink"].concat(t).join(" ") }, _o("div", { className: "fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid", style: { height: n } }, _o("a", r({ ref: o, className: "fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner" }, a), i))) })) : _o("th", { "aria-hidden": !0, className: "fc-timegrid-axis" }, _o("div", { className: "fc-timegrid-axis-frame", style: { height: n } })) }, t.renderTableRowAxis = function (e) { var n = t.context, r = n.options, o = n.viewApi, i = { text: r.allDayText, view: o }; return _o(Yo, { hookProps: i, classNames: r.allDayClassNames, content: r.allDayContent, defaultContent: Il, didMount: r.allDayDidMount, willUnmount: r.allDayWillUnmount }, (function (t, n, r, o) { return _o("td", { ref: t, "aria-hidden": !0, className: ["fc-timegrid-axis", "fc-scrollgrid-shrink"].concat(n).join(" ") }, _o("div", { className: "fc-timegrid-axis-frame fc-scrollgrid-shrink-frame" + (null == e ? " fc-timegrid-axis-frame-liquid" : ""), style: { height: e } }, _o("span", { className: "fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner", ref: r }, o))) })) }, t.handleSlatCoords = function (e) { t.setState({ slatCoords: e }) }, t } return n(t, e), t.prototype.renderSimpleLayout = function (e, t, n) { var r = this.context, o = this.props, i = [], a = Qa(r.options); return e && i.push({ type: "header", key: "header", isSticky: a, chunk: { elRef: this.headerElRef, tableClassName: "fc-col-header", rowContent: e } }), t && (i.push({ type: "body", key: "all-day", chunk: { content: t } }), i.push({ type: "body", key: "all-day-divider", outerContent: _o("tr", { role: "presentation", className: "fc-scrollgrid-section" }, _o("td", { className: "fc-timegrid-divider " + r.theme.getClass("tableCellShaded") })) })), i.push({ type: "body", key: "body", liquid: !0, expandRows: Boolean(r.options.expandRows), chunk: { scrollerElRef: this.scrollerElRef, content: n } }), _o(ti, { viewSpec: r.viewSpec, elRef: this.rootElRef }, (function (e, t) { return _o("div", { className: ["fc-timegrid"].concat(t).join(" "), ref: e }, _o(ts, { liquid: !o.isHeightAuto && !o.forPrint, collapsibleWidth: o.forPrint, cols: [{ width: "shrink" }], sections: i })) })) }, t.prototype.renderHScrollLayout = function (e, t, n, r, o, i, a) { var s = this, l = this.context.pluginHooks.scrollGridImpl; if (!l) throw new Error("No ScrollGrid implementation"); var u = this.context, c = this.props, d = !c.forPrint && Qa(u.options), p = !c.forPrint && es(u.options), f = []; e && f.push({ type: "header", key: "header", isSticky: d, syncRowHeights: !0, chunks: [{ key: "axis", rowContent: function (e) { return _o("tr", { role: "presentation" }, s.renderHeadAxis("day", e.rowSyncHeights[0])) } }, { key: "cols", elRef: this.headerElRef, tableClassName: "fc-col-header", rowContent: e }] }), t && (f.push({ type: "body", key: "all-day", syncRowHeights: !0, chunks: [{ key: "axis", rowContent: function (e) { return _o("tr", { role: "presentation" }, s.renderTableRowAxis(e.rowSyncHeights[0])) } }, { key: "cols", content: t }] }), f.push({ key: "all-day-divider", type: "body", outerContent: _o("tr", { role: "presentation", className: "fc-scrollgrid-section" }, _o("td", { colSpan: 2, className: "fc-timegrid-divider " + u.theme.getClass("tableCellShaded") })) })); var h = u.options.nowIndicator; return f.push({ type: "body", key: "body", liquid: !0, expandRows: Boolean(u.options.expandRows), chunks: [{ key: "axis", content: function (e) { return _o("div", { className: "fc-timegrid-axis-chunk" }, _o("table", { "aria-hidden": !0, style: { height: e.expandRows ? e.clientHeight : "" } }, e.tableColGroupNode, _o("tbody", null, _o(kl, { slatMetas: i }))), _o("div", { className: "fc-timegrid-now-indicator-container" }, _o(Ca, { unit: h ? "minute" : "day" }, (function (e) { var t = h && a && a.safeComputeTop(e); return "number" == typeof t ? _o(is, { isAxis: !0, date: e }, (function (e, n, r, o) { return _o("div", { ref: e, className: ["fc-timegrid-now-indicator-arrow"].concat(n).join(" "), style: { top: t } }, o) })) : null })))) } }, { key: "cols", scrollerElRef: this.scrollerElRef, content: n }] }), p && f.push({ key: "footer", type: "footer", isSticky: !0, chunks: [{ key: "axis", content: Ja }, { key: "cols", content: Ja }] }), _o(ti, { viewSpec: u.viewSpec, elRef: this.rootElRef }, (function (e, t) { return _o("div", { className: ["fc-timegrid"].concat(t).join(" "), ref: e }, _o(l, { liquid: !c.isHeightAuto && !c.forPrint, collapsibleWidth: !1, colGroups: [{ width: "shrink", cols: [{ width: "shrink" }] }, { cols: [{ span: r, minWidth: o }] }], sections: f })) })) }, t.prototype.getAllDayMaxEventProps = function () { var e = this.context.options, t = e.dayMaxEvents, n = e.dayMaxEventRows; return !0 !== t && !0 !== n || (t = void 0, n = 5), { dayMaxEvents: t, dayMaxEventRows: n } }, t }(Bo); function Il(e) { return e.text } var Pl = function () { function e(e, t, n) { this.positions = e, this.dateProfile = t, this.slotDuration = n } return e.prototype.safeComputeTop = function (e) { var t = this.dateProfile; if (Zn(t.currentRange, e)) { var n = lt(e), r = e.valueOf() - n.valueOf(); if (r >= Ut(t.slotMinTime) && r < Ut(t.slotMaxTime)) return this.computeTimeTop(Nt(r)) } return null }, e.prototype.computeDateTop = function (e, t) { return t || (t = lt(e)), this.computeTimeTop(Nt(e.valueOf() - t.valueOf())) }, e.prototype.computeTimeTop = function (e) { var t, n, r = this.positions, o = this.dateProfile, i = r.els.length, a = (e.milliseconds - Ut(o.slotMinTime)) / Ut(this.slotDuration); return a = Math.max(0, a), a = Math.min(i, a), t = Math.floor(a), n = a - (t = Math.min(t, i - 1)), r.tops[t] + r.getHeight(t) * n }, e }(), Nl = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.context, n = t.options, o = e.slatElRefs; return _o("tbody", null, e.slatMetas.map((function (i, a) { var s = { time: i.time, date: t.dateEnv.toDate(i.date), view: t.viewApi }, l = ["fc-timegrid-slot", "fc-timegrid-slot-lane", i.isLabeled ? "" : "fc-timegrid-slot-minor"]; return _o("tr", { key: i.key, ref: o.createRef(i.key) }, e.axis && _o(_l, r({}, i)), _o(Yo, { hookProps: s, classNames: n.slotLaneClassNames, content: n.slotLaneContent, didMount: n.slotLaneDidMount, willUnmount: n.slotLaneWillUnmount }, (function (e, t, n, r) { return _o("td", { ref: e, className: l.concat(t).join(" "), "data-time": i.isoTimeStr }, r) }))) }))) }, t }(Uo), Hl = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.rootElRef = ko(), t.slatElRefs = new Fa, t } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.context; return _o("div", { ref: this.rootElRef, className: "fc-timegrid-slots" }, _o("table", { "aria-hidden": !0, className: t.theme.getClass("table"), style: { minWidth: e.tableMinWidth, width: e.clientWidth, height: e.minHeight } }, e.tableColGroupNode, _o(Nl, { slatElRefs: this.slatElRefs, axis: e.axis, slatMetas: e.slatMetas }))) }, t.prototype.componentDidMount = function () { this.updateSizing() }, t.prototype.componentDidUpdate = function () { this.updateSizing() }, t.prototype.componentWillUnmount = function () { this.props.onCoords && this.props.onCoords(null) }, t.prototype.updateSizing = function () { var e, t = this.context, n = this.props; n.onCoords && null !== n.clientWidth && (this.rootElRef.current.offsetHeight && n.onCoords(new Pl(new So(this.rootElRef.current, (e = this.slatElRefs.currentMap, n.slatMetas.map((function (t) { return e[t.key] }))), !1, !0), this.props.dateProfile, t.options.slotDuration))) }, t }(Uo); function Ol(e, t) { var n, r = []; for (n = 0; n < t; n += 1)r.push([]); if (e) for (n = 0; n < e.length; n += 1)r[e[n].col].push(e[n]); return r } function Al(e, t) { var n = []; if (e) { for (a = 0; a < t; a += 1)n[a] = { affectedInstances: e.affectedInstances, isEvent: e.isEvent, segs: [] }; for (var r = 0, o = e.segs; r < o.length; r++) { var i = o[r]; n[i.col].segs.push(i) } } else for (var a = 0; a < t; a += 1)n[a] = null; return n } var Ll = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.rootElRef = ko(), t } return n(t, e), t.prototype.render = function () { var e = this, t = this.props; return _o(ms, { allDayDate: null, moreCnt: t.hiddenSegs.length, allSegs: t.hiddenSegs, hiddenSegs: t.hiddenSegs, alignmentElRef: this.rootElRef, defaultContent: Ul, extraDateSpan: t.extraDateSpan, dateProfile: t.dateProfile, todayRange: t.todayRange, popoverContent: function () { return Xl(t.hiddenSegs, t) } }, (function (n, r, o, i, a, s, l, u) { return _o("a", { ref: function (t) { Fo(n, t), Fo(e.rootElRef, t) }, className: ["fc-timegrid-more-link"].concat(r).join(" "), style: { top: t.top, bottom: t.bottom }, onClick: a, title: s, "aria-expanded": l, "aria-controls": u }, _o("div", { ref: o, className: "fc-timegrid-more-link-inner fc-sticky" }, i)) })) }, t }(Uo); function Ul(e) { return e.shortText } function Wl(e, t, n) { var o = new qi; null != t && (o.strictOrder = t), null != n && (o.maxStackCnt = n); var i, a, s, l = Xi(o.addSegs(e)), u = function (e) { var t = e.entriesByLevel, n = zl((function (e, t) { return e + ":" + t }), (function (o, i) { var a = Vl(function (e, t, n) { for (var r = e.levelCoords, o = e.entriesByLevel, i = o[t][n], a = r[t] + i.thickness, s = r.length, l = t; l < s && r[l] < a; l += 1); for (; l < s; l += 1) { for (var u = o[l], c = void 0, d = Qi(u, i.span.start, Yi), p = d[0] + d[1], f = p; (c = u[f]) && c.span.start < i.span.end;)f += 1; if (p < f) return { level: l, lateralStart: p, lateralEnd: f } } return null }(e, o, i), n), s = t[o][i]; return [r(r({}, s), { nextLevelNodes: a[0] }), s.thickness + a[1]] })); return Vl(t.length ? { level: 0, lateralStart: 0, lateralEnd: t[0].length } : null, n)[0] }(o); return i = u, a = 1, s = zl((function (e, t, n) { return Zi(e) }), (function (e, t, n) { var o, i = e.nextLevelNodes, l = e.thickness, u = l + n, c = l / u, d = []; if (i.length) for (var p = 0, f = i; p < f.length; p++) { var h = f[p]; if (void 0 === o) o = (v = s(h, t, u))[0], d.push(v[1]); else { var v = s(h, o, 0); d.push(v[1]) } } else o = a; var g = (o - t) * c; return [o - g, r(r({}, e), { thickness: g, nextLevelNodes: d })] })), { segRects: function (e) { var t = [], n = zl((function (e, t, n) { return Zi(e) }), (function (e, n, i) { var a = r(r({}, e), { levelCoord: n, stackDepth: i, stackForward: 0 }); return t.push(a), a.stackForward = o(e.nextLevelNodes, n + e.thickness, i + 1) + 1 })); function o(e, t, r) { for (var o = 0, i = 0, a = e; i < a.length; i++) { var s = a[i]; o = Math.max(n(s, t, r), o) } return o } return o(e, 0, 0), t }(u = i.map((function (e) { return s(e, 0, 0)[1] }))), hiddenGroups: l } } function Vl(e, t) { if (!e) return [[], 0]; for (var n = e.level, r = e.lateralStart, o = e.lateralEnd, i = r, a = []; i < o;)a.push(t(n, i)), i += 1; return a.sort(Fl), [a.map(Bl), a[0][1]] } function Fl(e, t) { return t[1] - e[1] } function Bl(e) { return e[0] } function zl(e, t) { var n = {}; return function () { for (var r = [], o = 0; o < arguments.length; o++)r[o] = arguments[o]; var i = e.apply(void 0, r); return i in n ? n[i] : n[i] = t.apply(void 0, r) } } function jl(e, t, n, r) { void 0 === n && (n = null), void 0 === r && (r = 0); var o = []; if (n) for (var i = 0; i < e.length; i += 1) { var a = e[i], s = n.computeDateTop(a.start, t), l = Math.max(s + (r || 0), n.computeDateTop(a.end, t)); o.push({ start: Math.round(s), end: Math.round(l) }) } return o } var Gl = ln({ hour: "numeric", minute: "2-digit", meridiem: !1 }), ql = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e = ["fc-timegrid-event", "fc-v-event"]; return this.props.isShort && e.push("fc-timegrid-event-short"), _o(rs, r({}, this.props, { defaultTimeFormat: Gl, extraClassNames: e })) }, t }(Uo), Yl = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e = this.props; return _o(ss, { date: e.date, dateProfile: e.dateProfile, todayRange: e.todayRange, extraHookProps: e.extraHookProps }, (function (e, t) { return t && _o("div", { className: "fc-timegrid-col-misc", ref: e }, t) })) }, t }(Uo), Zl = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.sortEventSegs = qt(tr), t } return n(t, e), t.prototype.render = function () { var e = this, t = this.props, n = this.context, o = n.options.selectMirror, i = t.eventDrag && t.eventDrag.segs || t.eventResize && t.eventResize.segs || o && t.dateSelectionSegs || [], a = t.eventDrag && t.eventDrag.affectedInstances || t.eventResize && t.eventResize.affectedInstances || {}, s = this.sortEventSegs(t.fgEventSegs, n.options.eventOrder); return _o(us, { elRef: t.elRef, date: t.date, dateProfile: t.dateProfile, todayRange: t.todayRange, extraHookProps: t.extraHookProps }, (function (n, l, u) { return _o("td", r({ ref: n, role: "gridcell", className: ["fc-timegrid-col"].concat(l, t.extraClassNames || []).join(" ") }, u, t.extraDataAttrs), _o("div", { className: "fc-timegrid-col-frame" }, _o("div", { className: "fc-timegrid-col-bg" }, e.renderFillSegs(t.businessHourSegs, "non-business"), e.renderFillSegs(t.bgEventSegs, "bg-event"), e.renderFillSegs(t.dateSelectionSegs, "highlight")), _o("div", { className: "fc-timegrid-col-events" }, e.renderFgSegs(s, a, !1, !1, !1)), _o("div", { className: "fc-timegrid-col-events" }, e.renderFgSegs(i, {}, Boolean(t.eventDrag), Boolean(t.eventResize), Boolean(o))), _o("div", { className: "fc-timegrid-now-indicator-container" }, e.renderNowIndicator(t.nowIndicatorSegs)), _o(Yl, { date: t.date, dateProfile: t.dateProfile, todayRange: t.todayRange, extraHookProps: t.extraHookProps }))) })) }, t.prototype.renderFgSegs = function (e, t, n, r, o) { var i = this.props; return i.forPrint ? Xl(e, i) : this.renderPositionedFgSegs(e, t, n, r, o) }, t.prototype.renderPositionedFgSegs = function (e, t, n, o, i) { var a = this, s = this.context.options, l = s.eventMaxStack, u = s.eventShortHeight, c = s.eventOrderStrict, d = s.eventMinHeight, p = this.props, f = p.date, h = p.slatCoords, v = p.eventSelection, g = p.todayRange, m = p.nowDate, y = n || o || i, E = function (e, t, n, r) { for (var o = [], i = [], a = 0; a < e.length; a += 1) { var s = t[a]; s ? o.push({ index: a, thickness: 1, span: s }) : i.push(e[a]) } for (var l = Wl(o, n, r), u = l.segRects, c = l.hiddenGroups, d = [], p = 0, f = u; p < f.length; p++) { var h = f[p]; d.push({ seg: e[h.index], rect: h }) } for (var v = 0, g = i; v < g.length; v++) { var m = g[v]; d.push({ seg: m, rect: null }) } return { segPlacements: d, hiddenGroups: c } }(e, jl(e, f, h, d), c, l), S = E.segPlacements, b = E.hiddenGroups; return _o(xo, null, this.renderHiddenGroups(b, e), S.map((function (e) { var s = e.seg, l = e.rect, c = s.eventRange.instance.instanceId, d = y || Boolean(!t[c] && l), p = Kl(l && l.span), f = !y && l ? a.computeSegHStyle(l) : { left: 0, right: 0 }, h = Boolean(l) && l.stackForward > 0, E = Boolean(l) && l.span.end - l.span.start < u; return _o("div", { className: "fc-timegrid-event-harness" + (h ? " fc-timegrid-event-harness-inset" : ""), key: c, style: r(r({ visibility: d ? "" : "hidden" }, p), f) }, _o(ql, r({ seg: s, isDragging: n, isResizing: o, isDateSelecting: i, isSelected: c === v, isShort: E }, sr(s, g, m)))) }))) }, t.prototype.renderHiddenGroups = function (e, t) { var n = this.props, r = n.extraDateSpan, o = n.dateProfile, i = n.todayRange, a = n.nowDate, s = n.eventSelection, l = n.eventDrag, u = n.eventResize; return _o(xo, null, e.map((function (e) { var n, c, d = Kl(e.span), p = (n = e.entries, c = t, n.map((function (e) { return c[e.index] }))); return _o(Ll, { key: Ft(Ss(p)), hiddenSegs: p, top: d.top, bottom: d.bottom, extraDateSpan: r, dateProfile: o, todayRange: i, nowDate: a, eventSelection: s, eventDrag: l, eventResize: u }) }))) }, t.prototype.renderFillSegs = function (e, t) { var n = this.props, o = this.context, i = jl(e, n.date, n.slatCoords, o.options.eventMinHeight).map((function (o, i) { var a = e[i]; return _o("div", { key: ur(a.eventRange), className: "fc-timegrid-bg-harness", style: Kl(o) }, "bg-event" === t ? _o(ds, r({ seg: a }, sr(a, n.todayRange, n.nowDate))) : cs(t)) })); return _o(xo, null, i) }, t.prototype.renderNowIndicator = function (e) { var t = this.props, n = t.slatCoords, r = t.date; return n ? e.map((function (e, t) { return _o(is, { isAxis: !1, date: r, key: t }, (function (t, o, i, a) { return _o("div", { ref: t, className: ["fc-timegrid-now-indicator-line"].concat(o).join(" "), style: { top: n.computeDateTop(e.start, r) } }, a) })) })) : null }, t.prototype.computeSegHStyle = function (e) { var t, n, r = this.context, o = r.isRtl, i = r.options.slotEventOverlap, a = e.levelCoord, s = e.levelCoord + e.thickness; i && (s = Math.min(1, a + 2 * (s - a))), o ? (t = 1 - s, n = a) : (t = a, n = 1 - s); var l = { zIndex: e.stackDepth + 1, left: 100 * t + "%", right: 100 * n + "%" }; return i && !e.stackForward && (l[o ? "marginLeft" : "marginRight"] = 20), l }, t }(Uo); function Xl(e, t) { var n = t.todayRange, o = t.nowDate, i = t.eventSelection, a = t.eventDrag, s = t.eventResize, l = (a ? a.affectedInstances : null) || (s ? s.affectedInstances : null) || {}; return _o(xo, null, e.map((function (e) { var t = e.eventRange.instance.instanceId; return _o("div", { key: t, style: { visibility: l[t] ? "hidden" : "" } }, _o(ql, r({ seg: e, isDragging: !1, isResizing: !1, isDateSelecting: !1, isSelected: t === i, isShort: !1 }, sr(e, n, o)))) }))) } function Kl(e) { return e ? { top: e.start, bottom: -e.end } : { top: "", bottom: "" } } var $l = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.splitFgEventSegs = qt(Ol), t.splitBgEventSegs = qt(Ol), t.splitBusinessHourSegs = qt(Ol), t.splitNowIndicatorSegs = qt(Ol), t.splitDateSelectionSegs = qt(Ol), t.splitEventDrag = qt(Al), t.splitEventResize = qt(Al), t.rootElRef = ko(), t.cellElRefs = new Fa, t } return n(t, e), t.prototype.render = function () { var e = this, t = this.props, n = this.context.options.nowIndicator && t.slatCoords && t.slatCoords.safeComputeTop(t.nowDate), r = t.cells.length, o = this.splitFgEventSegs(t.fgEventSegs, r), i = this.splitBgEventSegs(t.bgEventSegs, r), a = this.splitBusinessHourSegs(t.businessHourSegs, r), s = this.splitNowIndicatorSegs(t.nowIndicatorSegs, r), l = this.splitDateSelectionSegs(t.dateSelectionSegs, r), u = this.splitEventDrag(t.eventDrag, r), c = this.splitEventResize(t.eventResize, r); return _o("div", { className: "fc-timegrid-cols", ref: this.rootElRef }, _o("table", { role: "presentation", style: { minWidth: t.tableMinWidth, width: t.clientWidth } }, t.tableColGroupNode, _o("tbody", { role: "presentation" }, _o("tr", { role: "row" }, t.axis && _o("td", { "aria-hidden": !0, className: "fc-timegrid-col fc-timegrid-axis" }, _o("div", { className: "fc-timegrid-col-frame" }, _o("div", { className: "fc-timegrid-now-indicator-container" }, "number" == typeof n && _o(is, { isAxis: !0, date: t.nowDate }, (function (e, t, r, o) { return _o("div", { ref: e, className: ["fc-timegrid-now-indicator-arrow"].concat(t).join(" "), style: { top: n } }, o) }))))), t.cells.map((function (n, r) { return _o(Zl, { key: n.key, elRef: e.cellElRefs.createRef(n.key), dateProfile: t.dateProfile, date: n.date, nowDate: t.nowDate, todayRange: t.todayRange, extraHookProps: n.extraHookProps, extraDataAttrs: n.extraDataAttrs, extraClassNames: n.extraClassNames, extraDateSpan: n.extraDateSpan, fgEventSegs: o[r], bgEventSegs: i[r], businessHourSegs: a[r], nowIndicatorSegs: s[r], dateSelectionSegs: l[r], eventDrag: u[r], eventResize: c[r], slatCoords: t.slatCoords, eventSelection: t.eventSelection, forPrint: t.forPrint }) })))))) }, t.prototype.componentDidMount = function () { this.updateCoords() }, t.prototype.componentDidUpdate = function () { this.updateCoords() }, t.prototype.updateCoords = function () { var e, t = this.props; t.onColCoords && null !== t.clientWidth && t.onColCoords(new So(this.rootElRef.current, (e = this.cellElRefs.currentMap, t.cells.map((function (t) { return e[t.key] }))), !0, !1)) }, t }(Uo); var Jl = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.processSlotOptions = qt(Ql), t.state = { slatCoords: null }, t.handleRootEl = function (e) { e ? t.context.registerInteractiveComponent(t, { el: e, isHitComboAllowed: t.props.isHitComboAllowed }) : t.context.unregisterInteractiveComponent(t) }, t.handleScrollRequest = function (e) { var n = t.props.onScrollTopRequest, r = t.state.slatCoords; if (n && r) { if (e.time) { var o = r.computeTimeTop(e.time); (o = Math.ceil(o)) && (o += 1), n(o) } return !0 } return !1 }, t.handleColCoords = function (e) { t.colCoords = e }, t.handleSlatCoords = function (e) { t.setState({ slatCoords: e }), t.props.onSlatCoords && t.props.onSlatCoords(e) }, t } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.state; return _o("div", { className: "fc-timegrid-body", ref: this.handleRootEl, style: { width: e.clientWidth, minWidth: e.tableMinWidth } }, _o(Hl, { axis: e.axis, dateProfile: e.dateProfile, slatMetas: e.slatMetas, clientWidth: e.clientWidth, minHeight: e.expandRows ? e.clientHeight : "", tableMinWidth: e.tableMinWidth, tableColGroupNode: e.axis ? e.tableColGroupNode : null, onCoords: this.handleSlatCoords }), _o($l, { cells: e.cells, axis: e.axis, dateProfile: e.dateProfile, businessHourSegs: e.businessHourSegs, bgEventSegs: e.bgEventSegs, fgEventSegs: e.fgEventSegs, dateSelectionSegs: e.dateSelectionSegs, eventSelection: e.eventSelection, eventDrag: e.eventDrag, eventResize: e.eventResize, todayRange: e.todayRange, nowDate: e.nowDate, nowIndicatorSegs: e.nowIndicatorSegs, clientWidth: e.clientWidth, tableMinWidth: e.tableMinWidth, tableColGroupNode: e.tableColGroupNode, slatCoords: t.slatCoords, onColCoords: this.handleColCoords, forPrint: e.forPrint })) }, t.prototype.componentDidMount = function () { this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest) }, t.prototype.componentDidUpdate = function (e) { this.scrollResponder.update(e.dateProfile !== this.props.dateProfile) }, t.prototype.componentWillUnmount = function () { this.scrollResponder.detach() }, t.prototype.queryHit = function (e, t) { var n = this.context, o = n.dateEnv, i = n.options, a = this.colCoords, s = this.props.dateProfile, l = this.state.slatCoords, u = this.processSlotOptions(this.props.slotDuration, i.snapDuration), c = u.snapDuration, d = u.snapsPerSlot, p = a.leftToIndex(e), f = l.positions.topToIndex(t); if (null != p && null != f) { var h = this.props.cells[p], v = l.positions.tops[f], g = l.positions.getHeight(f), m = (t - v) / g, y = f * d + Math.floor(m * d), E = this.props.cells[p].date, S = Ot(s.slotMinTime, At(c, y)), b = o.add(E, S), D = o.add(b, c); return { dateProfile: s, dateSpan: r({ range: { start: b, end: D }, allDay: !1 }, h.extraDateSpan), dayEl: a.els[p], rect: { left: a.lefts[p], right: a.rights[p], top: v, bottom: v + g }, layer: 0 } } return null }, t }(Bo); function Ql(e, t) { var n = t || e, r = Wt(e, n); return null === r && (n = e, r = 1), { snapDuration: n, snapsPerSlot: r } } var eu = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.sliceRange = function (e, t) { for (var n = [], r = 0; r < t.length; r += 1) { var o = jn(e, t[r]); o && n.push({ start: o.start, end: o.end, isStart: o.start.valueOf() === e.start.valueOf(), isEnd: o.end.valueOf() === e.end.valueOf(), col: r }) } return n }, t }(xa), tu = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.buildDayRanges = qt(nu), t.slicer = new eu, t.timeColsRef = ko(), t } return n(t, e), t.prototype.render = function () { var e = this, t = this.props, n = this.context, o = t.dateProfile, i = t.dayTableModel, a = n.options.nowIndicator, s = this.buildDayRanges(i, o, n.dateEnv); return _o(Ca, { unit: a ? "minute" : "day" }, (function (l, u) { return _o(Jl, r({ ref: e.timeColsRef }, e.slicer.sliceProps(t, o, null, n, s), { forPrint: t.forPrint, axis: t.axis, dateProfile: o, slatMetas: t.slatMetas, slotDuration: t.slotDuration, cells: i.cells[0], tableColGroupNode: t.tableColGroupNode, tableMinWidth: t.tableMinWidth, clientWidth: t.clientWidth, clientHeight: t.clientHeight, expandRows: t.expandRows, nowDate: l, nowIndicatorSegs: a && e.slicer.sliceNowDate(l, n, s), todayRange: u, onScrollTopRequest: t.onScrollTopRequest, onSlatCoords: t.onSlatCoords })) })) }, t }(Bo); function nu(e, t, n) { for (var r = [], o = 0, i = e.headerDates; o < i.length; o++) { var a = i[o]; r.push({ start: n.add(a, t.slotMinTime), end: n.add(a, t.slotMaxTime) }) } return r } var ru = [{ hours: 1 }, { minutes: 30 }, { minutes: 15 }, { seconds: 30 }, { seconds: 15 }]; function ou(e, t, n, r, o) { for (var i = new Date(0), a = e, s = Nt(0), l = n || function (e) { var t, n, r; for (t = ru.length - 1; t >= 0; t -= 1)if (null !== (r = Wt(n = Nt(ru[t]), e)) && r > 1) return n; return e }(r), u = []; Ut(a) < Ut(t);) { var c = o.add(i, a), d = null !== Wt(s, l); u.push({ date: c, time: a, key: c.toISOString(), isoTimeStr: zt(c), isLabeled: d }), a = Ot(a, r), s = Ot(s, r) } return u } var iu = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.buildTimeColsModel = qt(au), t.buildSlatMetas = qt(ou), t } return n(t, e), t.prototype.render = function () { var e = this, t = this.context, n = t.options, o = t.dateEnv, i = t.dateProfileGenerator, a = this.props, s = a.dateProfile, l = this.buildTimeColsModel(s, i), u = this.allDaySplitter.splitProps(a), c = this.buildSlatMetas(s.slotMinTime, s.slotMaxTime, n.slotLabelInterval, n.slotDuration, o), d = n.dayMinWidth, p = !d, f = d, h = n.dayHeaders && _o(Ra, { dates: l.headerDates, dateProfile: s, datesRepDistinctDays: !0, renderIntro: p ? this.renderHeadAxis : null }), v = !1 !== n.allDaySlot && function (t) { return _o(Sl, r({}, u.allDay, { dateProfile: s, dayTableModel: l, nextDayThreshold: n.nextDayThreshold, tableMinWidth: t.tableMinWidth, colGroupNode: t.tableColGroupNode, renderRowIntro: p ? e.renderTableRowAxis : null, showWeekNumbers: !1, expandRows: !1, headerAlignElRef: e.headerElRef, clientWidth: t.clientWidth, clientHeight: t.clientHeight, forPrint: a.forPrint }, e.getAllDayMaxEventProps())) }, g = function (t) { return _o(tu, r({}, u.timed, { dayTableModel: l, dateProfile: s, axis: p, slotDuration: n.slotDuration, slatMetas: c, forPrint: a.forPrint, tableColGroupNode: t.tableColGroupNode, tableMinWidth: t.tableMinWidth, clientWidth: t.clientWidth, clientHeight: t.clientHeight, onSlatCoords: e.handleSlatCoords, expandRows: t.expandRows, onScrollTopRequest: e.handleScrollTopRequest })) }; return f ? this.renderHScrollLayout(h, v, g, l.colCnt, d, c, this.state.slatCoords) : this.renderSimpleLayout(h, v, g) }, t }(Ml); function au(e, t) { var n = new Ta(e.renderRange, t); return new ka(n, !1) } var su = zo({ initialView: "timeGridWeek", optionRefiners: { allDaySlot: Boolean }, views: { timeGrid: { component: iu, usesMinMaxTime: !0, allDaySlot: !0, slotDuration: "00:30:00", slotEventOverlap: !0 }, timeGridDay: { type: "timeGrid", duration: { days: 1 } }, timeGridWeek: { type: "timeGrid", duration: { weeks: 1 } } } }), lu = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.state = { textId: xe() }, t } return n(t, e), t.prototype.render = function () { var e = this.context, t = e.theme, n = e.dateEnv, o = e.options, i = e.viewApi, a = this.props, s = a.cellId, l = a.dayDate, u = a.todayRange, c = this.state.textId, d = ro(l, u), p = o.listDayFormat ? n.format(l, o.listDayFormat) : "", f = o.listDaySideFormat ? n.format(l, o.listDaySideFormat) : "", h = r({ date: n.toDate(l), view: i, textId: c, text: p, sideText: f, navLinkAttrs: so(this.context, l), sideNavLinkAttrs: so(this.context, l, "day", !1) }, d), v = ["fc-list-day"].concat(oo(d, t)); return _o(Yo, { hookProps: h, classNames: o.dayHeaderClassNames, content: o.dayHeaderContent, defaultContent: uu, didMount: o.dayHeaderDidMount, willUnmount: o.dayHeaderWillUnmount }, (function (e, n, r, o) { return _o("tr", { ref: e, className: v.concat(n).join(" "), "data-date": Bt(l) }, _o("th", { scope: "colgroup", colSpan: 3, id: s, "aria-labelledby": c }, _o("div", { className: "fc-list-day-cushion " + t.getClass("tableCellShaded"), ref: r }, o))) })) }, t }(Uo); function uu(e) { return _o(xo, null, e.text && _o("a", r({ id: e.textId, className: "fc-list-day-text" }, e.navLinkAttrs), e.text), e.sideText && _o("a", r({ "aria-hidden": !0, className: "fc-list-day-side-text" }, e.sideNavLinkAttrs), e.sideText)) } var cu = ln({ hour: "numeric", minute: "2-digit", meridiem: "short" }), du = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t.prototype.render = function () { var e = this.props, t = this.context, n = e.seg, o = e.timeHeaderId, i = e.eventHeaderId, a = e.dateHeaderId, s = t.options.eventTimeFormat || cu; return _o(ns, { seg: n, timeText: "", disableDragging: !0, disableResizing: !0, defaultContent: function () { return function (e, t) { var n = cr(e, t); return _o("a", r({}, n), e.eventRange.def.title) }(n, t) }, isPast: e.isPast, isFuture: e.isFuture, isToday: e.isToday, isSelected: e.isSelected, isDragging: e.isDragging, isResizing: e.isResizing, isDateSelecting: e.isDateSelecting }, (function (e, r, l, u, c) { return _o("tr", { className: ["fc-list-event", c.event.url ? "fc-event-forced-url" : ""].concat(r).join(" "), ref: e }, function (e, t, n, r, o) { var i = n.options; if (!1 !== i.displayEventTime) { var a = e.eventRange.def, s = e.eventRange.instance, l = !1, u = void 0; if (a.allDay ? l = !0 : Vn(e.eventRange.range) ? e.isStart ? u = ar(e, t, n, null, null, s.range.start, e.end) : e.isEnd ? u = ar(e, t, n, null, null, e.start, s.range.end) : l = !0 : u = ar(e, t, n), l) { var c = { text: n.options.allDayText, view: n.viewApi }; return _o(Yo, { hookProps: c, classNames: i.allDayClassNames, content: i.allDayContent, defaultContent: pu, didMount: i.allDayDidMount, willUnmount: i.allDayWillUnmount }, (function (e, t, n, i) { return _o("td", { ref: e, headers: r + " " + o, className: ["fc-list-event-time"].concat(t).join(" ") }, i) })) } return _o("td", { className: "fc-list-event-time" }, u) } return null }(n, s, t, o, a), _o("td", { "aria-hidden": !0, className: "fc-list-event-graphic" }, _o("span", { className: "fc-list-event-dot", style: { borderColor: c.borderColor || c.backgroundColor } })), _o("td", { ref: l, headers: i + " " + a, className: "fc-list-event-title" }, u)) })) }, t }(Uo); function pu(e) { return e.text } var fu = function (e) { function t() { var t = null !== e && e.apply(this, arguments) || this; return t.computeDateVars = qt(vu), t.eventStoreToSegs = qt(t._eventStoreToSegs), t.state = { timeHeaderId: xe(), eventHeaderId: xe(), dateHeaderIdRoot: xe() }, t.setRootEl = function (e) { e ? t.context.registerInteractiveComponent(t, { el: e }) : t.context.unregisterInteractiveComponent(t) }, t } return n(t, e), t.prototype.render = function () { var e = this, t = this.props, n = this.context, r = ["fc-list", n.theme.getClass("table"), !1 !== n.options.stickyHeaderDates ? "fc-list-sticky" : ""], o = this.computeDateVars(t.dateProfile), i = o.dayDates, a = o.dayRanges, s = this.eventStoreToSegs(t.eventStore, t.eventUiBases, a); return _o(ti, { viewSpec: n.viewSpec, elRef: this.setRootEl }, (function (n, o) { return _o("div", { ref: n, className: r.concat(o).join(" ") }, _o(Va, { liquid: !t.isHeightAuto, overflowX: t.isHeightAuto ? "visible" : "hidden", overflowY: t.isHeightAuto ? "visible" : "auto" }, s.length > 0 ? e.renderSegList(s, i) : e.renderEmptyMessage())) })) }, t.prototype.renderEmptyMessage = function () { var e = this.context, t = e.options, n = e.viewApi, r = { text: t.noEventsText, view: n }; return _o(Yo, { hookProps: r, classNames: t.noEventsClassNames, content: t.noEventsContent, defaultContent: hu, didMount: t.noEventsDidMount, willUnmount: t.noEventsWillUnmount }, (function (e, t, n, r) { return _o("div", { className: ["fc-list-empty"].concat(t).join(" "), ref: e }, _o("div", { className: "fc-list-empty-cushion", ref: n }, r)) })) }, t.prototype.renderSegList = function (e, t) { var n = this.context, o = n.theme, i = n.options, a = this.state, s = a.timeHeaderId, l = a.eventHeaderId, u = a.dateHeaderIdRoot, c = function (e) { var t, n, r = []; for (t = 0; t < e.length; t += 1)(r[(n = e[t]).dayIndex] || (r[n.dayIndex] = [])).push(n); return r }(e); return _o(Ca, { unit: "day" }, (function (e, n) { for (var a = [], d = 0; d < c.length; d += 1) { var p = c[d]; if (p) { var f = Bt(t[d]), h = u + "-" + f; a.push(_o(lu, { key: f, cellId: h, dayDate: t[d], todayRange: n })); for (var v = 0, g = p = tr(p, i.eventOrder); v < g.length; v++) { var m = g[v]; a.push(_o(du, r({ key: f + ":" + m.eventRange.instance.instanceId, seg: m, isDragging: !1, isResizing: !1, isDateSelecting: !1, isSelected: !1, timeHeaderId: s, eventHeaderId: l, dateHeaderId: h }, sr(m, n, e)))) } } } return _o("table", { className: "fc-list-table " + o.getClass("table") }, _o("thead", null, _o("tr", null, _o("th", { scope: "col", id: s }, i.timeHint), _o("th", { scope: "col", "aria-hidden": !0 }), _o("th", { scope: "col", id: l }, i.eventHint))), _o("tbody", null, a)) })) }, t.prototype._eventStoreToSegs = function (e, t, n) { return this.eventRangesToSegs(Xn(e, t, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, n) }, t.prototype.eventRangesToSegs = function (e, t) { for (var n = [], r = 0, o = e; r < o.length; r++) { var i = o[r]; n.push.apply(n, this.eventRangeToSegs(i, t)) } return n }, t.prototype.eventRangeToSegs = function (e, t) { var n, r, o, i = this.context.dateEnv, a = this.context.options.nextDayThreshold, s = e.range, l = e.def.allDay, u = []; for (n = 0; n < t.length; n += 1)if ((r = jn(s, t[n])) && (o = { component: this, eventRange: e, start: r.start, end: r.end, isStart: e.isStart && r.start.valueOf() === s.start.valueOf(), isEnd: e.isEnd && r.end.valueOf() === s.end.valueOf(), dayIndex: n }, u.push(o), !o.isEnd && !l && n + 1 < t.length && s.end < i.add(t[n + 1].start, a))) { o.end = s.end, o.isEnd = !0; break } return u }, t }(Bo); function hu(e) { return e.text } function vu(e) { for (var t = lt(e.renderRange.start), n = e.renderRange.end, r = [], o = []; t < n;)r.push(t), o.push({ start: t, end: tt(t, 1) }), t = tt(t, 1); return { dayDates: r, dayRanges: o } } function gu(e) { return !1 === e ? null : ln(e) } var mu = zo({ optionRefiners: { listDayFormat: gu, listDaySideFormat: gu, noEventsClassNames: yn, noEventsContent: yn, noEventsDidMount: yn, noEventsWillUnmount: yn }, views: { list: { component: fu, buttonTextKey: "list", listDayFormat: { month: "long", day: "numeric", year: "numeric" } }, listDay: { type: "list", duration: { days: 1 }, listDayFormat: { weekday: "long" } }, listWeek: { type: "list", duration: { weeks: 1 }, listDayFormat: { weekday: "long" }, listDaySideFormat: { month: "long", day: "numeric", year: "numeric" } }, listMonth: { type: "list", duration: { month: 1 }, listDaySideFormat: { weekday: "long" } }, listYear: { type: "list", duration: { year: 1 }, listDaySideFormat: { weekday: "long" } } } }), yu = function (e) { function t() { return null !== e && e.apply(this, arguments) || this } return n(t, e), t }(wo); yu.prototype.classes = { root: "fc-theme-bootstrap", table: "table-bordered", tableCellShaded: "table-active", buttonGroup: "btn-group", button: "btn btn-primary", buttonActive: "active", popover: "popover", popoverHeader: "popover-header", popoverContent: "popover-body" }, yu.prototype.baseIconClass = "fa", yu.prototype.iconClasses = { close: "fa-times", prev: "fa-chevron-left", next: "fa-chevron-right", prevYear: "fa-angle-double-left", nextYear: "fa-angle-double-right" }, yu.prototype.rtlIconClasses = { prev: "fa-chevron-right", next: "fa-chevron-left", prevYear: "fa-angle-double-right", nextYear: "fa-angle-double-left" }, yu.prototype.iconOverrideOption = "bootstrapFontAwesome", yu.prototype.iconOverrideCustomButtonOption = "bootstrapFontAwesome", yu.prototype.iconOverridePrefix = "fa-"; var Eu = zo({ themeClasses: { bootstrap: yu } }), Su = "https://www.googleapis.com/calendar/v3/calendars"; var bu = zo({ eventSourceDefs: [{ parseMeta: function (e) { var t = e.googleCalendarId; return !t && e.url && (t = function (e) { var t; if (/^[^/]+@([^/.]+\.)*(google|googlemail|gmail)\.com$/.test(e)) return e; if ((t = /^https:\/\/www.googleapis.com\/calendar\/v3\/calendars\/([^/]*)/.exec(e)) || (t = /^https?:\/\/www.google.com\/calendar\/feeds\/([^/]*)/.exec(e))) return decodeURIComponent(t[1]); return null }(e.url)), t ? { googleCalendarId: t, googleCalendarApiKey: e.googleCalendarApiKey, googleCalendarApiBase: e.googleCalendarApiBase, extraParams: e.extraParams } : null }, fetch: function (e, t, n) { var o = e.context, i = o.dateEnv, a = o.options, s = e.eventSource.meta, l = s.googleCalendarApiKey || a.googleCalendarApiKey; if (l) { var u = function (e) { var t = e.googleCalendarApiBase; t || (t = Su); return t + "/" + encodeURIComponent(e.googleCalendarId) + "/events" }(s), c = s.extraParams, d = "function" == typeof c ? c() : c, p = function (e, t, n, o) { var i, a, s; o.canComputeOffset ? (a = o.formatIso(e.start), s = o.formatIso(e.end)) : (a = tt(e.start, -1).toISOString(), s = tt(e.end, 1).toISOString()); i = r(r({}, n || {}), { key: t, timeMin: a, timeMax: s, singleEvents: !0, maxResults: 9999 }), "local" !== o.timeZone && (i.timeZone = o.timeZone); return i }(e.range, l, d, i); _i("GET", u, p, (function (e, r) { var o, i; e.error ? n({ message: "Google Calendar API: " + e.error.message, errors: e.error.errors, xhr: r }) : t({ rawEvents: (o = e.items, i = p.timeZone, o.map((function (e) { return function (e, t) { var n = e.htmlLink || null; n && t && (n = function (e, t) { return e.replace(/(\?.*?)?(#|$)/, (function (e, n, r) { return (n ? n + "&" : "?") + t + r })) }(n, "ctz=" + t)); return { id: e.id, title: e.summary, start: e.start.dateTime || e.start.date, end: e.end.dateTime || e.end.date, url: n, location: e.location, description: e.description, attachments: e.attachments || [], extendedProps: (e.extendedProperties || {}).shared || {} } }(e, i) }))), xhr: r }) }), (function (e, t) { n({ message: e, xhr: t }) })) } else n({ message: "Specify a googleCalendarApiKey. See http://fullcalendar.io/docs/google_calendar/" }) } }], optionRefiners: { googleCalendarApiKey: String }, eventSourceRefiners: { googleCalendarApiKey: String, googleCalendarId: String, googleCalendarApiBase: String, extraParams: yn } }); return xi.push($s, Cl, su, mu, Eu, bu), e.BASE_OPTION_DEFAULTS = cn, e.BASE_OPTION_REFINERS = un, e.BaseComponent = Uo, e.BgEvent = ds, e.BootstrapTheme = yu, e.Calendar = Cs, e.CalendarApi = kr, e.CalendarContent = fa, e.CalendarDataManager = Ni, e.CalendarDataProvider = ji, e.CalendarRoot = ga, e.Component = Ro, e.ContentHook = Xo, e.CustomContentRenderContext = Zo, e.DateComponent = Bo, e.DateEnv = Lr, e.DateProfileGenerator = ai, e.DayCellContent = ss, e.DayCellRoot = us, e.DayGridView = bl, e.DayHeader = Ra, e.DaySeriesModel = Ta, e.DayTable = Sl, e.DayTableModel = ka, e.DayTableSlicer = El, e.DayTimeCols = tu, e.DayTimeColsSlicer = eu, e.DayTimeColsView = iu, e.DelayedRunner = Mi, e.Draggable = Zs, e.ElementDragging = oa, e.ElementScrollController = Do, e.Emitter = Eo, e.EventApi = xr, e.EventRoot = ns, e.EventSourceApi = ye, e.FeaturefulElementDragging = Os, e.Fragment = xo, e.Interaction = ea, e.ListView = fu, e.MoreLinkRoot = ms, e.MountHook = $o, e.NamedTimeZoneImpl = Gi, e.NowIndicatorRoot = is, e.NowTimer = Ca, e.PointerDragging = Ts, e.PositionCache = So, e.RefMap = Fa, e.RenderHook = Yo, e.ScrollController = bo, e.ScrollResponder = Ho, e.Scroller = Va, e.SegHierarchy = qi, e.SimpleScrollGrid = ts, e.Slicer = xa, e.Splitter = to, e.StandardEvent = rs, e.Table = ml, e.TableDateCell = Sa, e.TableDowCell = Da, e.TableView = Js, e.Theme = wo, e.ThirdPartyDraggable = Ks, e.TimeCols = Jl, e.TimeColsSlatsCoords = Pl, e.TimeColsView = Ml, e.ViewApi = Cr, e.ViewContextType = Oo, e.ViewRoot = ti, e.WeekNumberRoot = fs, e.WindowScrollController = Co, e.addDays = tt, e.addDurations = Ot, e.addMs = nt, e.addWeeks = et, e.allowContextMenu = ze, e.allowSelection = Fe, e.applyMutationToEventStore = Sr, e.applyStyle = we, e.applyStyleProp = Re, e.asCleanDays = function (e) { return e.years || e.months || e.milliseconds ? 0 : e.days }, e.asRoughMinutes = function (e) { return Ut(e) / 6e4 }, e.asRoughMs = Ut, e.asRoughSeconds = function (e) { return Ut(e) / 1e3 }, e.binarySearch = Qi, e.buildClassNameNormalizer = Jo, e.buildDayRanges = nu, e.buildDayTableModel = Dl, e.buildEntryKey = Zi, e.buildEventApis = Ir, e.buildEventRangeKey = ur, e.buildHashFromArray = function (e, t) { for (var n = {}, r = 0; r < e.length; r += 1) { var o = t(e[r], r); n[o[0]] = o[1] } return n }, e.buildIsoString = Ft, e.buildNavLinkAttrs = so, e.buildSegCompareObj = nr, e.buildSegTimeText = ar, e.buildSlatMetas = ou, e.buildTimeColsModel = au, e.collectFromHash = kt, e.combineEventUis = xn, e.compareByFieldSpec = qe, e.compareByFieldSpecs = Ge, e.compareNumbers = Ke, e.compareObjs = _t, e.computeEarliestSegStart = Ss, e.computeEdges = ho, e.computeFallbackHeaderFormat = ma, e.computeHeightAndMargins = function (e) { return e.getBoundingClientRect().height + function (e) { var t = window.getComputedStyle(e); return parseInt(t.marginTop, 10) + parseInt(t.marginBottom, 10) }(e) }, e.computeInnerRect = vo, e.computeRect = go, e.computeSegDraggable = rr, e.computeSegEndResizable = ir, e.computeSegStartResizable = or, e.computeShrinkWidth = Ba, e.computeSmallestCellWidth = Je, e.computeVisibleDayRange = Wn, e.config = ia, e.constrainPoint = Kr, e.createAriaClickAttrs = He, e.createContext = Mo, e.createDuration = Nt, e.createElement = _o, e.createEmptyEventStore = Dn, e.createEventInstance = mt, e.createEventUi = kn, e.createFormatter = ln, e.createPlugin = zo, e.createPortal = Io, e.createRef = ko, e.diffDates = Fn, e.diffDayAndTime = it, e.diffDays = ot, e.diffPoints = Jr, e.diffWeeks = rt, e.diffWholeDays = st, e.diffWholeWeeks = at, e.disableCursor = Ue, e.elementClosest = Se, e.elementMatches = be, e.enableCursor = We, e.eventTupleToStore = Sn, e.filterEventStoreDefs = wn, e.filterHash = St, e.findDirectChildren = function (e, t) { for (var n = e instanceof HTMLElement ? [e] : e, r = [], o = 0; o < n.length; o += 1)for (var i = n[o].children, a = 0; a < i.length; a += 1) { var s = i[a]; t && !be(s, t) || r.push(s) } return r }, e.findElements = De, e.flexibleCompare = Ye, e.flushToDom = Po, e.formatDate = function (e, t) { void 0 === t && (t = {}); var n = jr(t), r = ln(t), o = n.createMarkerMeta(e); return o ? n.format(o.marker, r, { forcedTzo: o.forcedTzo }) : "" }, e.formatDayString = Bt, e.formatIsoTimeString = zt, e.formatRange = function (e, t, n) { var r = jr("object" == typeof n && n ? n : {}), o = ln(n), i = r.createMarkerMeta(e), a = r.createMarkerMeta(t); return i && a ? r.formatRange(i.marker, a.marker, o, { forcedStartTzo: i.forcedTzo, forcedEndTzo: a.forcedTzo, isEndExclusive: n.isEndExclusive, defaultSeparator: cn.defaultRangeSeparator }) : "" }, e.getAllowYScrolling = ja, e.getCanVGrowWithinCell = Qr, e.getClippingParents = mo, e.getDateMeta = ro, e.getDayClassNames = oo, e.getDefaultEventEnd = Er, e.getElRoot = Te, e.getElSeg = Jn, e.getEntrySpanEnd = Yi, e.getEventClassNames = lr, e.getEventTargetViaRoot = _e, e.getIsRtlScrollbarOnLeft = co, e.getRectCenter = $r, e.getRelevantEvents = bn, e.getScrollGridClassNames = Ka, e.getScrollbarWidths = po, e.getSectionClassNames = $a, e.getSectionHasLiquidHeight = za, e.getSegAnchorAttrs = cr, e.getSegMeta = sr, e.getSlotClassNames = function (e, t) { var n = ["fc-slot", "fc-slot-" + Qe[e.dow]]; return e.isDisabled ? n.push("fc-slot-disabled") : (e.isToday && (n.push("fc-slot-today"), n.push(t.getClass("today"))), e.isPast && n.push("fc-slot-past"), e.isFuture && n.push("fc-slot-future")), n }, e.getStickyFooterScrollbar = es, e.getStickyHeaderDates = Qa, e.getUnequalProps = Rt, e.getUniqueDomId = xe, e.globalLocales = Ur, e.globalPlugins = xi, e.greatestDurationDenominator = Vt, e.groupIntersectingEntries = Xi, e.guid = Le, e.hasBgRendering = Kn, e.hasShrinkWidth = Xa, e.identity = yn, e.interactionSettingsStore = ra, e.interactionSettingsToStore = na, e.intersectRanges = jn, e.intersectRects = Xr, e.intersectSpans = $i, e.isArraysEqual = Gt, e.isColPropsEqual = qa, e.isDateSelectionValid = Pa, e.isDateSpansEqual = fr, e.isInt = $e, e.isInteractionValid = Ia, e.isMultiDayRange = Vn, e.isPropsEqual = wt, e.isPropsValid = Ha, e.isValidDate = vt, e.joinSpans = Ki, e.listenBySelector = Ie, e.mapHash = bt, e.memoize = qt, e.memoizeArraylike = function (e, t, n) { var r = this, o = [], i = []; return function (a) { for (var s = o.length, l = a.length, u = 0; u < s; u += 1)if (a[u]) { if (!Gt(o[u], a[u])) { n && n(i[u]); var c = e.apply(r, a[u]); t && t(c, i[u]) || (i[u] = c) } } else n && n(i[u]); for (; u < l; u += 1)i[u] = e.apply(r, a[u]); return o = a, i.splice(l), i } }, e.memoizeHashlike = function (e, t, n) { var r = this, o = {}, i = {}; return function (a) { var s = {}; for (var l in a) if (i[l]) if (Gt(o[l], a[l])) s[l] = i[l]; else { n && n(i[l]); var u = e.apply(r, a[l]); s[l] = t && t(u, i[l]) ? i[l] : u } else s[l] = e.apply(r, a[l]); return o = a, i = s, s } }, e.memoizeObjArg = Yt, e.mergeEventStores = Cn, e.multiplyDuration = At, e.padStart = Ze, e.parseBusinessHours = Yr, e.parseClassNames = Rn, e.parseDragMeta = sa, e.parseEventDef = Ln, e.parseFieldSpecs = je, e.parseMarker = Ar, e.pointInsideRect = Zr, e.preventContextMenu = Be, e.preventDefault = Me, e.preventSelection = Ve, e.rangeContainsMarker = Zn, e.rangeContainsRange = Yn, e.rangesEqual = Gn, e.rangesIntersect = qn, e.refineEventDef = On, e.refineProps = mn, e.removeElement = Ee, e.removeExact = function (e, t) { for (var n = 0, r = 0; r < e.length;)e[r] === t ? (e.splice(r, 1), n += 1) : r += 1; return n }, e.render = To, e.renderChunkContent = Ga, e.renderFill = cs, e.renderMicroColGroup = Ya, e.renderScrollShim = Ja, e.requestJson = _i, e.sanitizeShrinkWidth = Za, e.setElSeg = $n, e.setRef = Fo, e.sliceEventStore = Xn, e.sliceEvents = function (e, t) { return Xn(e.eventStore, e.eventUiBases, e.dateProfile.activeRange, t ? e.nextDayThreshold : null).fg }, e.sortEventSegs = tr, e.startOfDay = lt, e.translateRect = function (e, t, n) { return { left: e.left + t, right: e.right + t, top: e.top + n, bottom: e.bottom + n } }, e.triggerDateSelect = mr, e.unmountComponentAtNode = No, e.unpromisify = yo, e.version = "5.10.1", e.whenTransitionDone = Ne, e.wholeDivideDurations = Wt, Object.defineProperty(e, "__esModule", { value: !0 }), e }({});